{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":0},{"_id":"themes/hexo-theme-aircloud/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-aircloud/source/css/aircloud.css.map","path":"css/aircloud.css.map","modified":0,"renderable":1},{"_id":"themes/hexo-theme-aircloud/source/css/aircloud.css","path":"css/aircloud.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-aircloud/source/css/aircloud.less","path":"css/aircloud.less","modified":0,"renderable":1},{"_id":"themes/hexo-theme-aircloud/source/css/gitment.css","path":"css/gitment.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-aircloud/source/js/gitment.js","path":"js/gitment.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-aircloud/source/js/index.js","path":"js/index.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/about/index.md","hash":"e3b787f49863ed2c08b42545c2eb2714ea6b4e9b","modified":1646806990130},{"_id":"source/tags/index.md","hash":"22dd3308e0a3db852e008fa8c8d526142e790dcb","modified":1646806958777},{"_id":"source/_posts/ForkJoinSumCalculator.md","hash":"1e722211f179f799e52da2c3b72b8d73337c06a3","modified":1647332699522},{"_id":"source/_posts/MyBatis-Plugin-Development.md","hash":"812035fc5c038833a136f0b5bd45426e2d736b12","modified":1646897321020},{"_id":"source/_posts/Install-WSL.md","hash":"b3960825643350dacce1f7ce33031302a89c36de","modified":1646807387803},{"_id":"source/_posts/Hexo-Theme-AirCloud.md","hash":"6c36ca6c3ce9559ebed45d19b06c39eab06f76f6","modified":1646805957798},{"_id":"source/_posts/Observer.md","hash":"231a45a363d569186d26910e9887a4f83904fd60","modified":1646992809676},{"_id":"source/_posts/MySql-Transaction-Isolation-Level.md","hash":"7ecc66aaaa70f72cca7e4f4ae53890fc798e5d00","modified":1646897763975},{"_id":"source/_posts/Run-Time-Data-Areas.md","hash":"7ac966873bd441d5bdcd62699ba4359c6f910ccb","modified":1646895695270},{"_id":"source/_posts/俞敏洪在同济大学的的演讲.md","hash":"76b8488deee608e350c9d21c2c007de4a548bf5a","modified":1647568675099},{"_id":"source/img/avatar.jpg","hash":"5304e3982426a771746874abc1e70bc93261e197","modified":1646804013857},{"_id":"themes/hexo-theme-aircloud/layout/catagory.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1646796566886},{"_id":"themes/hexo-theme-aircloud/layout/page.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1646796566893},{"_id":"themes/hexo-theme-aircloud/source/_less/about.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1646796566912},{"_id":"themes/hexo-theme-aircloud/source/_less/about.less","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1646796566913},{"_id":"themes/hexo-theme-aircloud/source/_less/diff.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1646796566923},{"_id":"themes/hexo-theme-aircloud/source/_less/diff.less","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1646796566924},{"_id":"themes/hexo-theme-aircloud/source/_less/page.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1646796566944},{"_id":"themes/hexo-theme-aircloud/source/_less/page.less","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1646796566945},{"_id":"themes/hexo-theme-aircloud/source/_less/theme.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1646796566952},{"_id":"themes/hexo-theme-aircloud/source/_less/theme.less","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1646796566954},{"_id":"themes/hexo-theme-aircloud/.gitignore","hash":"e0ed028c2b034754ba17b141041c4b6fb2499177","modified":1646796566861},{"_id":"themes/hexo-theme-aircloud/_config.yml","hash":"0ad3a6ab2c9bb07fb1e030052622fdcde5c6f28a","modified":1646804491551},{"_id":"themes/hexo-theme-aircloud/languages/ko.yml","hash":"53ab9cd27ca3fd5959743362b5aa62d868b0c795","modified":1646796566868},{"_id":"themes/hexo-theme-aircloud/languages/zh.yml","hash":"6c30c31f4ec188949caab414aa81296f3f49df53","modified":1646796566869},{"_id":"themes/hexo-theme-aircloud/LICENSE","hash":"278d4c4d923734a79286b3a5b524723c107c132a","modified":1646796566862},{"_id":"themes/hexo-theme-aircloud/readme-en.md","hash":"abb3560f471191278681891903353919f606c7b7","modified":1646796566901},{"_id":"themes/hexo-theme-aircloud/languages/en.yml","hash":"8326653662ab628d33289c7fdaea3701274bb6fa","modified":1646796566867},{"_id":"themes/hexo-theme-aircloud/layout/about.ejs","hash":"24512de66f4e00cebe9be8e97bcfc2e4a4efdd12","modified":1646796566883},{"_id":"themes/hexo-theme-aircloud/layout/404.ejs","hash":"51ac993ccbd409d7bfe0deee0de8015a89b5a15c","modified":1646796566872},{"_id":"themes/hexo-theme-aircloud/readme.md","hash":"ed6d035a9c024f0787322d5c579fec405e3bdf40","modified":1646796566903},{"_id":"themes/hexo-theme-aircloud/layout/index.ejs","hash":"d576808a0a4179e4fa8a44615aab754fbca33f40","modified":1646796566887},{"_id":"themes/hexo-theme-aircloud/layout/archive.ejs","hash":"fe44df8eacf6e5e27df30b450033b18cae88f523","modified":1646796566885},{"_id":"themes/hexo-theme-aircloud/layout/_partial/donate.ejs","hash":"d97224a63f76045cbd0a53a3cabef3f0fd010ad3","modified":1646796566874},{"_id":"themes/hexo-theme-aircloud/layout/post.ejs","hash":"5f3fcc6f6d86b8e43bf2d76cf809753e9b9f89aa","modified":1646796566895},{"_id":"themes/hexo-theme-aircloud/layout/layout.ejs","hash":"d02b0dcd34e10b7e73bdd72bd964672a1f760b8f","modified":1646796566891},{"_id":"themes/hexo-theme-aircloud/layout/tags.ejs","hash":"4de0555bf1f0e35fae7f797d43d7a8a0caf843ca","modified":1646796566897},{"_id":"themes/hexo-theme-aircloud/layout/_partial/toc.ejs","hash":"20106463b4885e93ef69122d69464174c45df71d","modified":1646796566881},{"_id":"themes/hexo-theme-aircloud/layout/_partial/footer.ejs","hash":"236e217c976680136272652332f29fa4dca37131","modified":1646796566875},{"_id":"themes/hexo-theme-aircloud/layout/_partial/nav.ejs","hash":"94cf4f06c500166ba2a2f70807660b612b9a1d6d","modified":1646796566879},{"_id":"themes/hexo-theme-aircloud/layout/_partial/head.ejs","hash":"f2efb1f71199e44f1986d2f4723191fa728b332a","modified":1646796566877},{"_id":"themes/hexo-theme-aircloud/source/css/aircloud.less","hash":"cf339e918c04f33837516cf4f54e27640cf48460","modified":1646796566967},{"_id":"themes/hexo-theme-aircloud/source/css/aircloud.css.map","hash":"50db34961d11f6f461e23912609d25141068a6fc","modified":1646796566965},{"_id":"themes/hexo-theme-aircloud/source/css/aircloud.css","hash":"047eda914647ccee61c3858114750c932ab2cbda","modified":1646796566964},{"_id":"themes/hexo-theme-aircloud/source/css/gitment.css","hash":"c6951e8c4d709f1917c2cf78b9777d9610cb6532","modified":1646796566969},{"_id":"themes/hexo-theme-aircloud/source/js/index.js","hash":"e44073fdb9d7dd334b39b65fc741172e62d42330","modified":1646796566980},{"_id":"themes/hexo-theme-aircloud/source/_less/archive.css","hash":"372da40133108078c91c3fc73b361aa81436248f","modified":1646796566916},{"_id":"themes/hexo-theme-aircloud/source/_less/archive.less","hash":"b27c479274d648918f29452aae8139bafe997804","modified":1646796566918},{"_id":"themes/hexo-theme-aircloud/source/_less/donate.less","hash":"efaf3572a73c26aff77331e18543b6b2336931c0","modified":1646796566927},{"_id":"themes/hexo-theme-aircloud/source/_less/common.css","hash":"0e80d6a42e463be27180f60c38d50615445c3177","modified":1646796566919},{"_id":"themes/hexo-theme-aircloud/source/_less/gitment.css","hash":"01fdbed1c91ed4bd685886c298383809a0c5f1d7","modified":1646796566929},{"_id":"themes/hexo-theme-aircloud/source/_less/gitment.less","hash":"f6f18d9e7451c501234a1d2166813edae63cd7d5","modified":1646796566930},{"_id":"themes/hexo-theme-aircloud/source/_less/donate.css","hash":"d5c94d24c9ea63b1c2eb186a333f07a28a1f88a6","modified":1646796566926},{"_id":"themes/hexo-theme-aircloud/source/_less/common.less","hash":"b09d13483dbc701fa34dedb6d2db8177e5fe7ad7","modified":1646796566922},{"_id":"themes/hexo-theme-aircloud/source/_less/hightlight.less","hash":"1eaef200f09685294c7382462b4774de2b4ba1f3","modified":1646796566934},{"_id":"themes/hexo-theme-aircloud/source/_less/hightlight.css","hash":"1eaef200f09685294c7382462b4774de2b4ba1f3","modified":1646796566933},{"_id":"themes/hexo-theme-aircloud/source/_less/index.css","hash":"8853826ff7e2f679f481f7de6cd742d9aaf76778","modified":1646796566936},{"_id":"themes/hexo-theme-aircloud/source/_less/layout.css","hash":"f0d83db7d9a041c540cdeb093cedffdb982f90e4","modified":1646796566939},{"_id":"themes/hexo-theme-aircloud/source/_less/index.less","hash":"91f05eb476510fcbb2bed556092dfd889656ef0b","modified":1646796566937},{"_id":"themes/hexo-theme-aircloud/source/_less/layout.less","hash":"332a42d5ab45c73a25c90b182ede63a4dfdfbe30","modified":1646796566941},{"_id":"themes/hexo-theme-aircloud/source/_less/nav.css","hash":"66675a061db5067c088d314193a0f1ec8ef53276","modified":1646796566942},{"_id":"themes/hexo-theme-aircloud/source/_less/nav.less","hash":"5828d1f0436701c153e1f10d39ee2b2e251a6eae","modified":1646796566943},{"_id":"themes/hexo-theme-aircloud/source/_less/post.css","hash":"ac889864719f7c261a6d1f48c7ffe4d177e662eb","modified":1646796566947},{"_id":"themes/hexo-theme-aircloud/source/_less/variables.css","hash":"c5d6ce4d904e7c108fbf4f2392eb2917bed636d8","modified":1646796566959},{"_id":"themes/hexo-theme-aircloud/source/_less/post.less","hash":"070f68106148a453e4c00b55d0644badfd9b4a64","modified":1646796566948},{"_id":"themes/hexo-theme-aircloud/source/_less/variables.less","hash":"e881ecdb19c4c5c6452abd5d0c6294c83fe6cb53","modified":1646796566960},{"_id":"themes/hexo-theme-aircloud/source/_less/tag.less","hash":"e75576604e73ce22559ea0ff7816a52f72772219","modified":1646796566951},{"_id":"themes/hexo-theme-aircloud/source/_less/tag.css","hash":"bde136456c498eb671ea75c5315130d7dea1d9ba","modified":1646796566950},{"_id":"themes/hexo-theme-aircloud/source/_less/toc.css","hash":"c17dd8c7c0326ff41eec9c25dbbcb19895f07367","modified":1646796566956},{"_id":"themes/hexo-theme-aircloud/source/_less/toc.less","hash":"8ab3e0bc1f7c9e466d7916e0bb2bfe7f2b4e1386","modified":1646796566957},{"_id":"themes/hexo-theme-aircloud/source/_less/_partial/footer.css","hash":"c14a3aac90c0d6fc0c4cdcd84b98e2ce3005d47f","modified":1646796566907},{"_id":"themes/hexo-theme-aircloud/source/_less/_partial/footer.less","hash":"a4137692c2b8fd287ac014feb3e73aa0502f7c23","modified":1646796566911},{"_id":"themes/hexo-theme-aircloud/source/_less/_partial/footer.css.map","hash":"9e8d4df5d08425de5a8b247d0dd8b805c6edc661","modified":1646796566909},{"_id":"themes/hexo-theme-aircloud/source/js/gitment.js","hash":"7d7a9c07794fb31fd6d4620e473d05e14e27285d","modified":1646796566977},{"_id":"themes/hexo-theme-aircloud/source/img/avatar.jpg","hash":"5304e3982426a771746874abc1e70bc93261e197","modified":1646804013857},{"_id":"public/search.json","hash":"b7db95de60ecff52a00168c3057cc1df61ed07c0","modified":1658361081389},{"_id":"public/tags/index.html","hash":"19c6d7603727149b5266d1a7d08118c64aa97ea3","modified":1658282278377},{"_id":"public/about/index.html","hash":"35c8265474e791981c25b317abcf9445b30622c4","modified":1647568211820},{"_id":"public/2022/03/11/Observer/index.html","hash":"9209f273444ff1c333b6e4ba89a9d3294164489d","modified":1647568211820},{"_id":"public/2022/03/09/Run-Time-Data-Areas/index.html","hash":"5ae9630bf820a2affe3c9317282c88ed9937319c","modified":1647568211820},{"_id":"public/2022/03/09/Install-WSL/index.html","hash":"822532e7b27c73fca0c64505c33ed80e06a3a6cb","modified":1647568211820},{"_id":"public/archives/index.html","hash":"6847ed286e21cde5986cdcfda894e4def11e573a","modified":1658282278377},{"_id":"public/archives/2022/index.html","hash":"6847ed286e21cde5986cdcfda894e4def11e573a","modified":1658282278377},{"_id":"public/index.html","hash":"30d5a94f810f675c8ca1b0c22fa918e51e97cc9f","modified":1658282278377},{"_id":"public/archives/2022/03/index.html","hash":"6847ed286e21cde5986cdcfda894e4def11e573a","modified":1658282278377},{"_id":"public/tags/Hexo/index.html","hash":"c3d1ad8b9712a24813cddc8c2c922a80ea1693bd","modified":1658282278377},{"_id":"public/tags/WSL/index.html","hash":"c3d1ad8b9712a24813cddc8c2c922a80ea1693bd","modified":1658282278377},{"_id":"public/tags/Java/index.html","hash":"c3d1ad8b9712a24813cddc8c2c922a80ea1693bd","modified":1658282278377},{"_id":"public/tags/MyBatis/index.html","hash":"c3d1ad8b9712a24813cddc8c2c922a80ea1693bd","modified":1658282278377},{"_id":"public/tags/MySql/index.html","hash":"c3d1ad8b9712a24813cddc8c2c922a80ea1693bd","modified":1658282278377},{"_id":"public/tags/Design/index.html","hash":"c3d1ad8b9712a24813cddc8c2c922a80ea1693bd","modified":1658282278377},{"_id":"public/tags/Other/index.html","hash":"c3d1ad8b9712a24813cddc8c2c922a80ea1693bd","modified":1658282278377},{"_id":"public/2022/03/17/俞敏洪在同济大学的的演讲/index.html","hash":"88ea0aef8b15a731a006ddfc86d41c07518d3438","modified":1647568681174},{"_id":"public/2022/03/15/ForkJoinSumCalculator/index.html","hash":"66846c0e574cb5bf542b226400767e57d1076279","modified":1647568211820},{"_id":"public/2022/03/10/MySql-Transaction-Isolation-Level/index.html","hash":"b8d2b6455c2152eb08f3d36f7e72c625c89f1481","modified":1647568211820},{"_id":"public/2022/03/10/MyBatis-Plugin-Development/index.html","hash":"4df3492e7766ecc4b4f8e1c96cad0b42abc2e0f4","modified":1647568211820},{"_id":"public/2022/03/09/Hexo-Theme-AirCloud/index.html","hash":"6135a93af57f5e4c5cae116225583214dc427511","modified":1647568211820},{"_id":"public/css/aircloud.less","hash":"cf339e918c04f33837516cf4f54e27640cf48460","modified":1647568211820},{"_id":"public/css/aircloud.css.map","hash":"50db34961d11f6f461e23912609d25141068a6fc","modified":1647568211820},{"_id":"public/css/gitment.css","hash":"926b553be983d6dd90bcb60c5d6d4ee215d268a6","modified":1647568211820},{"_id":"public/css/aircloud.css","hash":"2fe1fc9d6fa13cc4660cb8ae3d80b8d51e04dbf6","modified":1647568211820},{"_id":"public/js/gitment.js","hash":"89687f8fffe1125e08323fd6635ca4e53771c05e","modified":1647568211820},{"_id":"public/js/index.js","hash":"fcec9a2e4fd90a40957359d423f7f61caa712830","modified":1647568211820},{"_id":"public/img/avatar.jpg","hash":"5304e3982426a771746874abc1e70bc93261e197","modified":1647568211820},{"_id":"source/_posts/WordCounter.md","hash":"7dcf8b1e8eda237c8ac06c2748570e0182489909","modified":1647591821497},{"_id":"public/2022/03/18/WordCounter/index.html","hash":"7d5c64df48393052487d170c58018fcc1581b78d","modified":1647591861376},{"_id":"source/_posts/java线程池-阿里为什么不允许使用Executors.md","hash":"58622678b863278b3ffd705cb88f7662f48bcba8","modified":1647595478121},{"_id":"public/2022/03/18/java线程池-阿里为什么不允许使用Executors/index.html","hash":"3f626ee3462415cd849243a93c624beb3d029367","modified":1647595486219},{"_id":"source/_posts/Java线程池-工作窃取算法.md","hash":"c93ea549037aacdd28961f83db71f690e9795c9e","modified":1647596060639},{"_id":"public/archives/page/2/index.html","hash":"6847ed286e21cde5986cdcfda894e4def11e573a","modified":1658282278377},{"_id":"public/archives/2022/page/2/index.html","hash":"6847ed286e21cde5986cdcfda894e4def11e573a","modified":1658282278377},{"_id":"public/archives/2022/03/page/2/index.html","hash":"6847ed286e21cde5986cdcfda894e4def11e573a","modified":1658282278377},{"_id":"public/page/2/index.html","hash":"d1d4cdefeb183eaf7d838a5ef9a457f49c81899d","modified":1658282278377},{"_id":"public/2022/03/18/Java线程池-工作窃取算法/index.html","hash":"660e3fa14578af7ffdc15a8a85a5956d3686aedd","modified":1647596068937},{"_id":"source/_posts/Mybatis数据源结构解析之连接池.md","hash":"60973a4ee50321ba34e26cf67c5d7f8e9863bfa8","modified":1647699934359},{"_id":"public/2022/03/19/Mybatis数据源结构解析之连接池/index.html","hash":"d122e14816ef201f7704fb595807794171ed1aed","modified":1647699945220},{"_id":"source/_posts/简历.md","hash":"a67b4551c7d6025da365a7fe2d781fe7556da0d5","modified":1647759616202},{"_id":"public/2022/03/20/简历/index.html","hash":"1edc2b74d78b04182484d3c39970e27d8a115c0b","modified":1647759627629},{"_id":"source/_posts/20220320.md","hash":"9deab61f1b65b28e578a7cdb791bf5677d901e07","modified":1647777762554},{"_id":"public/2022/03/20/20220320/index.html","hash":"1e4025367aad33e04ea760642e47769206839d0a","modified":1647777776758},{"_id":"public/tags/Diary/index.html","hash":"fa680f88479bb1b61efe410ad5d3f912131ce0c8","modified":1647777170294},{"_id":"source/_posts/LotReassign.md","hash":"c6b92caec9d845a2e08252562cba1f9d9ccd108e","modified":1652156313068},{"_id":"public/2022/05/09/LotReassign/index.html","hash":"4cba06b65fe87eb5f86b94d69aade3e6cbaa8217","modified":1652156335497},{"_id":"public/archives/2022/05/index.html","hash":"6847ed286e21cde5986cdcfda894e4def11e573a","modified":1658282278377},{"_id":"source/_posts/HJ30字符串合并处理.md","hash":"0748e4cf3f014ed1c0bd14f1fb89248a89674a5d","modified":1652237155437},{"_id":"public/2022/05/11/HJ30字符串合并处理/index.html","hash":"7286f1fb1d016ae2c7306885bce51082b1ceadf9","modified":1652237167303},{"_id":"public/tags/牛客网华为题目/index.html","hash":"c3d1ad8b9712a24813cddc8c2c922a80ea1693bd","modified":1658282278377},{"_id":"source/_posts/HJ30合法IP.md","hash":"48c16f23b80081f8c06270f2b1079aaacf3a4d1e","modified":1652254566285},{"_id":"public/2022/05/11/HJ30合法IP/index.html","hash":"bbc97a8bcf41bfbe35fc3a82913ea31b93e73f73","modified":1652254575146},{"_id":"source/_posts/HJ10字符个数统计.md","hash":"4d8bac950eded3539155d59bbdebd3452a100a0e","modified":1652256699367},{"_id":"public/2022/05/11/HJ10字符个数统计/index.html","hash":"0cf4320f7e1f43326f9d5bce84300c42af171aa5","modified":1652256706868},{"_id":"source/_posts/JVM.md","hash":"baf629a745855699d0a89fb420a336d01791ed04","modified":1652430931292},{"_id":"public/2022/05/12/JVM/index.html","hash":"5318c694a5ff136ececb934d83bc85d5a28ae2de","modified":1652430950101},{"_id":"source/_posts/自我介绍.md","hash":"cb0b6730dc7a6964fe623857dca3e53d75311871","modified":1653435869999},{"_id":"public/2022/05/14/自我介绍/index.html","hash":"1e93c49599dea6d090dc4be6d2ef5798cbace4ba","modified":1653436144149},{"_id":"source/_posts/PostProcess.md","hash":"43048b54b6824522b9d1275b7838efcc1c9b96b3","modified":1653435949502},{"_id":"source/_posts/Spring循环依赖.md","hash":"68004bdec319130ea8f5a812261a067cd1ddd064","modified":1652602029613},{"_id":"public/2022/05/15/Spring循环依赖/index.html","hash":"d1d4d87da73ab02d8bde2e778cd0ed4a44a5fd0c","modified":1652602038587},{"_id":"public/2022/05/14/PostProcess/index.html","hash":"dbd126d811c6e50db8eb433c883d4f86df03b6c8","modified":1653436144149},{"_id":"public/page/3/index.html","hash":"be7a41bc03318ee922f6b5a2ff7f42b76bd9d437","modified":1658282278377},{"_id":"public/archives/page/3/index.html","hash":"6847ed286e21cde5986cdcfda894e4def11e573a","modified":1658282278377},{"_id":"public/archives/2022/page/3/index.html","hash":"6847ed286e21cde5986cdcfda894e4def11e573a","modified":1658282278377},{"_id":"public/tags/Spring/index.html","hash":"c3d1ad8b9712a24813cddc8c2c922a80ea1693bd","modified":1658282278377},{"_id":"source/_posts/DDD.md","hash":"eaeceb727afb7f7c5cd22bc73cb8b8d3770a0329","modified":1652853023530},{"_id":"public/2022/05/18/DDD/index.html","hash":"8324a0c0404695305c13dae9aeb9c7c17c9d29f0","modified":1653436144149},{"_id":"source/_posts/HexoEditor.md","hash":"cdbd4fb1ff45bcf7b67ea0d31ff4523455e42fd9","modified":1658228024772},{"_id":"public/2022/07/19/HexoEditor/index.html","hash":"ffad77d5e1d1103b723c50568adf172ea5fa212e","modified":1658228057176},{"_id":"public/archives/2022/07/index.html","hash":"6847ed286e21cde5986cdcfda894e4def11e573a","modified":1658282278377},{"_id":"source/_posts/绵绵星球工作笔记.md","hash":"5ba2546aaa3952f4c90c0ba63a101d351d322e5f","modified":1658282216682},{"_id":"source/_posts/申请售后和取消申请的逻辑.md","hash":"68bffa348d28bcaa98e60a34a7a48343e7ff9dd9","modified":1658281456877},{"_id":"source/_posts/订单售后按钮及文案设计.md","hash":"053aaa68f2cb0b4616d4bf5c1ec1471e747521f1","modified":1658361020448},{"_id":"public/2022/07/20/绵绵星球工作笔记/index.html","hash":"6a15a86c93d0a13e08642542f1ab1d09e61d9068","modified":1658282278377},{"_id":"public/2022/07/20/申请售后和取消申请的逻辑/index.html","hash":"70a2e4c06e562f19baf5b4209a05fb6421429430","modified":1658282278377},{"_id":"public/2022/07/20/订单售后按钮及文案设计/index.html","hash":"4c8929349269ab24ad21392f0cb2eb8bcf09d325","modified":1658361081389}],"Category":[],"Data":[],"Page":[{"layout":"about","title":"About","date":"2022-03-09T06:21:57.000Z","comments":1,"_content":"","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2022-03-09 14:21:57\ncomments: true\n---","updated":"2022-03-09T06:23:10.130Z","path":"about/index.html","_id":"cl0vrkopr000010ln4cpw41lk","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"Tags","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\n---","date":"2022-03-09T06:22:38.777Z","updated":"2022-03-09T06:22:38.777Z","path":"tags/index.html","comments":1,"_id":"cl0vrkopz000210ln35yjezxt","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"ForkJoinSumCalculator","date":"2022-03-15T08:22:53.000Z","_content":"\n```java\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.ForkJoinTask;\nimport java.util.concurrent.RecursiveTask;\nimport java.util.function.Function;\nimport java.util.stream.LongStream;\n\npublic class ForkJoinSumCalculator extends RecursiveTask<Long> {\n    private final long[] numbers;\n    private final int start;\n    private final int end;\n\n    public static final long THRESHOLD = 10_000;\n\n    public ForkJoinSumCalculator(long[] numbers) {\n        this(numbers, 0, numbers.length);\n    }\n\n    private ForkJoinSumCalculator(long[] numbers, int start, int end) {\n        this.numbers = numbers;\n        this.start = start;\n        this.end = end;\n    }\n\n\n    @Override\n    protected Long compute() {\n        int length = end - start;\n        if (length <= THRESHOLD) {\n            return computeSequentially();\n        }\n        ForkJoinSumCalculator leftTask =\n                new ForkJoinSumCalculator(numbers, start, start + length / 2);\n        leftTask.fork();\n        ForkJoinSumCalculator rightTask =\n                new ForkJoinSumCalculator(numbers, start + length / 2, end);\n        Long rightResult = rightTask.compute();\n        Long leftResult = leftTask.join();\n        return leftResult + rightResult;\n    }\n\n    private Long computeSequentially() {\n        long sum = 0;\n        for (int i = start; i < end; i++) {\n            sum += numbers[i];\n        }\n        return sum;\n    }\n\n    public static long forJoinSum(long n) {\n        long[] numbers = LongStream.rangeClosed(1, n).toArray();\n        ForkJoinTask<Long> task = new ForkJoinSumCalculator(numbers);\n        return new ForkJoinPool().invoke(task);\n    }\n\n    public static long parallel(long n) {\n        return LongStream.rangeClosed(1, n).parallel().reduce(0, Long::sum);\n    }\n\n    public static void main(String[] args) {\n        measureSumPerf(ForkJoinSumCalculator::forJoinSum, 1000000L);\n        measureSumPerf(ForkJoinSumCalculator::parallel, 1000000L);\n\n    }\n\n    public static long measureSumPerf(Function<Long, Long> adder, Long n) {\n        long max = Long.MAX_VALUE;\n        for (int i = 0; i < 10; i++) {\n            long start = System.nanoTime();\n            Long result = adder.apply(n);\n            long time = (System.nanoTime() - start) / 1_000_000;\n            if (time < max) {\n                max = time;\n            }\n        }\n        System.out.println(max);\n        return max;\n    }\n}\n\n```\n\n","source":"_posts/ForkJoinSumCalculator.md","raw":"---\ntitle: ForkJoinSumCalculator\ndate: 2022-03-15 16:22:53\ntags: Java\n---\n\n```java\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.ForkJoinTask;\nimport java.util.concurrent.RecursiveTask;\nimport java.util.function.Function;\nimport java.util.stream.LongStream;\n\npublic class ForkJoinSumCalculator extends RecursiveTask<Long> {\n    private final long[] numbers;\n    private final int start;\n    private final int end;\n\n    public static final long THRESHOLD = 10_000;\n\n    public ForkJoinSumCalculator(long[] numbers) {\n        this(numbers, 0, numbers.length);\n    }\n\n    private ForkJoinSumCalculator(long[] numbers, int start, int end) {\n        this.numbers = numbers;\n        this.start = start;\n        this.end = end;\n    }\n\n\n    @Override\n    protected Long compute() {\n        int length = end - start;\n        if (length <= THRESHOLD) {\n            return computeSequentially();\n        }\n        ForkJoinSumCalculator leftTask =\n                new ForkJoinSumCalculator(numbers, start, start + length / 2);\n        leftTask.fork();\n        ForkJoinSumCalculator rightTask =\n                new ForkJoinSumCalculator(numbers, start + length / 2, end);\n        Long rightResult = rightTask.compute();\n        Long leftResult = leftTask.join();\n        return leftResult + rightResult;\n    }\n\n    private Long computeSequentially() {\n        long sum = 0;\n        for (int i = start; i < end; i++) {\n            sum += numbers[i];\n        }\n        return sum;\n    }\n\n    public static long forJoinSum(long n) {\n        long[] numbers = LongStream.rangeClosed(1, n).toArray();\n        ForkJoinTask<Long> task = new ForkJoinSumCalculator(numbers);\n        return new ForkJoinPool().invoke(task);\n    }\n\n    public static long parallel(long n) {\n        return LongStream.rangeClosed(1, n).parallel().reduce(0, Long::sum);\n    }\n\n    public static void main(String[] args) {\n        measureSumPerf(ForkJoinSumCalculator::forJoinSum, 1000000L);\n        measureSumPerf(ForkJoinSumCalculator::parallel, 1000000L);\n\n    }\n\n    public static long measureSumPerf(Function<Long, Long> adder, Long n) {\n        long max = Long.MAX_VALUE;\n        for (int i = 0; i < 10; i++) {\n            long start = System.nanoTime();\n            Long result = adder.apply(n);\n            long time = (System.nanoTime() - start) / 1_000_000;\n            if (time < max) {\n                max = time;\n            }\n        }\n        System.out.println(max);\n        return max;\n    }\n}\n\n```\n\n","slug":"ForkJoinSumCalculator","published":1,"updated":"2022-03-15T08:24:59.522Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0vrkopv000110lnapc795ve","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.RecursiveTask;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Function;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.LongStream;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ForkJoinSumCalculator</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span>[] numbers;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> start;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> end;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">THRESHOLD</span> <span class=\"operator\">=</span> <span class=\"number\">10_000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ForkJoinSumCalculator</span><span class=\"params\">(<span class=\"type\">long</span>[] numbers)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(numbers, <span class=\"number\">0</span>, numbers.length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">ForkJoinSumCalculator</span><span class=\"params\">(<span class=\"type\">long</span>[] numbers, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.numbers = numbers;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.start = start;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.end = end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Long <span class=\"title function_\">compute</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> end - start;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (length &lt;= THRESHOLD) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> computeSequentially();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">ForkJoinSumCalculator</span> <span class=\"variable\">leftTask</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">ForkJoinSumCalculator</span>(numbers, start, start + length / <span class=\"number\">2</span>);</span><br><span class=\"line\">        leftTask.fork();</span><br><span class=\"line\">        <span class=\"type\">ForkJoinSumCalculator</span> <span class=\"variable\">rightTask</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">ForkJoinSumCalculator</span>(numbers, start + length / <span class=\"number\">2</span>, end);</span><br><span class=\"line\">        <span class=\"type\">Long</span> <span class=\"variable\">rightResult</span> <span class=\"operator\">=</span> rightTask.compute();</span><br><span class=\"line\">        <span class=\"type\">Long</span> <span class=\"variable\">leftResult</span> <span class=\"operator\">=</span> leftTask.join();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> leftResult + rightResult;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long <span class=\"title function_\">computeSequentially</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> start; i &lt; end; i++) &#123;</span><br><span class=\"line\">            sum += numbers[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"title function_\">forJoinSum</span><span class=\"params\">(<span class=\"type\">long</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span>[] numbers = LongStream.rangeClosed(<span class=\"number\">1</span>, n).toArray();</span><br><span class=\"line\">        ForkJoinTask&lt;Long&gt; task = <span class=\"keyword\">new</span> <span class=\"title class_\">ForkJoinSumCalculator</span>(numbers);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ForkJoinPool</span>().invoke(task);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"title function_\">parallel</span><span class=\"params\">(<span class=\"type\">long</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> LongStream.rangeClosed(<span class=\"number\">1</span>, n).parallel().reduce(<span class=\"number\">0</span>, Long::sum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        measureSumPerf(ForkJoinSumCalculator::forJoinSum, <span class=\"number\">1000000L</span>);</span><br><span class=\"line\">        measureSumPerf(ForkJoinSumCalculator::parallel, <span class=\"number\">1000000L</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"title function_\">measureSumPerf</span><span class=\"params\">(Function&lt;Long, Long&gt; adder, Long n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">max</span> <span class=\"operator\">=</span> Long.MAX_VALUE;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">            <span class=\"type\">Long</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> adder.apply(n);</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">time</span> <span class=\"operator\">=</span> (System.nanoTime() - start) / <span class=\"number\">1_000_000</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &lt; max) &#123;</span><br><span class=\"line\">                max = time;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(max);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.RecursiveTask;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Function;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.LongStream;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ForkJoinSumCalculator</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span>[] numbers;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> start;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> end;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">THRESHOLD</span> <span class=\"operator\">=</span> <span class=\"number\">10_000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ForkJoinSumCalculator</span><span class=\"params\">(<span class=\"type\">long</span>[] numbers)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(numbers, <span class=\"number\">0</span>, numbers.length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">ForkJoinSumCalculator</span><span class=\"params\">(<span class=\"type\">long</span>[] numbers, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.numbers = numbers;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.start = start;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.end = end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Long <span class=\"title function_\">compute</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> end - start;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (length &lt;= THRESHOLD) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> computeSequentially();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">ForkJoinSumCalculator</span> <span class=\"variable\">leftTask</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">ForkJoinSumCalculator</span>(numbers, start, start + length / <span class=\"number\">2</span>);</span><br><span class=\"line\">        leftTask.fork();</span><br><span class=\"line\">        <span class=\"type\">ForkJoinSumCalculator</span> <span class=\"variable\">rightTask</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">ForkJoinSumCalculator</span>(numbers, start + length / <span class=\"number\">2</span>, end);</span><br><span class=\"line\">        <span class=\"type\">Long</span> <span class=\"variable\">rightResult</span> <span class=\"operator\">=</span> rightTask.compute();</span><br><span class=\"line\">        <span class=\"type\">Long</span> <span class=\"variable\">leftResult</span> <span class=\"operator\">=</span> leftTask.join();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> leftResult + rightResult;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long <span class=\"title function_\">computeSequentially</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> start; i &lt; end; i++) &#123;</span><br><span class=\"line\">            sum += numbers[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"title function_\">forJoinSum</span><span class=\"params\">(<span class=\"type\">long</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span>[] numbers = LongStream.rangeClosed(<span class=\"number\">1</span>, n).toArray();</span><br><span class=\"line\">        ForkJoinTask&lt;Long&gt; task = <span class=\"keyword\">new</span> <span class=\"title class_\">ForkJoinSumCalculator</span>(numbers);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ForkJoinPool</span>().invoke(task);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"title function_\">parallel</span><span class=\"params\">(<span class=\"type\">long</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> LongStream.rangeClosed(<span class=\"number\">1</span>, n).parallel().reduce(<span class=\"number\">0</span>, Long::sum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        measureSumPerf(ForkJoinSumCalculator::forJoinSum, <span class=\"number\">1000000L</span>);</span><br><span class=\"line\">        measureSumPerf(ForkJoinSumCalculator::parallel, <span class=\"number\">1000000L</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"title function_\">measureSumPerf</span><span class=\"params\">(Function&lt;Long, Long&gt; adder, Long n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">max</span> <span class=\"operator\">=</span> Long.MAX_VALUE;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">            <span class=\"type\">Long</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> adder.apply(n);</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">time</span> <span class=\"operator\">=</span> (System.nanoTime() - start) / <span class=\"number\">1_000_000</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &lt; max) &#123;</span><br><span class=\"line\">                max = time;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(max);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n"},{"title":"Install-WSL","date":"2022-03-09T06:28:42.000Z","_content":"\n\n\n为简单起见，通常建议使用 [`wsl --install`](https://docs.microsoft.com/zh-cn/windows/wsl/install) 安装适用于 Linux 的 Windows 子系统，但如果运行的是旧版 Windows，则可能不支持这种方式。 下面介绍了手动安装步骤。 如果在安装过程中遇到问题，请查看[疑难解答指南的安装部分](https://docs.microsoft.com/zh-cn/windows/wsl/troubleshooting#installation-issues)。\n\n## 步骤 1 - 启用适用于 Linux 的 Windows 子系统\n\n需要先启用“适用于 Linux 的 Windows 子系统”可选功能，然后才能在 Windows 上安装 Linux 分发。\n\n以管理员身份打开 PowerShell（“开始”菜单 >“PowerShell”> 单击右键 >“以管理员身份运行”），然后输入以下命令：\n\nPowerShell复制\n\n```powershell\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart\n```\n\n建议现在转到步骤 #2，更新到 WSL 2，但如果只想安装 WSL 1，现在可以重新启动计算机，然后继续执行[步骤 6 - 安装所选的 Linux 发行版](https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#step-6---install-your-linux-distribution-of-choice)。 若要更新到 WSL 2，请等待重新启动计算机，然后继续执行下一步。\n\n## 步骤 2 - 检查运行 WSL 2 的要求\n\n若要更新到 WSL 2，需要运行 Windows 10。\n\n- 对于 x64 系统：**版本 1903** 或更高版本，采用**内部版本 18362** 或更高版本。\n- 对于 ARM64 系统：**版本 2004** 或更高版本，采用**内部版本 19041** 或更高版本。\n- 低于 18362 的版本不支持 WSL 2。 使用 [Windows Update 助手](https://www.microsoft.com/software-download/windows10)更新 Windows 版本。\n\n若要检查 Windows 版本及内部版本号，选择 Windows 徽标键 + R，然后键入“winver”，选择“确定”。 更新到“设置”菜单中的[最新 Windows 版本](ms-settings:windowsupdate)。\n\n 备注\n\n如果运行的是 Windows 10 版本1903 或 1909，请在 Windows 菜单中打开“设置”，导航到“更新和安全性”，然后选择“检查更新”。 内部版本号必须是 18362.1049+ 或 18363.1049+，次要内部版本号需要高于 .1049。 阅读详细信息：[WSL 2 即将支持 Windows 10 版本 1903 和 1909](https://devblogs.microsoft.com/commandline/wsl-2-support-is-coming-to-windows-10-versions-1903-and-1909/)。\n\n## 步骤 3 - 启用虚拟机功能\n\n安装 WSL 2 之前，必须启用“虚拟机平台”可选功能。 计算机需要[虚拟化功能](https://docs.microsoft.com/zh-cn/windows/wsl/troubleshooting#error-0x80370102-the-virtual-machine-could-not-be-started-because-a-required-feature-is-not-installed)才能使用此功能。\n\n以管理员身份打开 PowerShell 并运行：\n\nPowerShell复制\n\n```powershell\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\n```\n\n**重新启动**计算机，以完成 WSL 安装并更新到 WSL 2。\n\n## 步骤 4 - 下载 Linux 内核更新包\n\n1. 下载最新包：\n\n   - [适用于 x64 计算机的 WSL2 Linux 内核更新包](https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi)\n\n    备注\n\n   如果使用的是 ARM64 计算机，请下载 [ARM64 包](https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_arm64.msi)。 如果不确定自己计算机的类型，请打开命令提示符或 PowerShell，并输入：`systeminfo | find \"System Type\"`。 **Caveat：** 在非英文版 Windows 上，你可能必须修改搜索文本，对“System Type”字符串进行翻译。 你可能还需要对引号进行转义来用于 find 命令。 例如，在德语版中使用 `systeminfo | find '\"Systemtyp\"'`。\n\n2. 运行上一步中下载的更新包。 （双击以运行 - 系统将提示你提供提升的权限，选择“是”以批准此安装。）\n\n安装完成后，请继续执行下一步 - 在安装新的 Linux 分发时，将 WSL 2 设置为默认版本。 （如果希望将新的 Linux 安装设置为 WSL 1，请跳过此步骤。）\n\n 备注\n\n有关详细信息，请参阅 [Windows 命令行博客](https://aka.ms/cliblog)上的文章[对更新 WSL2 Linux 内核的更改](https://devblogs.microsoft.com/commandline/wsl2-will-be-generally-available-in-windows-10-version-2004)。\n\n## 步骤 5 - 将 WSL 2 设置为默认版本\n\n打开 PowerShell，然后在安装新的 Linux 发行版时运行以下命令，将 WSL 2 设置为默认版本：\n\nPowerShell复制\n\n```powershell\nwsl --set-default-version 2\n```\n\n## 步骤 6 - 安装所选的 Linux 分发\n\n1. 打开 [Microsoft Store](https://aka.ms/wslstore)，并选择你偏好的 Linux 分发版。\n","source":"_posts/Install-WSL.md","raw":"---\ntitle: Install-WSL\ndate: 2022-03-09 14:28:42\ntags: WSL\n---\n\n\n\n为简单起见，通常建议使用 [`wsl --install`](https://docs.microsoft.com/zh-cn/windows/wsl/install) 安装适用于 Linux 的 Windows 子系统，但如果运行的是旧版 Windows，则可能不支持这种方式。 下面介绍了手动安装步骤。 如果在安装过程中遇到问题，请查看[疑难解答指南的安装部分](https://docs.microsoft.com/zh-cn/windows/wsl/troubleshooting#installation-issues)。\n\n## 步骤 1 - 启用适用于 Linux 的 Windows 子系统\n\n需要先启用“适用于 Linux 的 Windows 子系统”可选功能，然后才能在 Windows 上安装 Linux 分发。\n\n以管理员身份打开 PowerShell（“开始”菜单 >“PowerShell”> 单击右键 >“以管理员身份运行”），然后输入以下命令：\n\nPowerShell复制\n\n```powershell\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart\n```\n\n建议现在转到步骤 #2，更新到 WSL 2，但如果只想安装 WSL 1，现在可以重新启动计算机，然后继续执行[步骤 6 - 安装所选的 Linux 发行版](https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#step-6---install-your-linux-distribution-of-choice)。 若要更新到 WSL 2，请等待重新启动计算机，然后继续执行下一步。\n\n## 步骤 2 - 检查运行 WSL 2 的要求\n\n若要更新到 WSL 2，需要运行 Windows 10。\n\n- 对于 x64 系统：**版本 1903** 或更高版本，采用**内部版本 18362** 或更高版本。\n- 对于 ARM64 系统：**版本 2004** 或更高版本，采用**内部版本 19041** 或更高版本。\n- 低于 18362 的版本不支持 WSL 2。 使用 [Windows Update 助手](https://www.microsoft.com/software-download/windows10)更新 Windows 版本。\n\n若要检查 Windows 版本及内部版本号，选择 Windows 徽标键 + R，然后键入“winver”，选择“确定”。 更新到“设置”菜单中的[最新 Windows 版本](ms-settings:windowsupdate)。\n\n 备注\n\n如果运行的是 Windows 10 版本1903 或 1909，请在 Windows 菜单中打开“设置”，导航到“更新和安全性”，然后选择“检查更新”。 内部版本号必须是 18362.1049+ 或 18363.1049+，次要内部版本号需要高于 .1049。 阅读详细信息：[WSL 2 即将支持 Windows 10 版本 1903 和 1909](https://devblogs.microsoft.com/commandline/wsl-2-support-is-coming-to-windows-10-versions-1903-and-1909/)。\n\n## 步骤 3 - 启用虚拟机功能\n\n安装 WSL 2 之前，必须启用“虚拟机平台”可选功能。 计算机需要[虚拟化功能](https://docs.microsoft.com/zh-cn/windows/wsl/troubleshooting#error-0x80370102-the-virtual-machine-could-not-be-started-because-a-required-feature-is-not-installed)才能使用此功能。\n\n以管理员身份打开 PowerShell 并运行：\n\nPowerShell复制\n\n```powershell\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\n```\n\n**重新启动**计算机，以完成 WSL 安装并更新到 WSL 2。\n\n## 步骤 4 - 下载 Linux 内核更新包\n\n1. 下载最新包：\n\n   - [适用于 x64 计算机的 WSL2 Linux 内核更新包](https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi)\n\n    备注\n\n   如果使用的是 ARM64 计算机，请下载 [ARM64 包](https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_arm64.msi)。 如果不确定自己计算机的类型，请打开命令提示符或 PowerShell，并输入：`systeminfo | find \"System Type\"`。 **Caveat：** 在非英文版 Windows 上，你可能必须修改搜索文本，对“System Type”字符串进行翻译。 你可能还需要对引号进行转义来用于 find 命令。 例如，在德语版中使用 `systeminfo | find '\"Systemtyp\"'`。\n\n2. 运行上一步中下载的更新包。 （双击以运行 - 系统将提示你提供提升的权限，选择“是”以批准此安装。）\n\n安装完成后，请继续执行下一步 - 在安装新的 Linux 分发时，将 WSL 2 设置为默认版本。 （如果希望将新的 Linux 安装设置为 WSL 1，请跳过此步骤。）\n\n 备注\n\n有关详细信息，请参阅 [Windows 命令行博客](https://aka.ms/cliblog)上的文章[对更新 WSL2 Linux 内核的更改](https://devblogs.microsoft.com/commandline/wsl2-will-be-generally-available-in-windows-10-version-2004)。\n\n## 步骤 5 - 将 WSL 2 设置为默认版本\n\n打开 PowerShell，然后在安装新的 Linux 发行版时运行以下命令，将 WSL 2 设置为默认版本：\n\nPowerShell复制\n\n```powershell\nwsl --set-default-version 2\n```\n\n## 步骤 6 - 安装所选的 Linux 分发\n\n1. 打开 [Microsoft Store](https://aka.ms/wslstore)，并选择你偏好的 Linux 分发版。\n","slug":"Install-WSL","published":1,"updated":"2022-03-09T06:29:47.803Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0vrkopz000310ln4qhm67n3","content":"<p>为简单起见，通常建议使用 <a href=\"https://docs.microsoft.com/zh-cn/windows/wsl/install\"><code>wsl --install</code></a> 安装适用于 Linux 的 Windows 子系统，但如果运行的是旧版 Windows，则可能不支持这种方式。 下面介绍了手动安装步骤。 如果在安装过程中遇到问题，请查看<a href=\"https://docs.microsoft.com/zh-cn/windows/wsl/troubleshooting#installation-issues\">疑难解答指南的安装部分</a>。</p>\n<h2 id=\"步骤-1-启用适用于-Linux-的-Windows-子系统\"><a href=\"#步骤-1-启用适用于-Linux-的-Windows-子系统\" class=\"headerlink\" title=\"步骤 1 - 启用适用于 Linux 的 Windows 子系统\"></a>步骤 1 - 启用适用于 Linux 的 Windows 子系统</h2><p>需要先启用“适用于 Linux 的 Windows 子系统”可选功能，然后才能在 Windows 上安装 Linux 分发。</p>\n<p>以管理员身份打开 PowerShell（“开始”菜单 &gt;“PowerShell”&gt; 单击右键 &gt;“以管理员身份运行”），然后输入以下命令：</p>\n<p>PowerShell复制</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dism.exe /online /<span class=\"built_in\">enable-feature</span> /featurename:Microsoft<span class=\"literal\">-Windows-Subsystem-Linux</span> /all /norestart</span><br></pre></td></tr></table></figure>\n\n<p>建议现在转到步骤 #2，更新到 WSL 2，但如果只想安装 WSL 1，现在可以重新启动计算机，然后继续执行<a href=\"https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#step-6---install-your-linux-distribution-of-choice\">步骤 6 - 安装所选的 Linux 发行版</a>。 若要更新到 WSL 2，请等待重新启动计算机，然后继续执行下一步。</p>\n<h2 id=\"步骤-2-检查运行-WSL-2-的要求\"><a href=\"#步骤-2-检查运行-WSL-2-的要求\" class=\"headerlink\" title=\"步骤 2 - 检查运行 WSL 2 的要求\"></a>步骤 2 - 检查运行 WSL 2 的要求</h2><p>若要更新到 WSL 2，需要运行 Windows 10。</p>\n<ul>\n<li>对于 x64 系统：<strong>版本 1903</strong> 或更高版本，采用<strong>内部版本 18362</strong> 或更高版本。</li>\n<li>对于 ARM64 系统：<strong>版本 2004</strong> 或更高版本，采用<strong>内部版本 19041</strong> 或更高版本。</li>\n<li>低于 18362 的版本不支持 WSL 2。 使用 <a href=\"https://www.microsoft.com/software-download/windows10\">Windows Update 助手</a>更新 Windows 版本。</li>\n</ul>\n<p>若要检查 Windows 版本及内部版本号，选择 Windows 徽标键 + R，然后键入“winver”，选择“确定”。 更新到“设置”菜单中的<a href=\"ms-settings:windowsupdate\">最新 Windows 版本</a>。</p>\n<p> 备注</p>\n<p>如果运行的是 Windows 10 版本1903 或 1909，请在 Windows 菜单中打开“设置”，导航到“更新和安全性”，然后选择“检查更新”。 内部版本号必须是 18362.1049+ 或 18363.1049+，次要内部版本号需要高于 .1049。 阅读详细信息：<a href=\"https://devblogs.microsoft.com/commandline/wsl-2-support-is-coming-to-windows-10-versions-1903-and-1909/\">WSL 2 即将支持 Windows 10 版本 1903 和 1909</a>。</p>\n<h2 id=\"步骤-3-启用虚拟机功能\"><a href=\"#步骤-3-启用虚拟机功能\" class=\"headerlink\" title=\"步骤 3 - 启用虚拟机功能\"></a>步骤 3 - 启用虚拟机功能</h2><p>安装 WSL 2 之前，必须启用“虚拟机平台”可选功能。 计算机需要<a href=\"https://docs.microsoft.com/zh-cn/windows/wsl/troubleshooting#error-0x80370102-the-virtual-machine-could-not-be-started-because-a-required-feature-is-not-installed\">虚拟化功能</a>才能使用此功能。</p>\n<p>以管理员身份打开 PowerShell 并运行：</p>\n<p>PowerShell复制</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dism.exe /online /<span class=\"built_in\">enable-feature</span> /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure>\n\n<p><strong>重新启动</strong>计算机，以完成 WSL 安装并更新到 WSL 2。</p>\n<h2 id=\"步骤-4-下载-Linux-内核更新包\"><a href=\"#步骤-4-下载-Linux-内核更新包\" class=\"headerlink\" title=\"步骤 4 - 下载 Linux 内核更新包\"></a>步骤 4 - 下载 Linux 内核更新包</h2><ol>\n<li><p>下载最新包：</p>\n<ul>\n<li><a href=\"https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi\">适用于 x64 计算机的 WSL2 Linux 内核更新包</a></li>\n</ul>\n<p> 备注</p>\n<p>如果使用的是 ARM64 计算机，请下载 <a href=\"https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_arm64.msi\">ARM64 包</a>。 如果不确定自己计算机的类型，请打开命令提示符或 PowerShell，并输入：<code>systeminfo | find &quot;System Type&quot;</code>。 <strong>Caveat：</strong> 在非英文版 Windows 上，你可能必须修改搜索文本，对“System Type”字符串进行翻译。 你可能还需要对引号进行转义来用于 find 命令。 例如，在德语版中使用 <code>systeminfo | find &#39;&quot;Systemtyp&quot;&#39;</code>。</p>\n</li>\n<li><p>运行上一步中下载的更新包。 （双击以运行 - 系统将提示你提供提升的权限，选择“是”以批准此安装。）</p>\n</li>\n</ol>\n<p>安装完成后，请继续执行下一步 - 在安装新的 Linux 分发时，将 WSL 2 设置为默认版本。 （如果希望将新的 Linux 安装设置为 WSL 1，请跳过此步骤。）</p>\n<p> 备注</p>\n<p>有关详细信息，请参阅 <a href=\"https://aka.ms/cliblog\">Windows 命令行博客</a>上的文章<a href=\"https://devblogs.microsoft.com/commandline/wsl2-will-be-generally-available-in-windows-10-version-2004\">对更新 WSL2 Linux 内核的更改</a>。</p>\n<h2 id=\"步骤-5-将-WSL-2-设置为默认版本\"><a href=\"#步骤-5-将-WSL-2-设置为默认版本\" class=\"headerlink\" title=\"步骤 5 - 将 WSL 2 设置为默认版本\"></a>步骤 5 - 将 WSL 2 设置为默认版本</h2><p>打开 PowerShell，然后在安装新的 Linux 发行版时运行以下命令，将 WSL 2 设置为默认版本：</p>\n<p>PowerShell复制</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsl <span class=\"literal\">--set-default-version</span> <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"步骤-6-安装所选的-Linux-分发\"><a href=\"#步骤-6-安装所选的-Linux-分发\" class=\"headerlink\" title=\"步骤 6 - 安装所选的 Linux 分发\"></a>步骤 6 - 安装所选的 Linux 分发</h2><ol>\n<li>打开 <a href=\"https://aka.ms/wslstore\">Microsoft Store</a>，并选择你偏好的 Linux 分发版。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>为简单起见，通常建议使用 <a href=\"https://docs.microsoft.com/zh-cn/windows/wsl/install\"><code>wsl --install</code></a> 安装适用于 Linux 的 Windows 子系统，但如果运行的是旧版 Windows，则可能不支持这种方式。 下面介绍了手动安装步骤。 如果在安装过程中遇到问题，请查看<a href=\"https://docs.microsoft.com/zh-cn/windows/wsl/troubleshooting#installation-issues\">疑难解答指南的安装部分</a>。</p>\n<h2 id=\"步骤-1-启用适用于-Linux-的-Windows-子系统\"><a href=\"#步骤-1-启用适用于-Linux-的-Windows-子系统\" class=\"headerlink\" title=\"步骤 1 - 启用适用于 Linux 的 Windows 子系统\"></a>步骤 1 - 启用适用于 Linux 的 Windows 子系统</h2><p>需要先启用“适用于 Linux 的 Windows 子系统”可选功能，然后才能在 Windows 上安装 Linux 分发。</p>\n<p>以管理员身份打开 PowerShell（“开始”菜单 &gt;“PowerShell”&gt; 单击右键 &gt;“以管理员身份运行”），然后输入以下命令：</p>\n<p>PowerShell复制</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dism.exe /online /<span class=\"built_in\">enable-feature</span> /featurename:Microsoft<span class=\"literal\">-Windows-Subsystem-Linux</span> /all /norestart</span><br></pre></td></tr></table></figure>\n\n<p>建议现在转到步骤 #2，更新到 WSL 2，但如果只想安装 WSL 1，现在可以重新启动计算机，然后继续执行<a href=\"https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#step-6---install-your-linux-distribution-of-choice\">步骤 6 - 安装所选的 Linux 发行版</a>。 若要更新到 WSL 2，请等待重新启动计算机，然后继续执行下一步。</p>\n<h2 id=\"步骤-2-检查运行-WSL-2-的要求\"><a href=\"#步骤-2-检查运行-WSL-2-的要求\" class=\"headerlink\" title=\"步骤 2 - 检查运行 WSL 2 的要求\"></a>步骤 2 - 检查运行 WSL 2 的要求</h2><p>若要更新到 WSL 2，需要运行 Windows 10。</p>\n<ul>\n<li>对于 x64 系统：<strong>版本 1903</strong> 或更高版本，采用<strong>内部版本 18362</strong> 或更高版本。</li>\n<li>对于 ARM64 系统：<strong>版本 2004</strong> 或更高版本，采用<strong>内部版本 19041</strong> 或更高版本。</li>\n<li>低于 18362 的版本不支持 WSL 2。 使用 <a href=\"https://www.microsoft.com/software-download/windows10\">Windows Update 助手</a>更新 Windows 版本。</li>\n</ul>\n<p>若要检查 Windows 版本及内部版本号，选择 Windows 徽标键 + R，然后键入“winver”，选择“确定”。 更新到“设置”菜单中的<a href=\"ms-settings:windowsupdate\">最新 Windows 版本</a>。</p>\n<p> 备注</p>\n<p>如果运行的是 Windows 10 版本1903 或 1909，请在 Windows 菜单中打开“设置”，导航到“更新和安全性”，然后选择“检查更新”。 内部版本号必须是 18362.1049+ 或 18363.1049+，次要内部版本号需要高于 .1049。 阅读详细信息：<a href=\"https://devblogs.microsoft.com/commandline/wsl-2-support-is-coming-to-windows-10-versions-1903-and-1909/\">WSL 2 即将支持 Windows 10 版本 1903 和 1909</a>。</p>\n<h2 id=\"步骤-3-启用虚拟机功能\"><a href=\"#步骤-3-启用虚拟机功能\" class=\"headerlink\" title=\"步骤 3 - 启用虚拟机功能\"></a>步骤 3 - 启用虚拟机功能</h2><p>安装 WSL 2 之前，必须启用“虚拟机平台”可选功能。 计算机需要<a href=\"https://docs.microsoft.com/zh-cn/windows/wsl/troubleshooting#error-0x80370102-the-virtual-machine-could-not-be-started-because-a-required-feature-is-not-installed\">虚拟化功能</a>才能使用此功能。</p>\n<p>以管理员身份打开 PowerShell 并运行：</p>\n<p>PowerShell复制</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dism.exe /online /<span class=\"built_in\">enable-feature</span> /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure>\n\n<p><strong>重新启动</strong>计算机，以完成 WSL 安装并更新到 WSL 2。</p>\n<h2 id=\"步骤-4-下载-Linux-内核更新包\"><a href=\"#步骤-4-下载-Linux-内核更新包\" class=\"headerlink\" title=\"步骤 4 - 下载 Linux 内核更新包\"></a>步骤 4 - 下载 Linux 内核更新包</h2><ol>\n<li><p>下载最新包：</p>\n<ul>\n<li><a href=\"https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi\">适用于 x64 计算机的 WSL2 Linux 内核更新包</a></li>\n</ul>\n<p> 备注</p>\n<p>如果使用的是 ARM64 计算机，请下载 <a href=\"https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_arm64.msi\">ARM64 包</a>。 如果不确定自己计算机的类型，请打开命令提示符或 PowerShell，并输入：<code>systeminfo | find &quot;System Type&quot;</code>。 <strong>Caveat：</strong> 在非英文版 Windows 上，你可能必须修改搜索文本，对“System Type”字符串进行翻译。 你可能还需要对引号进行转义来用于 find 命令。 例如，在德语版中使用 <code>systeminfo | find &#39;&quot;Systemtyp&quot;&#39;</code>。</p>\n</li>\n<li><p>运行上一步中下载的更新包。 （双击以运行 - 系统将提示你提供提升的权限，选择“是”以批准此安装。）</p>\n</li>\n</ol>\n<p>安装完成后，请继续执行下一步 - 在安装新的 Linux 分发时，将 WSL 2 设置为默认版本。 （如果希望将新的 Linux 安装设置为 WSL 1，请跳过此步骤。）</p>\n<p> 备注</p>\n<p>有关详细信息，请参阅 <a href=\"https://aka.ms/cliblog\">Windows 命令行博客</a>上的文章<a href=\"https://devblogs.microsoft.com/commandline/wsl2-will-be-generally-available-in-windows-10-version-2004\">对更新 WSL2 Linux 内核的更改</a>。</p>\n<h2 id=\"步骤-5-将-WSL-2-设置为默认版本\"><a href=\"#步骤-5-将-WSL-2-设置为默认版本\" class=\"headerlink\" title=\"步骤 5 - 将 WSL 2 设置为默认版本\"></a>步骤 5 - 将 WSL 2 设置为默认版本</h2><p>打开 PowerShell，然后在安装新的 Linux 发行版时运行以下命令，将 WSL 2 设置为默认版本：</p>\n<p>PowerShell复制</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsl <span class=\"literal\">--set-default-version</span> <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"步骤-6-安装所选的-Linux-分发\"><a href=\"#步骤-6-安装所选的-Linux-分发\" class=\"headerlink\" title=\"步骤 6 - 安装所选的 Linux 分发\"></a>步骤 6 - 安装所选的 Linux 分发</h2><ol>\n<li>打开 <a href=\"https://aka.ms/wslstore\">Microsoft Store</a>，并选择你偏好的 Linux 分发版。</li>\n</ol>\n"},{"title":"Hexo-Theme-AirCloud","date":"2022-03-09T06:03:36.000Z","_content":"\n\n\n## Hexo-Theme-AirCloud: 一个简洁轻量的 hexo 博客主题\n\n## 功能简介\n\nHexo-Theme-AirCloud 是一个简洁轻量的 hexo 博客主题，旨在将中心放在博文本身，因此：\n\n- 默认没有大范围的主题色块、图片铺排等，也不要求每片博文配图，一方面这并不是我们记录知识的重点，另外一方面可能程序员群体并没有足够的素材，容易造成主题纠纷。\n- 建议通过不冗余的内容进行传达，比如默认没有博文摘要，因为不少开发者写博客的时候没有写博文摘要，如果从博客前一部分截取往往不能表达完整思想。\n\n另外，该主题主要实现的功能有:\n\n- 全局搜索功能，并对搜索内容进行高亮。\n- 博客评论功能，目前接入 [gitment](https://imsun.net/posts/gitment-introduction/)，之后考虑接入多种可选。\n- 文章详情页文章目录功能\n- 访问量统计（总体UV、PV，单页PV）\n- 语言切换能力，目前支持中文和英文\n\n## 起步\n\n> 我在”常见问题”中总结了该项目之前被提及的一些问题，如果你在使用过程中遇到了问题，可以在”常见问题”中寻找答案，如果没能解决，欢迎提[issue](https://github.com/aircloud/hexo-theme-aircloud/issues)，我会保证回复。\n\n注意，如果你不按照”功能适配”部分的内容进行操作，可能会导致相关提及的功能无法正常使用。\n\n- [基本使用](https://github.com/aircloud/hexo-theme-aircloud#基本使用)\n- 功能适配\n  - [搜索功能](https://github.com/aircloud/hexo-theme-aircloud#搜索功能)\n  - [`标签`页面 & `关于`页面](https://github.com/aircloud/hexo-theme-aircloud#标签页面--关于页面)\n  - [评论功能](https://github.com/aircloud/hexo-theme-aircloud#评论功能)\n  - [favicon 的配置](https://github.com/aircloud/hexo-theme-aircloud#标签页面--关于页面)\n  - [底部自定义](https://github.com/aircloud/hexo-theme-aircloud#底部自定义)\n- 高级自定义\n  - [首行缩进](https://github.com/aircloud/hexo-theme-aircloud#首行缩进)\n- 常见问题\n  - [如何取消赞赏功能？](https://github.com/aircloud/hexo-theme-aircloud#如何取消赞赏功能)\n- [一些注意事项](https://github.com/aircloud/hexo-theme-aircloud#一些注意事项)\n\n## 基本使用\n\n**建议：参考 [DEMO](https://github.com/aircloud/hexo-aircloud-blog) 进行配置，尤其是 _config.yml 部分，否则可能会造成功能缺失**\n\n同其他博客主题使用方式相同，直接 clone 或者下载本项目，复制粘贴到 themes 文件夹下即可。\n\n具体的 _config.yml 自定义配置，请参考[DEMO](https://github.com/aircloud/hexo-aircloud-blog)。\n\n## 功能适配\n\n### 搜索功能\n\n为了使用搜索功能，首先需要安装下列插件：\n\n```\nnpm i hexo-generator-search --save\n```\n\n然后在 _config.yml 中进行配置，可以参考如下配置：\n\n```\nsearch:\n  path: search.json\n  field: post\n```\n\n### `标签`页面 & `关于`页面\n\n如果是新项目，默认是没有`标签`页面和`关于`页面的，需要在`source`文件夹下建立`tags`文件夹和`about`文件夹。\n\n> 注：建议不要直接新建文件，而是采用 hexo 的 `hexo new page tags` 和 `hexo new page about` 的方式新建文件，这样可以被 hexo 索引到。\n\n其中`tags`文件夹中新建`index.md`并写入：\n\n```\n---\nlayout: \"tags\"\ntitle: \"Tags\"\n---\n```\n\n`about`文件夹下`index.md`为一篇支持 markdown 格式的文件，需要在开头添加：\n\n```\n---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ncomments: true\n---\n```\n\n### 评论功能\n\n目前，本博客支持以下评论功能：\n\n- [gitment](https://imsun.net/posts/gitment-introduction/)（gitment 经常会出现限频或者 404 等错误，其作者已关闭github认证转发服务）\n- [disqus](https://disqus.com/)\n- [LiveRe](https://www.livere.com/)\n\n#### gitment\n\n建议先在[gitment](https://imsun.net/posts/gitment-introduction/)进行了解，然后参考[DEMO](https://github.com/aircloud/hexo-aircloud-blog)进行配置，其中一些相关项目如下：\n\n```\ncomment:\n  type: gitment\n  id: your-id-created-by-https://github.com/settings/applications/new\n  secret: your-secret-created-by-https://github.com/settings/applications/new\n  owner: aircloud\n  repo: hexo-aircloud-blog\n```\n\n#### disqus\n\ndisqus 是一个使用比较广泛的评论系统，我们需要先在[官方网站](https://disqus.com/)注册一个账号。\n\n登录后，点击首页的 GET STARTED 按钮，之后选择 I want to install Disqus on my site 选项，填写相关内容，值得注意的是，`Website Name` 需要全网唯一，而且，一般情况，假设你的 `Website Name` 填写的是 example，那么下文 `script` 字段就可以写 `'https://example.disqus.com/embed.js'`。\n\n当然，你也可以在下一步 -> 选择 basic 免费套餐 -> 选择最后的 “I don’t see my platform listed, installed manually with universal code” -> 找到代码中的 `s.src = 'https://xxxx.disqus.com/embed.js'; `, 从而找到 script 地址。(无需插入 disqus 给出的脚本，只需按照这里的说明配置即可)\n\n之后，你需要在 `_config.yml` 中配置如下内容：\n\n```\ncomment:\n   type: disqus\n   script: 'https://example.disqus.com/embed.js'\n```\n\n当然，你也可以配置`url` 和 `identifier`， 但是这个就属于高级内容了，对于我们一般的 hexo 博客网站来说必要性不大，如果你需要配置这些内容，可能你已经是一个高级玩家了，可以在 `themes/aircloud/layout/layout.ejs` 的相关代码的基础上进行改动。\n\n> 注意: 目前，直接嵌入 disqus 的代码可能会加载失败，你也可以考虑将相关代码放在自己的博客下引入：在 public 文件夹下新建文件放入代码，跟随发布即可（放入 source 文件夹下可能会由于 hexo 的处理变得有错误），并同时更改 `_config.yml` 中的配置。\n\n#### LiveRe\n\nLiveRe 是一款来自韩国的支持中文且没有被墙LiveRe评论插件，重点是使用无需翻墙。\n\n该插件分为city和premium两个版本，其中city版是适合所有人使用的免费版本,有更高需求的可以考虑premium版本。\n\n注册之后，选择 安装 -> 选 city版本，按提示操作进入到管理页面，系统会给出一段嵌入代码，找到其中的data-id和data-uid。\n\n之后，你需要在`_config.yml`中配置如下内容\n\n```\ncomment:\n   type: livere\n   livere_id: 'city'\n   livere_uid: \n```\n\n`livere_id` 和 `livere_uid`就是注册后获得的 data-id和data-uid。\n\n### favicon 的配置\n\n项目的 favicon 默认在你的博客根目录的 `/source/img` 下面，在 `/source/img` 下面添加 favicon.ico 即可，不要添加在主题文件夹内。\n\n### 底部自定义\n\n大家如果访问提供的预览链接，会发现我们的博客底部是提供一些内容的：一些社交平台的个人主页链接、友情链接、PV、UV 与 本模版链接。\n\n一般情况下，大家无需改动底部的代码，直接在 `_config.yml` 中配置即可。\n\n配置社交平台主页的样例代码：\n\n```\n# SNS settings\n# 一些社交平台地址，支持以下几种：\nweibo_username:     3286578617\nzhihu_username:     ai-er-lan-xue-da\ngithub_username:    AirCloud\ntwitter_username:   iconie_alloy\nfacebook_username:  xiaotao.nie.5\nlinkedin_username:  小涛-聂-80964aba\n```\n\n如果不想包括某些社交平台，直接注释或删除相关代码即可（目前暂不支持在不改动模版代码的前提下新增社交平台）。\n\n配置友情链接的样例代码：\n\n```\n# Friends\n# 友情链接\nfriends: [\n    {\n        title: \"10000H\",\n        href: \"https://www.10000h.top\"\n    },{\n        title: \"Xiaotao's Page\",\n        href: \"https://niexiaotao.com\"\n    },{\n        title: \"It helps SEO\",\n        href: \"#\"\n    }\n]\n```\n\n最底部的 PV、UV 和模版地址，无需配置。\n\n## 高级自定义\n\n### 首行缩进\n\n目前可以配置是否在博客页面带有首行缩进两个汉字的效果，默认是有首行缩进的效果的，但是也可以通过下面的配置代码进行关闭：\n\n```\npost_style:\n    indent: 0\n```\n\n### 头像圆角\n\n```\navatar_style:\n  radius: true\n```\n\n## 常见问题\n\n### 如何取消赞赏功能？\n\n目前网站的赞赏功能做的比较鸡肋，缺乏一定的丰富度，如果你想取消这个功能，只需取消注释或者删除掉赞赏部分的相关配置即可：\n\n```\ndonate:\n  img: img/donate.jpg\n  content: 感谢鼓励\n```\n\n另外，如果你对赞赏部分有用户体验较好并且通用型比较好的设计，也可以提 issue，我会考虑实现。\n\n## 一些注意事项\n\n由于一些hexo的历史遗留问题等，为了避免给用户在使用过程中带来太多麻烦(比如需要改动主题代码甚至hexo源码)，建议用户使用过程中遵循一些规范：\n\n- 文章不要有跳级目录，比如一个`###`三级目录下是一个`#####`五级目录，然后又有一个`###`三级目录，这样有可能导致 hexo 解析出错，从而影响文章目录部分的展示。\n- 文章的段落(p)都有默认的两个字符的首行缩进，虽然能识别 markdown 段落中的换行，但是无法对换行后的内容进行缩进，所以这里需要注意样式问题(如果需要多行缩进，建议使用多个段落或者做成列表)。\n","source":"_posts/Hexo-Theme-AirCloud.md","raw":"---\ntitle: Hexo-Theme-AirCloud\ndate: 2022-03-09 14:03:36\ntags: Hexo\n---\n\n\n\n## Hexo-Theme-AirCloud: 一个简洁轻量的 hexo 博客主题\n\n## 功能简介\n\nHexo-Theme-AirCloud 是一个简洁轻量的 hexo 博客主题，旨在将中心放在博文本身，因此：\n\n- 默认没有大范围的主题色块、图片铺排等，也不要求每片博文配图，一方面这并不是我们记录知识的重点，另外一方面可能程序员群体并没有足够的素材，容易造成主题纠纷。\n- 建议通过不冗余的内容进行传达，比如默认没有博文摘要，因为不少开发者写博客的时候没有写博文摘要，如果从博客前一部分截取往往不能表达完整思想。\n\n另外，该主题主要实现的功能有:\n\n- 全局搜索功能，并对搜索内容进行高亮。\n- 博客评论功能，目前接入 [gitment](https://imsun.net/posts/gitment-introduction/)，之后考虑接入多种可选。\n- 文章详情页文章目录功能\n- 访问量统计（总体UV、PV，单页PV）\n- 语言切换能力，目前支持中文和英文\n\n## 起步\n\n> 我在”常见问题”中总结了该项目之前被提及的一些问题，如果你在使用过程中遇到了问题，可以在”常见问题”中寻找答案，如果没能解决，欢迎提[issue](https://github.com/aircloud/hexo-theme-aircloud/issues)，我会保证回复。\n\n注意，如果你不按照”功能适配”部分的内容进行操作，可能会导致相关提及的功能无法正常使用。\n\n- [基本使用](https://github.com/aircloud/hexo-theme-aircloud#基本使用)\n- 功能适配\n  - [搜索功能](https://github.com/aircloud/hexo-theme-aircloud#搜索功能)\n  - [`标签`页面 & `关于`页面](https://github.com/aircloud/hexo-theme-aircloud#标签页面--关于页面)\n  - [评论功能](https://github.com/aircloud/hexo-theme-aircloud#评论功能)\n  - [favicon 的配置](https://github.com/aircloud/hexo-theme-aircloud#标签页面--关于页面)\n  - [底部自定义](https://github.com/aircloud/hexo-theme-aircloud#底部自定义)\n- 高级自定义\n  - [首行缩进](https://github.com/aircloud/hexo-theme-aircloud#首行缩进)\n- 常见问题\n  - [如何取消赞赏功能？](https://github.com/aircloud/hexo-theme-aircloud#如何取消赞赏功能)\n- [一些注意事项](https://github.com/aircloud/hexo-theme-aircloud#一些注意事项)\n\n## 基本使用\n\n**建议：参考 [DEMO](https://github.com/aircloud/hexo-aircloud-blog) 进行配置，尤其是 _config.yml 部分，否则可能会造成功能缺失**\n\n同其他博客主题使用方式相同，直接 clone 或者下载本项目，复制粘贴到 themes 文件夹下即可。\n\n具体的 _config.yml 自定义配置，请参考[DEMO](https://github.com/aircloud/hexo-aircloud-blog)。\n\n## 功能适配\n\n### 搜索功能\n\n为了使用搜索功能，首先需要安装下列插件：\n\n```\nnpm i hexo-generator-search --save\n```\n\n然后在 _config.yml 中进行配置，可以参考如下配置：\n\n```\nsearch:\n  path: search.json\n  field: post\n```\n\n### `标签`页面 & `关于`页面\n\n如果是新项目，默认是没有`标签`页面和`关于`页面的，需要在`source`文件夹下建立`tags`文件夹和`about`文件夹。\n\n> 注：建议不要直接新建文件，而是采用 hexo 的 `hexo new page tags` 和 `hexo new page about` 的方式新建文件，这样可以被 hexo 索引到。\n\n其中`tags`文件夹中新建`index.md`并写入：\n\n```\n---\nlayout: \"tags\"\ntitle: \"Tags\"\n---\n```\n\n`about`文件夹下`index.md`为一篇支持 markdown 格式的文件，需要在开头添加：\n\n```\n---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ncomments: true\n---\n```\n\n### 评论功能\n\n目前，本博客支持以下评论功能：\n\n- [gitment](https://imsun.net/posts/gitment-introduction/)（gitment 经常会出现限频或者 404 等错误，其作者已关闭github认证转发服务）\n- [disqus](https://disqus.com/)\n- [LiveRe](https://www.livere.com/)\n\n#### gitment\n\n建议先在[gitment](https://imsun.net/posts/gitment-introduction/)进行了解，然后参考[DEMO](https://github.com/aircloud/hexo-aircloud-blog)进行配置，其中一些相关项目如下：\n\n```\ncomment:\n  type: gitment\n  id: your-id-created-by-https://github.com/settings/applications/new\n  secret: your-secret-created-by-https://github.com/settings/applications/new\n  owner: aircloud\n  repo: hexo-aircloud-blog\n```\n\n#### disqus\n\ndisqus 是一个使用比较广泛的评论系统，我们需要先在[官方网站](https://disqus.com/)注册一个账号。\n\n登录后，点击首页的 GET STARTED 按钮，之后选择 I want to install Disqus on my site 选项，填写相关内容，值得注意的是，`Website Name` 需要全网唯一，而且，一般情况，假设你的 `Website Name` 填写的是 example，那么下文 `script` 字段就可以写 `'https://example.disqus.com/embed.js'`。\n\n当然，你也可以在下一步 -> 选择 basic 免费套餐 -> 选择最后的 “I don’t see my platform listed, installed manually with universal code” -> 找到代码中的 `s.src = 'https://xxxx.disqus.com/embed.js'; `, 从而找到 script 地址。(无需插入 disqus 给出的脚本，只需按照这里的说明配置即可)\n\n之后，你需要在 `_config.yml` 中配置如下内容：\n\n```\ncomment:\n   type: disqus\n   script: 'https://example.disqus.com/embed.js'\n```\n\n当然，你也可以配置`url` 和 `identifier`， 但是这个就属于高级内容了，对于我们一般的 hexo 博客网站来说必要性不大，如果你需要配置这些内容，可能你已经是一个高级玩家了，可以在 `themes/aircloud/layout/layout.ejs` 的相关代码的基础上进行改动。\n\n> 注意: 目前，直接嵌入 disqus 的代码可能会加载失败，你也可以考虑将相关代码放在自己的博客下引入：在 public 文件夹下新建文件放入代码，跟随发布即可（放入 source 文件夹下可能会由于 hexo 的处理变得有错误），并同时更改 `_config.yml` 中的配置。\n\n#### LiveRe\n\nLiveRe 是一款来自韩国的支持中文且没有被墙LiveRe评论插件，重点是使用无需翻墙。\n\n该插件分为city和premium两个版本，其中city版是适合所有人使用的免费版本,有更高需求的可以考虑premium版本。\n\n注册之后，选择 安装 -> 选 city版本，按提示操作进入到管理页面，系统会给出一段嵌入代码，找到其中的data-id和data-uid。\n\n之后，你需要在`_config.yml`中配置如下内容\n\n```\ncomment:\n   type: livere\n   livere_id: 'city'\n   livere_uid: \n```\n\n`livere_id` 和 `livere_uid`就是注册后获得的 data-id和data-uid。\n\n### favicon 的配置\n\n项目的 favicon 默认在你的博客根目录的 `/source/img` 下面，在 `/source/img` 下面添加 favicon.ico 即可，不要添加在主题文件夹内。\n\n### 底部自定义\n\n大家如果访问提供的预览链接，会发现我们的博客底部是提供一些内容的：一些社交平台的个人主页链接、友情链接、PV、UV 与 本模版链接。\n\n一般情况下，大家无需改动底部的代码，直接在 `_config.yml` 中配置即可。\n\n配置社交平台主页的样例代码：\n\n```\n# SNS settings\n# 一些社交平台地址，支持以下几种：\nweibo_username:     3286578617\nzhihu_username:     ai-er-lan-xue-da\ngithub_username:    AirCloud\ntwitter_username:   iconie_alloy\nfacebook_username:  xiaotao.nie.5\nlinkedin_username:  小涛-聂-80964aba\n```\n\n如果不想包括某些社交平台，直接注释或删除相关代码即可（目前暂不支持在不改动模版代码的前提下新增社交平台）。\n\n配置友情链接的样例代码：\n\n```\n# Friends\n# 友情链接\nfriends: [\n    {\n        title: \"10000H\",\n        href: \"https://www.10000h.top\"\n    },{\n        title: \"Xiaotao's Page\",\n        href: \"https://niexiaotao.com\"\n    },{\n        title: \"It helps SEO\",\n        href: \"#\"\n    }\n]\n```\n\n最底部的 PV、UV 和模版地址，无需配置。\n\n## 高级自定义\n\n### 首行缩进\n\n目前可以配置是否在博客页面带有首行缩进两个汉字的效果，默认是有首行缩进的效果的，但是也可以通过下面的配置代码进行关闭：\n\n```\npost_style:\n    indent: 0\n```\n\n### 头像圆角\n\n```\navatar_style:\n  radius: true\n```\n\n## 常见问题\n\n### 如何取消赞赏功能？\n\n目前网站的赞赏功能做的比较鸡肋，缺乏一定的丰富度，如果你想取消这个功能，只需取消注释或者删除掉赞赏部分的相关配置即可：\n\n```\ndonate:\n  img: img/donate.jpg\n  content: 感谢鼓励\n```\n\n另外，如果你对赞赏部分有用户体验较好并且通用型比较好的设计，也可以提 issue，我会考虑实现。\n\n## 一些注意事项\n\n由于一些hexo的历史遗留问题等，为了避免给用户在使用过程中带来太多麻烦(比如需要改动主题代码甚至hexo源码)，建议用户使用过程中遵循一些规范：\n\n- 文章不要有跳级目录，比如一个`###`三级目录下是一个`#####`五级目录，然后又有一个`###`三级目录，这样有可能导致 hexo 解析出错，从而影响文章目录部分的展示。\n- 文章的段落(p)都有默认的两个字符的首行缩进，虽然能识别 markdown 段落中的换行，但是无法对换行后的内容进行缩进，所以这里需要注意样式问题(如果需要多行缩进，建议使用多个段落或者做成列表)。\n","slug":"Hexo-Theme-AirCloud","published":1,"updated":"2022-03-09T06:05:57.798Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0vrkoq3000510lnhm82hpqb","content":"<h2 id=\"Hexo-Theme-AirCloud-一个简洁轻量的-hexo-博客主题\"><a href=\"#Hexo-Theme-AirCloud-一个简洁轻量的-hexo-博客主题\" class=\"headerlink\" title=\"Hexo-Theme-AirCloud: 一个简洁轻量的 hexo 博客主题\"></a>Hexo-Theme-AirCloud: 一个简洁轻量的 hexo 博客主题</h2><h2 id=\"功能简介\"><a href=\"#功能简介\" class=\"headerlink\" title=\"功能简介\"></a>功能简介</h2><p>Hexo-Theme-AirCloud 是一个简洁轻量的 hexo 博客主题，旨在将中心放在博文本身，因此：</p>\n<ul>\n<li>默认没有大范围的主题色块、图片铺排等，也不要求每片博文配图，一方面这并不是我们记录知识的重点，另外一方面可能程序员群体并没有足够的素材，容易造成主题纠纷。</li>\n<li>建议通过不冗余的内容进行传达，比如默认没有博文摘要，因为不少开发者写博客的时候没有写博文摘要，如果从博客前一部分截取往往不能表达完整思想。</li>\n</ul>\n<p>另外，该主题主要实现的功能有:</p>\n<ul>\n<li>全局搜索功能，并对搜索内容进行高亮。</li>\n<li>博客评论功能，目前接入 <a href=\"https://imsun.net/posts/gitment-introduction/\">gitment</a>，之后考虑接入多种可选。</li>\n<li>文章详情页文章目录功能</li>\n<li>访问量统计（总体UV、PV，单页PV）</li>\n<li>语言切换能力，目前支持中文和英文</li>\n</ul>\n<h2 id=\"起步\"><a href=\"#起步\" class=\"headerlink\" title=\"起步\"></a>起步</h2><blockquote>\n<p>我在”常见问题”中总结了该项目之前被提及的一些问题，如果你在使用过程中遇到了问题，可以在”常见问题”中寻找答案，如果没能解决，欢迎提<a href=\"https://github.com/aircloud/hexo-theme-aircloud/issues\">issue</a>，我会保证回复。</p>\n</blockquote>\n<p>注意，如果你不按照”功能适配”部分的内容进行操作，可能会导致相关提及的功能无法正常使用。</p>\n<ul>\n<li><a href=\"https://github.com/aircloud/hexo-theme-aircloud#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8\">基本使用</a></li>\n<li>功能适配<ul>\n<li><a href=\"https://github.com/aircloud/hexo-theme-aircloud#%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD\">搜索功能</a></li>\n<li><a href=\"https://github.com/aircloud/hexo-theme-aircloud#%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%9D%A2--%E5%85%B3%E4%BA%8E%E9%A1%B5%E9%9D%A2\"><code>标签</code>页面 &amp; <code>关于</code>页面</a></li>\n<li><a href=\"https://github.com/aircloud/hexo-theme-aircloud#%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD\">评论功能</a></li>\n<li><a href=\"https://github.com/aircloud/hexo-theme-aircloud#%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%9D%A2--%E5%85%B3%E4%BA%8E%E9%A1%B5%E9%9D%A2\">favicon 的配置</a></li>\n<li><a href=\"https://github.com/aircloud/hexo-theme-aircloud#%E5%BA%95%E9%83%A8%E8%87%AA%E5%AE%9A%E4%B9%89\">底部自定义</a></li>\n</ul>\n</li>\n<li>高级自定义<ul>\n<li><a href=\"https://github.com/aircloud/hexo-theme-aircloud#%E9%A6%96%E8%A1%8C%E7%BC%A9%E8%BF%9B\">首行缩进</a></li>\n</ul>\n</li>\n<li>常见问题<ul>\n<li><a href=\"https://github.com/aircloud/hexo-theme-aircloud#%E5%A6%82%E4%BD%95%E5%8F%96%E6%B6%88%E8%B5%9E%E8%B5%8F%E5%8A%9F%E8%83%BD\">如何取消赞赏功能？</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/aircloud/hexo-theme-aircloud#%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\">一些注意事项</a></li>\n</ul>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><p><strong>建议：参考 <a href=\"https://github.com/aircloud/hexo-aircloud-blog\">DEMO</a> 进行配置，尤其是 _config.yml 部分，否则可能会造成功能缺失</strong></p>\n<p>同其他博客主题使用方式相同，直接 clone 或者下载本项目，复制粘贴到 themes 文件夹下即可。</p>\n<p>具体的 _config.yml 自定义配置，请参考<a href=\"https://github.com/aircloud/hexo-aircloud-blog\">DEMO</a>。</p>\n<h2 id=\"功能适配\"><a href=\"#功能适配\" class=\"headerlink\" title=\"功能适配\"></a>功能适配</h2><h3 id=\"搜索功能\"><a href=\"#搜索功能\" class=\"headerlink\" title=\"搜索功能\"></a>搜索功能</h3><p>为了使用搜索功能，首先需要安装下列插件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i hexo-generator-search --save</span><br></pre></td></tr></table></figure>\n\n<p>然后在 _config.yml 中进行配置，可以参考如下配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">search:</span><br><span class=\"line\">  path: search.json</span><br><span class=\"line\">  field: post</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"标签页面-amp-关于页面\"><a href=\"#标签页面-amp-关于页面\" class=\"headerlink\" title=\"标签页面 &amp; 关于页面\"></a><code>标签</code>页面 &amp; <code>关于</code>页面</h3><p>如果是新项目，默认是没有<code>标签</code>页面和<code>关于</code>页面的，需要在<code>source</code>文件夹下建立<code>tags</code>文件夹和<code>about</code>文件夹。</p>\n<blockquote>\n<p>注：建议不要直接新建文件，而是采用 hexo 的 <code>hexo new page tags</code> 和 <code>hexo new page about</code> 的方式新建文件，这样可以被 hexo 索引到。</p>\n</blockquote>\n<p>其中<code>tags</code>文件夹中新建<code>index.md</code>并写入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">layout: &quot;tags&quot;</span><br><span class=\"line\">title: &quot;Tags&quot;</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<p><code>about</code>文件夹下<code>index.md</code>为一篇支持 markdown 格式的文件，需要在开头添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">layout: &quot;about&quot;</span><br><span class=\"line\">title: &quot;About&quot;</span><br><span class=\"line\">date: 2016-04-21 04:48:33</span><br><span class=\"line\">comments: true</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"评论功能\"><a href=\"#评论功能\" class=\"headerlink\" title=\"评论功能\"></a>评论功能</h3><p>目前，本博客支持以下评论功能：</p>\n<ul>\n<li><a href=\"https://imsun.net/posts/gitment-introduction/\">gitment</a>（gitment 经常会出现限频或者 404 等错误，其作者已关闭github认证转发服务）</li>\n<li><a href=\"https://disqus.com/\">disqus</a></li>\n<li><a href=\"https://www.livere.com/\">LiveRe</a></li>\n</ul>\n<h4 id=\"gitment\"><a href=\"#gitment\" class=\"headerlink\" title=\"gitment\"></a>gitment</h4><p>建议先在<a href=\"https://imsun.net/posts/gitment-introduction/\">gitment</a>进行了解，然后参考<a href=\"https://github.com/aircloud/hexo-aircloud-blog\">DEMO</a>进行配置，其中一些相关项目如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">comment:</span><br><span class=\"line\">  type: gitment</span><br><span class=\"line\">  id: your-id-created-by-https://github.com/settings/applications/new</span><br><span class=\"line\">  secret: your-secret-created-by-https://github.com/settings/applications/new</span><br><span class=\"line\">  owner: aircloud</span><br><span class=\"line\">  repo: hexo-aircloud-blog</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"disqus\"><a href=\"#disqus\" class=\"headerlink\" title=\"disqus\"></a>disqus</h4><p>disqus 是一个使用比较广泛的评论系统，我们需要先在<a href=\"https://disqus.com/\">官方网站</a>注册一个账号。</p>\n<p>登录后，点击首页的 GET STARTED 按钮，之后选择 I want to install Disqus on my site 选项，填写相关内容，值得注意的是，<code>Website Name</code> 需要全网唯一，而且，一般情况，假设你的 <code>Website Name</code> 填写的是 example，那么下文 <code>script</code> 字段就可以写 <code>&#39;https://example.disqus.com/embed.js&#39;</code>。</p>\n<p>当然，你也可以在下一步 -&gt; 选择 basic 免费套餐 -&gt; 选择最后的 “I don’t see my platform listed, installed manually with universal code” -&gt; 找到代码中的 <code>s.src = &#39;https://xxxx.disqus.com/embed.js&#39;; </code>, 从而找到 script 地址。(无需插入 disqus 给出的脚本，只需按照这里的说明配置即可)</p>\n<p>之后，你需要在 <code>_config.yml</code> 中配置如下内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">comment:</span><br><span class=\"line\">   type: disqus</span><br><span class=\"line\">   script: &#x27;https://example.disqus.com/embed.js&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>当然，你也可以配置<code>url</code> 和 <code>identifier</code>， 但是这个就属于高级内容了，对于我们一般的 hexo 博客网站来说必要性不大，如果你需要配置这些内容，可能你已经是一个高级玩家了，可以在 <code>themes/aircloud/layout/layout.ejs</code> 的相关代码的基础上进行改动。</p>\n<blockquote>\n<p>注意: 目前，直接嵌入 disqus 的代码可能会加载失败，你也可以考虑将相关代码放在自己的博客下引入：在 public 文件夹下新建文件放入代码，跟随发布即可（放入 source 文件夹下可能会由于 hexo 的处理变得有错误），并同时更改 <code>_config.yml</code> 中的配置。</p>\n</blockquote>\n<h4 id=\"LiveRe\"><a href=\"#LiveRe\" class=\"headerlink\" title=\"LiveRe\"></a>LiveRe</h4><p>LiveRe 是一款来自韩国的支持中文且没有被墙LiveRe评论插件，重点是使用无需翻墙。</p>\n<p>该插件分为city和premium两个版本，其中city版是适合所有人使用的免费版本,有更高需求的可以考虑premium版本。</p>\n<p>注册之后，选择 安装 -&gt; 选 city版本，按提示操作进入到管理页面，系统会给出一段嵌入代码，找到其中的data-id和data-uid。</p>\n<p>之后，你需要在<code>_config.yml</code>中配置如下内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">comment:</span><br><span class=\"line\">   type: livere</span><br><span class=\"line\">   livere_id: &#x27;city&#x27;</span><br><span class=\"line\">   livere_uid: </span><br></pre></td></tr></table></figure>\n\n<p><code>livere_id</code> 和 <code>livere_uid</code>就是注册后获得的 data-id和data-uid。</p>\n<h3 id=\"favicon-的配置\"><a href=\"#favicon-的配置\" class=\"headerlink\" title=\"favicon 的配置\"></a>favicon 的配置</h3><p>项目的 favicon 默认在你的博客根目录的 <code>/source/img</code> 下面，在 <code>/source/img</code> 下面添加 favicon.ico 即可，不要添加在主题文件夹内。</p>\n<h3 id=\"底部自定义\"><a href=\"#底部自定义\" class=\"headerlink\" title=\"底部自定义\"></a>底部自定义</h3><p>大家如果访问提供的预览链接，会发现我们的博客底部是提供一些内容的：一些社交平台的个人主页链接、友情链接、PV、UV 与 本模版链接。</p>\n<p>一般情况下，大家无需改动底部的代码，直接在 <code>_config.yml</code> 中配置即可。</p>\n<p>配置社交平台主页的样例代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># SNS settings</span><br><span class=\"line\"># 一些社交平台地址，支持以下几种：</span><br><span class=\"line\">weibo_username:     3286578617</span><br><span class=\"line\">zhihu_username:     ai-er-lan-xue-da</span><br><span class=\"line\">github_username:    AirCloud</span><br><span class=\"line\">twitter_username:   iconie_alloy</span><br><span class=\"line\">facebook_username:  xiaotao.nie.5</span><br><span class=\"line\">linkedin_username:  小涛-聂-80964aba</span><br></pre></td></tr></table></figure>\n\n<p>如果不想包括某些社交平台，直接注释或删除相关代码即可（目前暂不支持在不改动模版代码的前提下新增社交平台）。</p>\n<p>配置友情链接的样例代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Friends</span><br><span class=\"line\"># 友情链接</span><br><span class=\"line\">friends: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        title: &quot;10000H&quot;,</span><br><span class=\"line\">        href: &quot;https://www.10000h.top&quot;</span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">        title: &quot;Xiaotao&#x27;s Page&quot;,</span><br><span class=\"line\">        href: &quot;https://niexiaotao.com&quot;</span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">        title: &quot;It helps SEO&quot;,</span><br><span class=\"line\">        href: &quot;#&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>最底部的 PV、UV 和模版地址，无需配置。</p>\n<h2 id=\"高级自定义\"><a href=\"#高级自定义\" class=\"headerlink\" title=\"高级自定义\"></a>高级自定义</h2><h3 id=\"首行缩进\"><a href=\"#首行缩进\" class=\"headerlink\" title=\"首行缩进\"></a>首行缩进</h3><p>目前可以配置是否在博客页面带有首行缩进两个汉字的效果，默认是有首行缩进的效果的，但是也可以通过下面的配置代码进行关闭：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">post_style:</span><br><span class=\"line\">    indent: 0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"头像圆角\"><a href=\"#头像圆角\" class=\"headerlink\" title=\"头像圆角\"></a>头像圆角</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">avatar_style:</span><br><span class=\"line\">  radius: true</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><h3 id=\"如何取消赞赏功能？\"><a href=\"#如何取消赞赏功能？\" class=\"headerlink\" title=\"如何取消赞赏功能？\"></a>如何取消赞赏功能？</h3><p>目前网站的赞赏功能做的比较鸡肋，缺乏一定的丰富度，如果你想取消这个功能，只需取消注释或者删除掉赞赏部分的相关配置即可：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">donate:</span><br><span class=\"line\">  img: img/donate.jpg</span><br><span class=\"line\">  content: 感谢鼓励</span><br></pre></td></tr></table></figure>\n\n<p>另外，如果你对赞赏部分有用户体验较好并且通用型比较好的设计，也可以提 issue，我会考虑实现。</p>\n<h2 id=\"一些注意事项\"><a href=\"#一些注意事项\" class=\"headerlink\" title=\"一些注意事项\"></a>一些注意事项</h2><p>由于一些hexo的历史遗留问题等，为了避免给用户在使用过程中带来太多麻烦(比如需要改动主题代码甚至hexo源码)，建议用户使用过程中遵循一些规范：</p>\n<ul>\n<li>文章不要有跳级目录，比如一个<code>###</code>三级目录下是一个<code>#####</code>五级目录，然后又有一个<code>###</code>三级目录，这样有可能导致 hexo 解析出错，从而影响文章目录部分的展示。</li>\n<li>文章的段落(p)都有默认的两个字符的首行缩进，虽然能识别 markdown 段落中的换行，但是无法对换行后的内容进行缩进，所以这里需要注意样式问题(如果需要多行缩进，建议使用多个段落或者做成列表)。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Hexo-Theme-AirCloud-一个简洁轻量的-hexo-博客主题\"><a href=\"#Hexo-Theme-AirCloud-一个简洁轻量的-hexo-博客主题\" class=\"headerlink\" title=\"Hexo-Theme-AirCloud: 一个简洁轻量的 hexo 博客主题\"></a>Hexo-Theme-AirCloud: 一个简洁轻量的 hexo 博客主题</h2><h2 id=\"功能简介\"><a href=\"#功能简介\" class=\"headerlink\" title=\"功能简介\"></a>功能简介</h2><p>Hexo-Theme-AirCloud 是一个简洁轻量的 hexo 博客主题，旨在将中心放在博文本身，因此：</p>\n<ul>\n<li>默认没有大范围的主题色块、图片铺排等，也不要求每片博文配图，一方面这并不是我们记录知识的重点，另外一方面可能程序员群体并没有足够的素材，容易造成主题纠纷。</li>\n<li>建议通过不冗余的内容进行传达，比如默认没有博文摘要，因为不少开发者写博客的时候没有写博文摘要，如果从博客前一部分截取往往不能表达完整思想。</li>\n</ul>\n<p>另外，该主题主要实现的功能有:</p>\n<ul>\n<li>全局搜索功能，并对搜索内容进行高亮。</li>\n<li>博客评论功能，目前接入 <a href=\"https://imsun.net/posts/gitment-introduction/\">gitment</a>，之后考虑接入多种可选。</li>\n<li>文章详情页文章目录功能</li>\n<li>访问量统计（总体UV、PV，单页PV）</li>\n<li>语言切换能力，目前支持中文和英文</li>\n</ul>\n<h2 id=\"起步\"><a href=\"#起步\" class=\"headerlink\" title=\"起步\"></a>起步</h2><blockquote>\n<p>我在”常见问题”中总结了该项目之前被提及的一些问题，如果你在使用过程中遇到了问题，可以在”常见问题”中寻找答案，如果没能解决，欢迎提<a href=\"https://github.com/aircloud/hexo-theme-aircloud/issues\">issue</a>，我会保证回复。</p>\n</blockquote>\n<p>注意，如果你不按照”功能适配”部分的内容进行操作，可能会导致相关提及的功能无法正常使用。</p>\n<ul>\n<li><a href=\"https://github.com/aircloud/hexo-theme-aircloud#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8\">基本使用</a></li>\n<li>功能适配<ul>\n<li><a href=\"https://github.com/aircloud/hexo-theme-aircloud#%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD\">搜索功能</a></li>\n<li><a href=\"https://github.com/aircloud/hexo-theme-aircloud#%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%9D%A2--%E5%85%B3%E4%BA%8E%E9%A1%B5%E9%9D%A2\"><code>标签</code>页面 &amp; <code>关于</code>页面</a></li>\n<li><a href=\"https://github.com/aircloud/hexo-theme-aircloud#%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD\">评论功能</a></li>\n<li><a href=\"https://github.com/aircloud/hexo-theme-aircloud#%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%9D%A2--%E5%85%B3%E4%BA%8E%E9%A1%B5%E9%9D%A2\">favicon 的配置</a></li>\n<li><a href=\"https://github.com/aircloud/hexo-theme-aircloud#%E5%BA%95%E9%83%A8%E8%87%AA%E5%AE%9A%E4%B9%89\">底部自定义</a></li>\n</ul>\n</li>\n<li>高级自定义<ul>\n<li><a href=\"https://github.com/aircloud/hexo-theme-aircloud#%E9%A6%96%E8%A1%8C%E7%BC%A9%E8%BF%9B\">首行缩进</a></li>\n</ul>\n</li>\n<li>常见问题<ul>\n<li><a href=\"https://github.com/aircloud/hexo-theme-aircloud#%E5%A6%82%E4%BD%95%E5%8F%96%E6%B6%88%E8%B5%9E%E8%B5%8F%E5%8A%9F%E8%83%BD\">如何取消赞赏功能？</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/aircloud/hexo-theme-aircloud#%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\">一些注意事项</a></li>\n</ul>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><p><strong>建议：参考 <a href=\"https://github.com/aircloud/hexo-aircloud-blog\">DEMO</a> 进行配置，尤其是 _config.yml 部分，否则可能会造成功能缺失</strong></p>\n<p>同其他博客主题使用方式相同，直接 clone 或者下载本项目，复制粘贴到 themes 文件夹下即可。</p>\n<p>具体的 _config.yml 自定义配置，请参考<a href=\"https://github.com/aircloud/hexo-aircloud-blog\">DEMO</a>。</p>\n<h2 id=\"功能适配\"><a href=\"#功能适配\" class=\"headerlink\" title=\"功能适配\"></a>功能适配</h2><h3 id=\"搜索功能\"><a href=\"#搜索功能\" class=\"headerlink\" title=\"搜索功能\"></a>搜索功能</h3><p>为了使用搜索功能，首先需要安装下列插件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i hexo-generator-search --save</span><br></pre></td></tr></table></figure>\n\n<p>然后在 _config.yml 中进行配置，可以参考如下配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">search:</span><br><span class=\"line\">  path: search.json</span><br><span class=\"line\">  field: post</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"标签页面-amp-关于页面\"><a href=\"#标签页面-amp-关于页面\" class=\"headerlink\" title=\"标签页面 &amp; 关于页面\"></a><code>标签</code>页面 &amp; <code>关于</code>页面</h3><p>如果是新项目，默认是没有<code>标签</code>页面和<code>关于</code>页面的，需要在<code>source</code>文件夹下建立<code>tags</code>文件夹和<code>about</code>文件夹。</p>\n<blockquote>\n<p>注：建议不要直接新建文件，而是采用 hexo 的 <code>hexo new page tags</code> 和 <code>hexo new page about</code> 的方式新建文件，这样可以被 hexo 索引到。</p>\n</blockquote>\n<p>其中<code>tags</code>文件夹中新建<code>index.md</code>并写入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">layout: &quot;tags&quot;</span><br><span class=\"line\">title: &quot;Tags&quot;</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<p><code>about</code>文件夹下<code>index.md</code>为一篇支持 markdown 格式的文件，需要在开头添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">layout: &quot;about&quot;</span><br><span class=\"line\">title: &quot;About&quot;</span><br><span class=\"line\">date: 2016-04-21 04:48:33</span><br><span class=\"line\">comments: true</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"评论功能\"><a href=\"#评论功能\" class=\"headerlink\" title=\"评论功能\"></a>评论功能</h3><p>目前，本博客支持以下评论功能：</p>\n<ul>\n<li><a href=\"https://imsun.net/posts/gitment-introduction/\">gitment</a>（gitment 经常会出现限频或者 404 等错误，其作者已关闭github认证转发服务）</li>\n<li><a href=\"https://disqus.com/\">disqus</a></li>\n<li><a href=\"https://www.livere.com/\">LiveRe</a></li>\n</ul>\n<h4 id=\"gitment\"><a href=\"#gitment\" class=\"headerlink\" title=\"gitment\"></a>gitment</h4><p>建议先在<a href=\"https://imsun.net/posts/gitment-introduction/\">gitment</a>进行了解，然后参考<a href=\"https://github.com/aircloud/hexo-aircloud-blog\">DEMO</a>进行配置，其中一些相关项目如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">comment:</span><br><span class=\"line\">  type: gitment</span><br><span class=\"line\">  id: your-id-created-by-https://github.com/settings/applications/new</span><br><span class=\"line\">  secret: your-secret-created-by-https://github.com/settings/applications/new</span><br><span class=\"line\">  owner: aircloud</span><br><span class=\"line\">  repo: hexo-aircloud-blog</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"disqus\"><a href=\"#disqus\" class=\"headerlink\" title=\"disqus\"></a>disqus</h4><p>disqus 是一个使用比较广泛的评论系统，我们需要先在<a href=\"https://disqus.com/\">官方网站</a>注册一个账号。</p>\n<p>登录后，点击首页的 GET STARTED 按钮，之后选择 I want to install Disqus on my site 选项，填写相关内容，值得注意的是，<code>Website Name</code> 需要全网唯一，而且，一般情况，假设你的 <code>Website Name</code> 填写的是 example，那么下文 <code>script</code> 字段就可以写 <code>&#39;https://example.disqus.com/embed.js&#39;</code>。</p>\n<p>当然，你也可以在下一步 -&gt; 选择 basic 免费套餐 -&gt; 选择最后的 “I don’t see my platform listed, installed manually with universal code” -&gt; 找到代码中的 <code>s.src = &#39;https://xxxx.disqus.com/embed.js&#39;; </code>, 从而找到 script 地址。(无需插入 disqus 给出的脚本，只需按照这里的说明配置即可)</p>\n<p>之后，你需要在 <code>_config.yml</code> 中配置如下内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">comment:</span><br><span class=\"line\">   type: disqus</span><br><span class=\"line\">   script: &#x27;https://example.disqus.com/embed.js&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>当然，你也可以配置<code>url</code> 和 <code>identifier</code>， 但是这个就属于高级内容了，对于我们一般的 hexo 博客网站来说必要性不大，如果你需要配置这些内容，可能你已经是一个高级玩家了，可以在 <code>themes/aircloud/layout/layout.ejs</code> 的相关代码的基础上进行改动。</p>\n<blockquote>\n<p>注意: 目前，直接嵌入 disqus 的代码可能会加载失败，你也可以考虑将相关代码放在自己的博客下引入：在 public 文件夹下新建文件放入代码，跟随发布即可（放入 source 文件夹下可能会由于 hexo 的处理变得有错误），并同时更改 <code>_config.yml</code> 中的配置。</p>\n</blockquote>\n<h4 id=\"LiveRe\"><a href=\"#LiveRe\" class=\"headerlink\" title=\"LiveRe\"></a>LiveRe</h4><p>LiveRe 是一款来自韩国的支持中文且没有被墙LiveRe评论插件，重点是使用无需翻墙。</p>\n<p>该插件分为city和premium两个版本，其中city版是适合所有人使用的免费版本,有更高需求的可以考虑premium版本。</p>\n<p>注册之后，选择 安装 -&gt; 选 city版本，按提示操作进入到管理页面，系统会给出一段嵌入代码，找到其中的data-id和data-uid。</p>\n<p>之后，你需要在<code>_config.yml</code>中配置如下内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">comment:</span><br><span class=\"line\">   type: livere</span><br><span class=\"line\">   livere_id: &#x27;city&#x27;</span><br><span class=\"line\">   livere_uid: </span><br></pre></td></tr></table></figure>\n\n<p><code>livere_id</code> 和 <code>livere_uid</code>就是注册后获得的 data-id和data-uid。</p>\n<h3 id=\"favicon-的配置\"><a href=\"#favicon-的配置\" class=\"headerlink\" title=\"favicon 的配置\"></a>favicon 的配置</h3><p>项目的 favicon 默认在你的博客根目录的 <code>/source/img</code> 下面，在 <code>/source/img</code> 下面添加 favicon.ico 即可，不要添加在主题文件夹内。</p>\n<h3 id=\"底部自定义\"><a href=\"#底部自定义\" class=\"headerlink\" title=\"底部自定义\"></a>底部自定义</h3><p>大家如果访问提供的预览链接，会发现我们的博客底部是提供一些内容的：一些社交平台的个人主页链接、友情链接、PV、UV 与 本模版链接。</p>\n<p>一般情况下，大家无需改动底部的代码，直接在 <code>_config.yml</code> 中配置即可。</p>\n<p>配置社交平台主页的样例代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># SNS settings</span><br><span class=\"line\"># 一些社交平台地址，支持以下几种：</span><br><span class=\"line\">weibo_username:     3286578617</span><br><span class=\"line\">zhihu_username:     ai-er-lan-xue-da</span><br><span class=\"line\">github_username:    AirCloud</span><br><span class=\"line\">twitter_username:   iconie_alloy</span><br><span class=\"line\">facebook_username:  xiaotao.nie.5</span><br><span class=\"line\">linkedin_username:  小涛-聂-80964aba</span><br></pre></td></tr></table></figure>\n\n<p>如果不想包括某些社交平台，直接注释或删除相关代码即可（目前暂不支持在不改动模版代码的前提下新增社交平台）。</p>\n<p>配置友情链接的样例代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Friends</span><br><span class=\"line\"># 友情链接</span><br><span class=\"line\">friends: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        title: &quot;10000H&quot;,</span><br><span class=\"line\">        href: &quot;https://www.10000h.top&quot;</span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">        title: &quot;Xiaotao&#x27;s Page&quot;,</span><br><span class=\"line\">        href: &quot;https://niexiaotao.com&quot;</span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">        title: &quot;It helps SEO&quot;,</span><br><span class=\"line\">        href: &quot;#&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>最底部的 PV、UV 和模版地址，无需配置。</p>\n<h2 id=\"高级自定义\"><a href=\"#高级自定义\" class=\"headerlink\" title=\"高级自定义\"></a>高级自定义</h2><h3 id=\"首行缩进\"><a href=\"#首行缩进\" class=\"headerlink\" title=\"首行缩进\"></a>首行缩进</h3><p>目前可以配置是否在博客页面带有首行缩进两个汉字的效果，默认是有首行缩进的效果的，但是也可以通过下面的配置代码进行关闭：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">post_style:</span><br><span class=\"line\">    indent: 0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"头像圆角\"><a href=\"#头像圆角\" class=\"headerlink\" title=\"头像圆角\"></a>头像圆角</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">avatar_style:</span><br><span class=\"line\">  radius: true</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><h3 id=\"如何取消赞赏功能？\"><a href=\"#如何取消赞赏功能？\" class=\"headerlink\" title=\"如何取消赞赏功能？\"></a>如何取消赞赏功能？</h3><p>目前网站的赞赏功能做的比较鸡肋，缺乏一定的丰富度，如果你想取消这个功能，只需取消注释或者删除掉赞赏部分的相关配置即可：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">donate:</span><br><span class=\"line\">  img: img/donate.jpg</span><br><span class=\"line\">  content: 感谢鼓励</span><br></pre></td></tr></table></figure>\n\n<p>另外，如果你对赞赏部分有用户体验较好并且通用型比较好的设计，也可以提 issue，我会考虑实现。</p>\n<h2 id=\"一些注意事项\"><a href=\"#一些注意事项\" class=\"headerlink\" title=\"一些注意事项\"></a>一些注意事项</h2><p>由于一些hexo的历史遗留问题等，为了避免给用户在使用过程中带来太多麻烦(比如需要改动主题代码甚至hexo源码)，建议用户使用过程中遵循一些规范：</p>\n<ul>\n<li>文章不要有跳级目录，比如一个<code>###</code>三级目录下是一个<code>#####</code>五级目录，然后又有一个<code>###</code>三级目录，这样有可能导致 hexo 解析出错，从而影响文章目录部分的展示。</li>\n<li>文章的段落(p)都有默认的两个字符的首行缩进，虽然能识别 markdown 段落中的换行，但是无法对换行后的内容进行缩进，所以这里需要注意样式问题(如果需要多行缩进，建议使用多个段落或者做成列表)。</li>\n</ul>\n"},{"title":"MySql-Transaction-Isolation-Level","date":"2022-03-10T07:33:59.000Z","_content":"\n\n# 事务的4大特性ACID\n原子性（Atomicity）：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。\n一致性（Consistent）：一方面，在事务开始之前和事务结束以后，数据库的完整性没有被破坏；另一方面，写入的数据必须完全符合所有的预设规则。\n隔离性（Isolation）：不同的会话或线程，操作数据库的时候可能产生多个事务。如果同时操作一张表或同一行数据，必然产生并发或干扰操作。隔离性要求事务间对表或数据操作是透明的，互相不存在干扰的，通过这种方式保证一致性。\n持久性（Durable）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\n\n#  MySQL 事务的隔离级别\n\n\n\n## 准备环境\n\n```\n docker pull mysql\n docker run --name=mysql -it -p3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql\n docker ps -a\n docker exec -it 15084 bash\n mysql -u root -p\n mysql> create database kangpan\n mysql> use kangpan\n\n```\n\n\n\n## 准备数据\n\n```\nmysql> create table user(\n    -> id int(10) auto_increment,\n    -> name varchar(30) default null,\n    -> age tinyint(4) default null,\n    -> primary key (id)\n    -> )engine=innodb charset=utf8mb4;\n\n insert into user(id, name, age) values (1,'kangpan',31);\n\nmysql> select * from user;\n+----+---------+------+\n| id | name    | age  |\n+----+---------+------+\n|  1 | kangpan |   31 |\n+----+---------+------+\n1 row in set (0.00 sec)\n```\n\n## 事务并发可能出现的情况\n\n#### 脏读（Dirty Read）\n\n一个事务读到了另一个未提交事务修改过的数据\n\n\n\n#### 幻读（Phantom）\n\n一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。（幻读在读未提交、读已提交、可重复读隔离级别都可能会出现）\n\n\n\n#### 不可重复读（Non-Repeatable Read）\n\n一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值。（不可重复读在读未提交和读已提交隔离级别都可能会出现）\n\n\n\n#### 幻读（Phantom）\n\n一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。（幻读在读未提交、读已提交、可重复读隔离级别都可能会出现）\n\n\n\n## 事务的隔离级别\n\nMySQL的事务隔离级别一共有四个，分别是读未提交、读已提交、可重复读以及可串行化。\n\nMySQL的隔离级别的作用就是让事务之间互相隔离，互不影响，这样可以保证事务的一致性。\n\n隔离级别比较：可串行化>可重复读>读已提交>读未提交\n\n隔离级别对性能的影响比较：可串行化>可重复读>读已提交>读未提交\n\n由此看出，隔离级别越高，所需要消耗的MySQL性能越大（如事务并发严重性），为了平衡二者，一般建议设置的隔离级别为可重复读，MySQL默认的隔离级别也是可重复读。\n\n#### 读未提交（READ UNCOMMITTED）\n\n在读未提交隔离级别下，事务A可以读取到事务B修改过但未提交的数据。\n\n可能发生脏读、不可重复读和幻读问题，一般很少使用此隔离级别。\n\n#### 读已提交（READ COMMITTED）\n\n在读已提交隔离级别下，事务B只能在事务A修改过并且已提交后才能读取到事务B修改的数据。\n\n读已提交隔离级别解决了脏读的问题，但可能发生不可重复读和幻读问题，一般很少使用此隔离级别。\n\n#### 可重复读（REPEATABLE READ）\n\n在可重复读隔离级别下，事务B只能在事务A修改过数据并提交后，自己也提交事务后，才能读取到事务B修改的数据。可重复读隔离级别解决了脏读和不可重复读的问题，但可能发生幻读问题。\n\n提问：为什么上了写锁（写操作），别的事务还可以读操作？\n\n因为InnoDB有MVCC机制（多版本并发控制），可以使用快照读，而不会被阻塞。\n\n#### 可串行化（SERIALIZABLE）\n\n各种问题（脏读、不可重复读、幻读）都不会发生，通过加锁实现（读锁和写锁）。\n\n\n\n## 隔离级别的实现原理\n\n使用MySQL的默认隔离级别（可重复读）来进行说明。\n\n每条记录在更新的时候都会同时记录一条回滚操作（回滚操作日志undo log）。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。即通过回滚（rollback操作），可以回到前一个状态的值。\n\n假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。\n\n- read-view A : 回滚段 将 2 改成 1\n- read-view B : 回滚段 将 3 改成 2\n\n- read-view C : 当前值 4 \n\nread-view A -> read-view B -> read-view C\n\n当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。\n\n同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。\n\n提问：回滚操作日志（undo log）什么时候删除？\n\nMySQL会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除。\n\n提问：什么时候不需要了？\n\n当系统里么有比这个回滚日志更早的read-view的时候。\n\n我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行**回滚**，在 MySQL 中，恢复机制是通过 **回滚日志（undo log）** 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 **回滚日志** 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。\n\n另外，MVCC 的实现依赖于：**隐藏字段、Read View、undo log**。在内部实现中，InnoDB 通过数据行的 DB_TRX_ID 和 Read View 来判断数据的可见性，如不可见，则通过数据行的 DB_ROLL_PTR 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改\n\n## 查看当前会话隔离级别\n\n#### 方式1\n\n```\n命令：SHOW VARIABLES LIKE 'transaction_isolation';\n\nmysql> show variables like 'transaction_isolation';\n+-----------------------+--------------+\n| Variable_name  | Value |\n+-----------------------+--------------+\n| transaction_isolation | SERIALIZABLE |\n+-----------------------+--------------+\n```\n\n#### 方式2\n\n```\n命令：SELECT @@transaction_isolation;\n\nmysql> select @@transaction_isolation;\n+-------------------------+\n| @@transaction_isolation |\n+-------------------------+\n| SERIALIZABLE            |\n+-------------------------+\n\nmysql> select @@global.transaction_isolation;\n+--------------------------------+\n| @@global.transaction_isolation |\n+--------------------------------+\n| READ-UNCOMMITTED               |\n+--------------------------------+\n1 row in set (0.01 sec)\n```\n\n## 设置隔离级别\n\n#### 方式1：通过set命令\n\n```\nSET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;\n其中level有4种值：\nlevel: {\n     REPEATABLE READ\n   | READ COMMITTED\n   | READ UNCOMMITTED\n   | SERIALIZABLE\n}\n```\n\n##### 关键词：GLOBAL\n\n```\nSET GLOBAL TRANSACTION ISOLATION LEVEL level;\neg: set global transaction isolation level read uncommitted;\n* 只对执行完该语句之后产生的会话起作用\n* 当前已经存在的会话无效\n```\n\n##### 关键词：SESSION\n\n```\nSET SESSION TRANSACTION ISOLATION LEVEL level;\n* 对当前会话的所有后续的事务有效\n* 该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务\n* 如果在事务之间执行，则对后续的事务有效。\n```\n\n##### 无关键词\n\n```\nSET TRANSACTION ISOLATION LEVEL level;\n* 只对当前会话中下一个即将开启的事务有效\n* 下一个事务执行完后，后续事务将恢复到之前的隔离级别\n* 该语句不能在已经开启的事务中间执行，会报错的\n```\n\n#### 方式2：通过服务启动项命令\n\n> 可以修改启动参数transaction-isolation的值\n>\n> 比方说我们在启动服务器时指定了--transaction-isolation=READ UNCOMMITTED，那么事务的默认隔离级别就从原来的REPEATABLE READ变成了READ UNCOMMITTED。\n\n\n\n## 关于事务日志\n\n关于事务日志的说明中，我们可以看得出来，只要修改的数据已经写入到日志并且持久化了，数据本身还没有写入磁盘时，即使断电了，系统在重启的时候依然会将数据恢复。那么我们再来看看官网给出的innodb_flush_log_at_trx_commit 参数的介绍\n- 为0时，如果MySQL挂了或宕机可能会有1秒数据的丢失。\n- 为1时， 只要事务提交成功，redo log记录就一定在硬盘里，不会有任何数据丢失。如果事务执行期间MySQL挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。\n- 为2时， 只要事务提交成功，redo log buffer中的内容只写入文件系统缓存（page cache）。如果仅仅只是MySQL挂了不会有任何数据丢失，但是宕机可能会有1秒数据的丢失。\n\n该属性主要是为数据库的ACID原则进行服务的，并且默认为1，但是实际情况下设置为2会提高很多的事务性能，设置1的时候，innodb的缓存会在事务提交或者每秒钟时都会进行磁盘的刷新操作，2的时候，innodb缓存会在提交事务时写入到事务日志但不会刷新磁盘，然后在每秒钟时进行磁盘刷新操作，2要比1提高很多性能，事务没有commit时，断电了，此时肯定数据是没有更新成功的，因为都还没有来得及写入事务日志，事务提交后，在写入事务日志的时候，发生断电，此时无论是参数的值是1还是2，都应该恢复不了数据了，每秒钟刷新磁盘时，发生断电，此时既然事务日志已经持久化了，那么重启后，数据是会自动恢复的。\n\n#### 刷盘时机\n\nInnoDB 存储引擎为 redo log 的刷盘策略提供了 innodb_flush_log_at_trx_commit 参数，它支持三种策略：\n\n- **0** ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作，后台线程进行刷盘\n- **1** ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）\n- **2** ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache\n\ninnodb_flush_log_at_trx_commit 参数默认为 1 ，也就是说当事务提交时会调用 fsync 对 redo log 进行刷盘\n\n另外，InnoDB 存储引擎有一个后台线程，每隔1 秒，就会把 redo log buffer 中的内容写到文件系统缓存（page cache），然后调用 fsync 刷盘。也就是说，一个没有提交事务的 redo log 记录，也可能会刷盘。因为在事务执行过程 redo log 记录是会写入redo log buffer 中，这些 redo log 记录会被后台线程刷盘。除了后台线程每秒1次的轮询操作，还有一种情况，当 redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动刷盘。\n\n\n#### 日志存储方式\n硬盘上存储的 redo log 日志文件不只一个，而是以一个日志文件组的形式出现的，每个的redo日志文件大小都是一样的。\n比如可以配置为一组4个文件，每个文件的大小是 1GB，整个 redo log 日志文件组可以记录4G的内容。\n它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，在个日志文件组中还有两个重要的属性，分别是 write pos、checkpoint\n- write pos 是当前记录的位置，一边写一边后移\n- checkpoint 是当前要擦除的位置，也是往后推移\n每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。如果 write pos 追上 checkpoint ，表示日志文件组满了，这时候不能再写入新的 redo log 记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。\n\n## 关于Autocommit\n\n当变量autocommit的值为ON时，代表自动提交开启，改为OFF则变为手动提交。在手动提交模式下，可以使用下面两种指令开启事务：\n\n\n```\nstart transaction;\nbegin;\n```\n\n结束事务的方式也有两种，事务确认提交\n```\ncommit;\nrollback;\n```\n\n```\nmysql> set @@autocommit=0;\n\nmysql> SHOW VARIABLES like '%autocommit%';\n+---------------+-------+\n| Variable_name | Value |\n+---------------+-------+\n| autocommit    | OFF   |\n+---------------+-------+\n1 row in set (0.00 sec)\n```\n\n## 悲观锁与乐观锁\n\n- **悲观锁**：悲观锁指对数据被意外修改持保守态度，依赖数据库原生支持的锁机制来保证当前事务处理的安全性，防止其他并发事务对目标数据的破坏或破坏其他并发事务数据，将在事务开始执行前或执行中申请锁定，执行完后再释放锁定。这对于长事务来讲，可能会严重影响系统的并发处理能力\n\n  ```\n  LOCK TABLES a WRITE;\n  INSERT INTO a VALUES (1,23),(2,34),(4,33);\n  INSERT INTO a VALUES (8,26),(6,29);\n  UNLOCK TABLES;\n  ```\n\n  锁定表可以加速用多个语句执行的INSERT操作，因为索引缓存区仅在所有INSERT语句完成后刷新到磁盘上一次。一般有多少INSERT语句即有多少索引缓存区刷新，如果能用一个语句插入所有的行，就不需要锁定；对于事务表，应使用BEGIN和COMMIT代替LOCK TABLES来加快插入\n\n- **乐观锁**：乐观锁相对悲观锁而言，先假想数据不会被并发操作修改，没有数据冲突，只在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则宣告失败，否则更新数据。这就要求避免使用长事务和锁机制，以免导致系统并发处理能力降低，保障系统生产效率。下面将说明使用乐观锁时的大致业务处理流程\n\n  ```\n  首 步：执行一次查询 select some_column as old_value from some_table where id = id_value (假设该值在当前业务处理过程中不会被其他并发事务修改)\n  ...\n  第n步：old_value参与中间业务处理，比如old_value被自己修改 new_value = f(old_value)。这期间可能耗时很长，但不会为持有 some_column 而申请所在的行或表锁定，因此其他并发事务可以获得该锁\n  ...\n  尾 步：执行条件更新 update some_table set some_column = new_value where id = id_value and some_column = old_value (条件更新中检查old_value是否被修改)\n  ```\n\n## 三大日志\nMySQL InnoDB 引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。MySQL数据库的数据备份、主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。\n","source":"_posts/MySql-Transaction-Isolation-Level.md","raw":"---\ntitle: MySql-Transaction-Isolation-Level\ndate: 2022-03-10 15:33:59\ntags: MySql\n---\n\n\n# 事务的4大特性ACID\n原子性（Atomicity）：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。\n一致性（Consistent）：一方面，在事务开始之前和事务结束以后，数据库的完整性没有被破坏；另一方面，写入的数据必须完全符合所有的预设规则。\n隔离性（Isolation）：不同的会话或线程，操作数据库的时候可能产生多个事务。如果同时操作一张表或同一行数据，必然产生并发或干扰操作。隔离性要求事务间对表或数据操作是透明的，互相不存在干扰的，通过这种方式保证一致性。\n持久性（Durable）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\n\n#  MySQL 事务的隔离级别\n\n\n\n## 准备环境\n\n```\n docker pull mysql\n docker run --name=mysql -it -p3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql\n docker ps -a\n docker exec -it 15084 bash\n mysql -u root -p\n mysql> create database kangpan\n mysql> use kangpan\n\n```\n\n\n\n## 准备数据\n\n```\nmysql> create table user(\n    -> id int(10) auto_increment,\n    -> name varchar(30) default null,\n    -> age tinyint(4) default null,\n    -> primary key (id)\n    -> )engine=innodb charset=utf8mb4;\n\n insert into user(id, name, age) values (1,'kangpan',31);\n\nmysql> select * from user;\n+----+---------+------+\n| id | name    | age  |\n+----+---------+------+\n|  1 | kangpan |   31 |\n+----+---------+------+\n1 row in set (0.00 sec)\n```\n\n## 事务并发可能出现的情况\n\n#### 脏读（Dirty Read）\n\n一个事务读到了另一个未提交事务修改过的数据\n\n\n\n#### 幻读（Phantom）\n\n一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。（幻读在读未提交、读已提交、可重复读隔离级别都可能会出现）\n\n\n\n#### 不可重复读（Non-Repeatable Read）\n\n一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值。（不可重复读在读未提交和读已提交隔离级别都可能会出现）\n\n\n\n#### 幻读（Phantom）\n\n一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。（幻读在读未提交、读已提交、可重复读隔离级别都可能会出现）\n\n\n\n## 事务的隔离级别\n\nMySQL的事务隔离级别一共有四个，分别是读未提交、读已提交、可重复读以及可串行化。\n\nMySQL的隔离级别的作用就是让事务之间互相隔离，互不影响，这样可以保证事务的一致性。\n\n隔离级别比较：可串行化>可重复读>读已提交>读未提交\n\n隔离级别对性能的影响比较：可串行化>可重复读>读已提交>读未提交\n\n由此看出，隔离级别越高，所需要消耗的MySQL性能越大（如事务并发严重性），为了平衡二者，一般建议设置的隔离级别为可重复读，MySQL默认的隔离级别也是可重复读。\n\n#### 读未提交（READ UNCOMMITTED）\n\n在读未提交隔离级别下，事务A可以读取到事务B修改过但未提交的数据。\n\n可能发生脏读、不可重复读和幻读问题，一般很少使用此隔离级别。\n\n#### 读已提交（READ COMMITTED）\n\n在读已提交隔离级别下，事务B只能在事务A修改过并且已提交后才能读取到事务B修改的数据。\n\n读已提交隔离级别解决了脏读的问题，但可能发生不可重复读和幻读问题，一般很少使用此隔离级别。\n\n#### 可重复读（REPEATABLE READ）\n\n在可重复读隔离级别下，事务B只能在事务A修改过数据并提交后，自己也提交事务后，才能读取到事务B修改的数据。可重复读隔离级别解决了脏读和不可重复读的问题，但可能发生幻读问题。\n\n提问：为什么上了写锁（写操作），别的事务还可以读操作？\n\n因为InnoDB有MVCC机制（多版本并发控制），可以使用快照读，而不会被阻塞。\n\n#### 可串行化（SERIALIZABLE）\n\n各种问题（脏读、不可重复读、幻读）都不会发生，通过加锁实现（读锁和写锁）。\n\n\n\n## 隔离级别的实现原理\n\n使用MySQL的默认隔离级别（可重复读）来进行说明。\n\n每条记录在更新的时候都会同时记录一条回滚操作（回滚操作日志undo log）。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。即通过回滚（rollback操作），可以回到前一个状态的值。\n\n假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。\n\n- read-view A : 回滚段 将 2 改成 1\n- read-view B : 回滚段 将 3 改成 2\n\n- read-view C : 当前值 4 \n\nread-view A -> read-view B -> read-view C\n\n当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。\n\n同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。\n\n提问：回滚操作日志（undo log）什么时候删除？\n\nMySQL会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除。\n\n提问：什么时候不需要了？\n\n当系统里么有比这个回滚日志更早的read-view的时候。\n\n我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行**回滚**，在 MySQL 中，恢复机制是通过 **回滚日志（undo log）** 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 **回滚日志** 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。\n\n另外，MVCC 的实现依赖于：**隐藏字段、Read View、undo log**。在内部实现中，InnoDB 通过数据行的 DB_TRX_ID 和 Read View 来判断数据的可见性，如不可见，则通过数据行的 DB_ROLL_PTR 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改\n\n## 查看当前会话隔离级别\n\n#### 方式1\n\n```\n命令：SHOW VARIABLES LIKE 'transaction_isolation';\n\nmysql> show variables like 'transaction_isolation';\n+-----------------------+--------------+\n| Variable_name  | Value |\n+-----------------------+--------------+\n| transaction_isolation | SERIALIZABLE |\n+-----------------------+--------------+\n```\n\n#### 方式2\n\n```\n命令：SELECT @@transaction_isolation;\n\nmysql> select @@transaction_isolation;\n+-------------------------+\n| @@transaction_isolation |\n+-------------------------+\n| SERIALIZABLE            |\n+-------------------------+\n\nmysql> select @@global.transaction_isolation;\n+--------------------------------+\n| @@global.transaction_isolation |\n+--------------------------------+\n| READ-UNCOMMITTED               |\n+--------------------------------+\n1 row in set (0.01 sec)\n```\n\n## 设置隔离级别\n\n#### 方式1：通过set命令\n\n```\nSET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;\n其中level有4种值：\nlevel: {\n     REPEATABLE READ\n   | READ COMMITTED\n   | READ UNCOMMITTED\n   | SERIALIZABLE\n}\n```\n\n##### 关键词：GLOBAL\n\n```\nSET GLOBAL TRANSACTION ISOLATION LEVEL level;\neg: set global transaction isolation level read uncommitted;\n* 只对执行完该语句之后产生的会话起作用\n* 当前已经存在的会话无效\n```\n\n##### 关键词：SESSION\n\n```\nSET SESSION TRANSACTION ISOLATION LEVEL level;\n* 对当前会话的所有后续的事务有效\n* 该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务\n* 如果在事务之间执行，则对后续的事务有效。\n```\n\n##### 无关键词\n\n```\nSET TRANSACTION ISOLATION LEVEL level;\n* 只对当前会话中下一个即将开启的事务有效\n* 下一个事务执行完后，后续事务将恢复到之前的隔离级别\n* 该语句不能在已经开启的事务中间执行，会报错的\n```\n\n#### 方式2：通过服务启动项命令\n\n> 可以修改启动参数transaction-isolation的值\n>\n> 比方说我们在启动服务器时指定了--transaction-isolation=READ UNCOMMITTED，那么事务的默认隔离级别就从原来的REPEATABLE READ变成了READ UNCOMMITTED。\n\n\n\n## 关于事务日志\n\n关于事务日志的说明中，我们可以看得出来，只要修改的数据已经写入到日志并且持久化了，数据本身还没有写入磁盘时，即使断电了，系统在重启的时候依然会将数据恢复。那么我们再来看看官网给出的innodb_flush_log_at_trx_commit 参数的介绍\n- 为0时，如果MySQL挂了或宕机可能会有1秒数据的丢失。\n- 为1时， 只要事务提交成功，redo log记录就一定在硬盘里，不会有任何数据丢失。如果事务执行期间MySQL挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。\n- 为2时， 只要事务提交成功，redo log buffer中的内容只写入文件系统缓存（page cache）。如果仅仅只是MySQL挂了不会有任何数据丢失，但是宕机可能会有1秒数据的丢失。\n\n该属性主要是为数据库的ACID原则进行服务的，并且默认为1，但是实际情况下设置为2会提高很多的事务性能，设置1的时候，innodb的缓存会在事务提交或者每秒钟时都会进行磁盘的刷新操作，2的时候，innodb缓存会在提交事务时写入到事务日志但不会刷新磁盘，然后在每秒钟时进行磁盘刷新操作，2要比1提高很多性能，事务没有commit时，断电了，此时肯定数据是没有更新成功的，因为都还没有来得及写入事务日志，事务提交后，在写入事务日志的时候，发生断电，此时无论是参数的值是1还是2，都应该恢复不了数据了，每秒钟刷新磁盘时，发生断电，此时既然事务日志已经持久化了，那么重启后，数据是会自动恢复的。\n\n#### 刷盘时机\n\nInnoDB 存储引擎为 redo log 的刷盘策略提供了 innodb_flush_log_at_trx_commit 参数，它支持三种策略：\n\n- **0** ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作，后台线程进行刷盘\n- **1** ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）\n- **2** ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache\n\ninnodb_flush_log_at_trx_commit 参数默认为 1 ，也就是说当事务提交时会调用 fsync 对 redo log 进行刷盘\n\n另外，InnoDB 存储引擎有一个后台线程，每隔1 秒，就会把 redo log buffer 中的内容写到文件系统缓存（page cache），然后调用 fsync 刷盘。也就是说，一个没有提交事务的 redo log 记录，也可能会刷盘。因为在事务执行过程 redo log 记录是会写入redo log buffer 中，这些 redo log 记录会被后台线程刷盘。除了后台线程每秒1次的轮询操作，还有一种情况，当 redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动刷盘。\n\n\n#### 日志存储方式\n硬盘上存储的 redo log 日志文件不只一个，而是以一个日志文件组的形式出现的，每个的redo日志文件大小都是一样的。\n比如可以配置为一组4个文件，每个文件的大小是 1GB，整个 redo log 日志文件组可以记录4G的内容。\n它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，在个日志文件组中还有两个重要的属性，分别是 write pos、checkpoint\n- write pos 是当前记录的位置，一边写一边后移\n- checkpoint 是当前要擦除的位置，也是往后推移\n每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。如果 write pos 追上 checkpoint ，表示日志文件组满了，这时候不能再写入新的 redo log 记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。\n\n## 关于Autocommit\n\n当变量autocommit的值为ON时，代表自动提交开启，改为OFF则变为手动提交。在手动提交模式下，可以使用下面两种指令开启事务：\n\n\n```\nstart transaction;\nbegin;\n```\n\n结束事务的方式也有两种，事务确认提交\n```\ncommit;\nrollback;\n```\n\n```\nmysql> set @@autocommit=0;\n\nmysql> SHOW VARIABLES like '%autocommit%';\n+---------------+-------+\n| Variable_name | Value |\n+---------------+-------+\n| autocommit    | OFF   |\n+---------------+-------+\n1 row in set (0.00 sec)\n```\n\n## 悲观锁与乐观锁\n\n- **悲观锁**：悲观锁指对数据被意外修改持保守态度，依赖数据库原生支持的锁机制来保证当前事务处理的安全性，防止其他并发事务对目标数据的破坏或破坏其他并发事务数据，将在事务开始执行前或执行中申请锁定，执行完后再释放锁定。这对于长事务来讲，可能会严重影响系统的并发处理能力\n\n  ```\n  LOCK TABLES a WRITE;\n  INSERT INTO a VALUES (1,23),(2,34),(4,33);\n  INSERT INTO a VALUES (8,26),(6,29);\n  UNLOCK TABLES;\n  ```\n\n  锁定表可以加速用多个语句执行的INSERT操作，因为索引缓存区仅在所有INSERT语句完成后刷新到磁盘上一次。一般有多少INSERT语句即有多少索引缓存区刷新，如果能用一个语句插入所有的行，就不需要锁定；对于事务表，应使用BEGIN和COMMIT代替LOCK TABLES来加快插入\n\n- **乐观锁**：乐观锁相对悲观锁而言，先假想数据不会被并发操作修改，没有数据冲突，只在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则宣告失败，否则更新数据。这就要求避免使用长事务和锁机制，以免导致系统并发处理能力降低，保障系统生产效率。下面将说明使用乐观锁时的大致业务处理流程\n\n  ```\n  首 步：执行一次查询 select some_column as old_value from some_table where id = id_value (假设该值在当前业务处理过程中不会被其他并发事务修改)\n  ...\n  第n步：old_value参与中间业务处理，比如old_value被自己修改 new_value = f(old_value)。这期间可能耗时很长，但不会为持有 some_column 而申请所在的行或表锁定，因此其他并发事务可以获得该锁\n  ...\n  尾 步：执行条件更新 update some_table set some_column = new_value where id = id_value and some_column = old_value (条件更新中检查old_value是否被修改)\n  ```\n\n## 三大日志\nMySQL InnoDB 引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。MySQL数据库的数据备份、主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。\n","slug":"MySql-Transaction-Isolation-Level","published":1,"updated":"2022-03-10T07:36:03.975Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0vrkoq5000610ln47othejd","content":"<h1 id=\"事务的4大特性ACID\"><a href=\"#事务的4大特性ACID\" class=\"headerlink\" title=\"事务的4大特性ACID\"></a>事务的4大特性ACID</h1><p>原子性（Atomicity）：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。<br>一致性（Consistent）：一方面，在事务开始之前和事务结束以后，数据库的完整性没有被破坏；另一方面，写入的数据必须完全符合所有的预设规则。<br>隔离性（Isolation）：不同的会话或线程，操作数据库的时候可能产生多个事务。如果同时操作一张表或同一行数据，必然产生并发或干扰操作。隔离性要求事务间对表或数据操作是透明的，互相不存在干扰的，通过这种方式保证一致性。<br>持久性（Durable）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>\n<h1 id=\"MySQL-事务的隔离级别\"><a href=\"#MySQL-事务的隔离级别\" class=\"headerlink\" title=\"MySQL 事务的隔离级别\"></a>MySQL 事务的隔离级别</h1><h2 id=\"准备环境\"><a href=\"#准备环境\" class=\"headerlink\" title=\"准备环境\"></a>准备环境</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull mysql</span><br><span class=\"line\">docker run --name=mysql -it -p3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql</span><br><span class=\"line\">docker ps -a</span><br><span class=\"line\">docker exec -it 15084 bash</span><br><span class=\"line\">mysql -u root -p</span><br><span class=\"line\">mysql&gt; create database kangpan</span><br><span class=\"line\">mysql&gt; use kangpan</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"准备数据\"><a href=\"#准备数据\" class=\"headerlink\" title=\"准备数据\"></a>准备数据</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; create table user(</span><br><span class=\"line\">    -&gt; id int(10) auto_increment,</span><br><span class=\"line\">    -&gt; name varchar(30) default null,</span><br><span class=\"line\">    -&gt; age tinyint(4) default null,</span><br><span class=\"line\">    -&gt; primary key (id)</span><br><span class=\"line\">    -&gt; )engine=innodb charset=utf8mb4;</span><br><span class=\"line\"></span><br><span class=\"line\"> insert into user(id, name, age) values (1,&#x27;kangpan&#x27;,31);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select * from user;</span><br><span class=\"line\">+----+---------+------+</span><br><span class=\"line\">| id | name    | age  |</span><br><span class=\"line\">+----+---------+------+</span><br><span class=\"line\">|  1 | kangpan |   31 |</span><br><span class=\"line\">+----+---------+------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"事务并发可能出现的情况\"><a href=\"#事务并发可能出现的情况\" class=\"headerlink\" title=\"事务并发可能出现的情况\"></a>事务并发可能出现的情况</h2><h4 id=\"脏读（Dirty-Read）\"><a href=\"#脏读（Dirty-Read）\" class=\"headerlink\" title=\"脏读（Dirty Read）\"></a>脏读（Dirty Read）</h4><p>一个事务读到了另一个未提交事务修改过的数据</p>\n<h4 id=\"幻读（Phantom）\"><a href=\"#幻读（Phantom）\" class=\"headerlink\" title=\"幻读（Phantom）\"></a>幻读（Phantom）</h4><p>一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。（幻读在读未提交、读已提交、可重复读隔离级别都可能会出现）</p>\n<h4 id=\"不可重复读（Non-Repeatable-Read）\"><a href=\"#不可重复读（Non-Repeatable-Read）\" class=\"headerlink\" title=\"不可重复读（Non-Repeatable Read）\"></a>不可重复读（Non-Repeatable Read）</h4><p>一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值。（不可重复读在读未提交和读已提交隔离级别都可能会出现）</p>\n<h4 id=\"幻读（Phantom）-1\"><a href=\"#幻读（Phantom）-1\" class=\"headerlink\" title=\"幻读（Phantom）\"></a>幻读（Phantom）</h4><p>一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。（幻读在读未提交、读已提交、可重复读隔离级别都可能会出现）</p>\n<h2 id=\"事务的隔离级别\"><a href=\"#事务的隔离级别\" class=\"headerlink\" title=\"事务的隔离级别\"></a>事务的隔离级别</h2><p>MySQL的事务隔离级别一共有四个，分别是读未提交、读已提交、可重复读以及可串行化。</p>\n<p>MySQL的隔离级别的作用就是让事务之间互相隔离，互不影响，这样可以保证事务的一致性。</p>\n<p>隔离级别比较：可串行化&gt;可重复读&gt;读已提交&gt;读未提交</p>\n<p>隔离级别对性能的影响比较：可串行化&gt;可重复读&gt;读已提交&gt;读未提交</p>\n<p>由此看出，隔离级别越高，所需要消耗的MySQL性能越大（如事务并发严重性），为了平衡二者，一般建议设置的隔离级别为可重复读，MySQL默认的隔离级别也是可重复读。</p>\n<h4 id=\"读未提交（READ-UNCOMMITTED）\"><a href=\"#读未提交（READ-UNCOMMITTED）\" class=\"headerlink\" title=\"读未提交（READ UNCOMMITTED）\"></a>读未提交（READ UNCOMMITTED）</h4><p>在读未提交隔离级别下，事务A可以读取到事务B修改过但未提交的数据。</p>\n<p>可能发生脏读、不可重复读和幻读问题，一般很少使用此隔离级别。</p>\n<h4 id=\"读已提交（READ-COMMITTED）\"><a href=\"#读已提交（READ-COMMITTED）\" class=\"headerlink\" title=\"读已提交（READ COMMITTED）\"></a>读已提交（READ COMMITTED）</h4><p>在读已提交隔离级别下，事务B只能在事务A修改过并且已提交后才能读取到事务B修改的数据。</p>\n<p>读已提交隔离级别解决了脏读的问题，但可能发生不可重复读和幻读问题，一般很少使用此隔离级别。</p>\n<h4 id=\"可重复读（REPEATABLE-READ）\"><a href=\"#可重复读（REPEATABLE-READ）\" class=\"headerlink\" title=\"可重复读（REPEATABLE READ）\"></a>可重复读（REPEATABLE READ）</h4><p>在可重复读隔离级别下，事务B只能在事务A修改过数据并提交后，自己也提交事务后，才能读取到事务B修改的数据。可重复读隔离级别解决了脏读和不可重复读的问题，但可能发生幻读问题。</p>\n<p>提问：为什么上了写锁（写操作），别的事务还可以读操作？</p>\n<p>因为InnoDB有MVCC机制（多版本并发控制），可以使用快照读，而不会被阻塞。</p>\n<h4 id=\"可串行化（SERIALIZABLE）\"><a href=\"#可串行化（SERIALIZABLE）\" class=\"headerlink\" title=\"可串行化（SERIALIZABLE）\"></a>可串行化（SERIALIZABLE）</h4><p>各种问题（脏读、不可重复读、幻读）都不会发生，通过加锁实现（读锁和写锁）。</p>\n<h2 id=\"隔离级别的实现原理\"><a href=\"#隔离级别的实现原理\" class=\"headerlink\" title=\"隔离级别的实现原理\"></a>隔离级别的实现原理</h2><p>使用MySQL的默认隔离级别（可重复读）来进行说明。</p>\n<p>每条记录在更新的时候都会同时记录一条回滚操作（回滚操作日志undo log）。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。即通过回滚（rollback操作），可以回到前一个状态的值。</p>\n<p>假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。</p>\n<ul>\n<li><p>read-view A : 回滚段 将 2 改成 1</p>\n</li>\n<li><p>read-view B : 回滚段 将 3 改成 2</p>\n</li>\n<li><p>read-view C : 当前值 4 </p>\n</li>\n</ul>\n<p>read-view A -&gt; read-view B -&gt; read-view C</p>\n<p>当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。</p>\n<p>同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。</p>\n<p>提问：回滚操作日志（undo log）什么时候删除？</p>\n<p>MySQL会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除。</p>\n<p>提问：什么时候不需要了？</p>\n<p>当系统里么有比这个回滚日志更早的read-view的时候。</p>\n<p>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p>\n<p>另外，MVCC 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，InnoDB 通过数据行的 DB_TRX_ID 和 Read View 来判断数据的可见性，如不可见，则通过数据行的 DB_ROLL_PTR 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改</p>\n<h2 id=\"查看当前会话隔离级别\"><a href=\"#查看当前会话隔离级别\" class=\"headerlink\" title=\"查看当前会话隔离级别\"></a>查看当前会话隔离级别</h2><h4 id=\"方式1\"><a href=\"#方式1\" class=\"headerlink\" title=\"方式1\"></a>方式1</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令：SHOW VARIABLES LIKE &#x27;transaction_isolation&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; show variables like &#x27;transaction_isolation&#x27;;</span><br><span class=\"line\">+-----------------------+--------------+</span><br><span class=\"line\">| Variable_name  | Value |</span><br><span class=\"line\">+-----------------------+--------------+</span><br><span class=\"line\">| transaction_isolation | SERIALIZABLE |</span><br><span class=\"line\">+-----------------------+--------------+</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方式2\"><a href=\"#方式2\" class=\"headerlink\" title=\"方式2\"></a>方式2</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令：SELECT @@transaction_isolation;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select @@transaction_isolation;</span><br><span class=\"line\">+-------------------------+</span><br><span class=\"line\">| @@transaction_isolation |</span><br><span class=\"line\">+-------------------------+</span><br><span class=\"line\">| SERIALIZABLE            |</span><br><span class=\"line\">+-------------------------+</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select @@global.transaction_isolation;</span><br><span class=\"line\">+--------------------------------+</span><br><span class=\"line\">| @@global.transaction_isolation |</span><br><span class=\"line\">+--------------------------------+</span><br><span class=\"line\">| READ-UNCOMMITTED               |</span><br><span class=\"line\">+--------------------------------+</span><br><span class=\"line\">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"设置隔离级别\"><a href=\"#设置隔离级别\" class=\"headerlink\" title=\"设置隔离级别\"></a>设置隔离级别</h2><h4 id=\"方式1：通过set命令\"><a href=\"#方式1：通过set命令\" class=\"headerlink\" title=\"方式1：通过set命令\"></a>方式1：通过set命令</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;</span><br><span class=\"line\">其中level有4种值：</span><br><span class=\"line\">level: &#123;</span><br><span class=\"line\">     REPEATABLE READ</span><br><span class=\"line\">   | READ COMMITTED</span><br><span class=\"line\">   | READ UNCOMMITTED</span><br><span class=\"line\">   | SERIALIZABLE</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"关键词：GLOBAL\"><a href=\"#关键词：GLOBAL\" class=\"headerlink\" title=\"关键词：GLOBAL\"></a>关键词：GLOBAL</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET GLOBAL TRANSACTION ISOLATION LEVEL level;</span><br><span class=\"line\">eg: set global transaction isolation level read uncommitted;</span><br><span class=\"line\">* 只对执行完该语句之后产生的会话起作用</span><br><span class=\"line\">* 当前已经存在的会话无效</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"关键词：SESSION\"><a href=\"#关键词：SESSION\" class=\"headerlink\" title=\"关键词：SESSION\"></a>关键词：SESSION</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET SESSION TRANSACTION ISOLATION LEVEL level;</span><br><span class=\"line\">* 对当前会话的所有后续的事务有效</span><br><span class=\"line\">* 该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务</span><br><span class=\"line\">* 如果在事务之间执行，则对后续的事务有效。</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"无关键词\"><a href=\"#无关键词\" class=\"headerlink\" title=\"无关键词\"></a>无关键词</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET TRANSACTION ISOLATION LEVEL level;</span><br><span class=\"line\">* 只对当前会话中下一个即将开启的事务有效</span><br><span class=\"line\">* 下一个事务执行完后，后续事务将恢复到之前的隔离级别</span><br><span class=\"line\">* 该语句不能在已经开启的事务中间执行，会报错的</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方式2：通过服务启动项命令\"><a href=\"#方式2：通过服务启动项命令\" class=\"headerlink\" title=\"方式2：通过服务启动项命令\"></a>方式2：通过服务启动项命令</h4><blockquote>\n<p>可以修改启动参数transaction-isolation的值</p>\n<p>比方说我们在启动服务器时指定了–transaction-isolation=READ UNCOMMITTED，那么事务的默认隔离级别就从原来的REPEATABLE READ变成了READ UNCOMMITTED。</p>\n</blockquote>\n<h2 id=\"关于事务日志\"><a href=\"#关于事务日志\" class=\"headerlink\" title=\"关于事务日志\"></a>关于事务日志</h2><p>关于事务日志的说明中，我们可以看得出来，只要修改的数据已经写入到日志并且持久化了，数据本身还没有写入磁盘时，即使断电了，系统在重启的时候依然会将数据恢复。那么我们再来看看官网给出的innodb_flush_log_at_trx_commit 参数的介绍</p>\n<ul>\n<li>为0时，如果MySQL挂了或宕机可能会有1秒数据的丢失。</li>\n<li>为1时， 只要事务提交成功，redo log记录就一定在硬盘里，不会有任何数据丢失。如果事务执行期间MySQL挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。</li>\n<li>为2时， 只要事务提交成功，redo log buffer中的内容只写入文件系统缓存（page cache）。如果仅仅只是MySQL挂了不会有任何数据丢失，但是宕机可能会有1秒数据的丢失。</li>\n</ul>\n<p>该属性主要是为数据库的ACID原则进行服务的，并且默认为1，但是实际情况下设置为2会提高很多的事务性能，设置1的时候，innodb的缓存会在事务提交或者每秒钟时都会进行磁盘的刷新操作，2的时候，innodb缓存会在提交事务时写入到事务日志但不会刷新磁盘，然后在每秒钟时进行磁盘刷新操作，2要比1提高很多性能，事务没有commit时，断电了，此时肯定数据是没有更新成功的，因为都还没有来得及写入事务日志，事务提交后，在写入事务日志的时候，发生断电，此时无论是参数的值是1还是2，都应该恢复不了数据了，每秒钟刷新磁盘时，发生断电，此时既然事务日志已经持久化了，那么重启后，数据是会自动恢复的。</p>\n<h4 id=\"刷盘时机\"><a href=\"#刷盘时机\" class=\"headerlink\" title=\"刷盘时机\"></a>刷盘时机</h4><p>InnoDB 存储引擎为 redo log 的刷盘策略提供了 innodb_flush_log_at_trx_commit 参数，它支持三种策略：</p>\n<ul>\n<li><strong>0</strong> ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作，后台线程进行刷盘</li>\n<li><strong>1</strong> ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）</li>\n<li><strong>2</strong> ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache</li>\n</ul>\n<p>innodb_flush_log_at_trx_commit 参数默认为 1 ，也就是说当事务提交时会调用 fsync 对 redo log 进行刷盘</p>\n<p>另外，InnoDB 存储引擎有一个后台线程，每隔1 秒，就会把 redo log buffer 中的内容写到文件系统缓存（page cache），然后调用 fsync 刷盘。也就是说，一个没有提交事务的 redo log 记录，也可能会刷盘。因为在事务执行过程 redo log 记录是会写入redo log buffer 中，这些 redo log 记录会被后台线程刷盘。除了后台线程每秒1次的轮询操作，还有一种情况，当 redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动刷盘。</p>\n<h4 id=\"日志存储方式\"><a href=\"#日志存储方式\" class=\"headerlink\" title=\"日志存储方式\"></a>日志存储方式</h4><p>硬盘上存储的 redo log 日志文件不只一个，而是以一个日志文件组的形式出现的，每个的redo日志文件大小都是一样的。<br>比如可以配置为一组4个文件，每个文件的大小是 1GB，整个 redo log 日志文件组可以记录4G的内容。<br>它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，在个日志文件组中还有两个重要的属性，分别是 write pos、checkpoint</p>\n<ul>\n<li>write pos 是当前记录的位置，一边写一边后移</li>\n<li>checkpoint 是当前要擦除的位置，也是往后推移<br>每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。如果 write pos 追上 checkpoint ，表示日志文件组满了，这时候不能再写入新的 redo log 记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。</li>\n</ul>\n<h2 id=\"关于Autocommit\"><a href=\"#关于Autocommit\" class=\"headerlink\" title=\"关于Autocommit\"></a>关于Autocommit</h2><p>当变量autocommit的值为ON时，代表自动提交开启，改为OFF则变为手动提交。在手动提交模式下，可以使用下面两种指令开启事务：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start transaction;</span><br><span class=\"line\">begin;</span><br></pre></td></tr></table></figure>\n\n<p>结束事务的方式也有两种，事务确认提交</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">commit;</span><br><span class=\"line\">rollback;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; set @@autocommit=0;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; SHOW VARIABLES like &#x27;%autocommit%&#x27;;</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| Variable_name | Value |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| autocommit    | OFF   |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"悲观锁与乐观锁\"><a href=\"#悲观锁与乐观锁\" class=\"headerlink\" title=\"悲观锁与乐观锁\"></a>悲观锁与乐观锁</h2><ul>\n<li><p><strong>悲观锁</strong>：悲观锁指对数据被意外修改持保守态度，依赖数据库原生支持的锁机制来保证当前事务处理的安全性，防止其他并发事务对目标数据的破坏或破坏其他并发事务数据，将在事务开始执行前或执行中申请锁定，执行完后再释放锁定。这对于长事务来讲，可能会严重影响系统的并发处理能力</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LOCK TABLES a WRITE;</span><br><span class=\"line\">INSERT INTO a VALUES (1,23),(2,34),(4,33);</span><br><span class=\"line\">INSERT INTO a VALUES (8,26),(6,29);</span><br><span class=\"line\">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>\n\n<p>锁定表可以加速用多个语句执行的INSERT操作，因为索引缓存区仅在所有INSERT语句完成后刷新到磁盘上一次。一般有多少INSERT语句即有多少索引缓存区刷新，如果能用一个语句插入所有的行，就不需要锁定；对于事务表，应使用BEGIN和COMMIT代替LOCK TABLES来加快插入</p>\n</li>\n<li><p><strong>乐观锁</strong>：乐观锁相对悲观锁而言，先假想数据不会被并发操作修改，没有数据冲突，只在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则宣告失败，否则更新数据。这就要求避免使用长事务和锁机制，以免导致系统并发处理能力降低，保障系统生产效率。下面将说明使用乐观锁时的大致业务处理流程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">首 步：执行一次查询 select some_column as old_value from some_table where id = id_value (假设该值在当前业务处理过程中不会被其他并发事务修改)</span><br><span class=\"line\">...</span><br><span class=\"line\">第n步：old_value参与中间业务处理，比如old_value被自己修改 new_value = f(old_value)。这期间可能耗时很长，但不会为持有 some_column 而申请所在的行或表锁定，因此其他并发事务可以获得该锁</span><br><span class=\"line\">...</span><br><span class=\"line\">尾 步：执行条件更新 update some_table set some_column = new_value where id = id_value and some_column = old_value (条件更新中检查old_value是否被修改)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"三大日志\"><a href=\"#三大日志\" class=\"headerlink\" title=\"三大日志\"></a>三大日志</h2><p>MySQL InnoDB 引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。MySQL数据库的数据备份、主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"事务的4大特性ACID\"><a href=\"#事务的4大特性ACID\" class=\"headerlink\" title=\"事务的4大特性ACID\"></a>事务的4大特性ACID</h1><p>原子性（Atomicity）：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。<br>一致性（Consistent）：一方面，在事务开始之前和事务结束以后，数据库的完整性没有被破坏；另一方面，写入的数据必须完全符合所有的预设规则。<br>隔离性（Isolation）：不同的会话或线程，操作数据库的时候可能产生多个事务。如果同时操作一张表或同一行数据，必然产生并发或干扰操作。隔离性要求事务间对表或数据操作是透明的，互相不存在干扰的，通过这种方式保证一致性。<br>持久性（Durable）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>\n<h1 id=\"MySQL-事务的隔离级别\"><a href=\"#MySQL-事务的隔离级别\" class=\"headerlink\" title=\"MySQL 事务的隔离级别\"></a>MySQL 事务的隔离级别</h1><h2 id=\"准备环境\"><a href=\"#准备环境\" class=\"headerlink\" title=\"准备环境\"></a>准备环境</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull mysql</span><br><span class=\"line\">docker run --name=mysql -it -p3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql</span><br><span class=\"line\">docker ps -a</span><br><span class=\"line\">docker exec -it 15084 bash</span><br><span class=\"line\">mysql -u root -p</span><br><span class=\"line\">mysql&gt; create database kangpan</span><br><span class=\"line\">mysql&gt; use kangpan</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"准备数据\"><a href=\"#准备数据\" class=\"headerlink\" title=\"准备数据\"></a>准备数据</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; create table user(</span><br><span class=\"line\">    -&gt; id int(10) auto_increment,</span><br><span class=\"line\">    -&gt; name varchar(30) default null,</span><br><span class=\"line\">    -&gt; age tinyint(4) default null,</span><br><span class=\"line\">    -&gt; primary key (id)</span><br><span class=\"line\">    -&gt; )engine=innodb charset=utf8mb4;</span><br><span class=\"line\"></span><br><span class=\"line\"> insert into user(id, name, age) values (1,&#x27;kangpan&#x27;,31);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select * from user;</span><br><span class=\"line\">+----+---------+------+</span><br><span class=\"line\">| id | name    | age  |</span><br><span class=\"line\">+----+---------+------+</span><br><span class=\"line\">|  1 | kangpan |   31 |</span><br><span class=\"line\">+----+---------+------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"事务并发可能出现的情况\"><a href=\"#事务并发可能出现的情况\" class=\"headerlink\" title=\"事务并发可能出现的情况\"></a>事务并发可能出现的情况</h2><h4 id=\"脏读（Dirty-Read）\"><a href=\"#脏读（Dirty-Read）\" class=\"headerlink\" title=\"脏读（Dirty Read）\"></a>脏读（Dirty Read）</h4><p>一个事务读到了另一个未提交事务修改过的数据</p>\n<h4 id=\"幻读（Phantom）\"><a href=\"#幻读（Phantom）\" class=\"headerlink\" title=\"幻读（Phantom）\"></a>幻读（Phantom）</h4><p>一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。（幻读在读未提交、读已提交、可重复读隔离级别都可能会出现）</p>\n<h4 id=\"不可重复读（Non-Repeatable-Read）\"><a href=\"#不可重复读（Non-Repeatable-Read）\" class=\"headerlink\" title=\"不可重复读（Non-Repeatable Read）\"></a>不可重复读（Non-Repeatable Read）</h4><p>一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值。（不可重复读在读未提交和读已提交隔离级别都可能会出现）</p>\n<h4 id=\"幻读（Phantom）-1\"><a href=\"#幻读（Phantom）-1\" class=\"headerlink\" title=\"幻读（Phantom）\"></a>幻读（Phantom）</h4><p>一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。（幻读在读未提交、读已提交、可重复读隔离级别都可能会出现）</p>\n<h2 id=\"事务的隔离级别\"><a href=\"#事务的隔离级别\" class=\"headerlink\" title=\"事务的隔离级别\"></a>事务的隔离级别</h2><p>MySQL的事务隔离级别一共有四个，分别是读未提交、读已提交、可重复读以及可串行化。</p>\n<p>MySQL的隔离级别的作用就是让事务之间互相隔离，互不影响，这样可以保证事务的一致性。</p>\n<p>隔离级别比较：可串行化&gt;可重复读&gt;读已提交&gt;读未提交</p>\n<p>隔离级别对性能的影响比较：可串行化&gt;可重复读&gt;读已提交&gt;读未提交</p>\n<p>由此看出，隔离级别越高，所需要消耗的MySQL性能越大（如事务并发严重性），为了平衡二者，一般建议设置的隔离级别为可重复读，MySQL默认的隔离级别也是可重复读。</p>\n<h4 id=\"读未提交（READ-UNCOMMITTED）\"><a href=\"#读未提交（READ-UNCOMMITTED）\" class=\"headerlink\" title=\"读未提交（READ UNCOMMITTED）\"></a>读未提交（READ UNCOMMITTED）</h4><p>在读未提交隔离级别下，事务A可以读取到事务B修改过但未提交的数据。</p>\n<p>可能发生脏读、不可重复读和幻读问题，一般很少使用此隔离级别。</p>\n<h4 id=\"读已提交（READ-COMMITTED）\"><a href=\"#读已提交（READ-COMMITTED）\" class=\"headerlink\" title=\"读已提交（READ COMMITTED）\"></a>读已提交（READ COMMITTED）</h4><p>在读已提交隔离级别下，事务B只能在事务A修改过并且已提交后才能读取到事务B修改的数据。</p>\n<p>读已提交隔离级别解决了脏读的问题，但可能发生不可重复读和幻读问题，一般很少使用此隔离级别。</p>\n<h4 id=\"可重复读（REPEATABLE-READ）\"><a href=\"#可重复读（REPEATABLE-READ）\" class=\"headerlink\" title=\"可重复读（REPEATABLE READ）\"></a>可重复读（REPEATABLE READ）</h4><p>在可重复读隔离级别下，事务B只能在事务A修改过数据并提交后，自己也提交事务后，才能读取到事务B修改的数据。可重复读隔离级别解决了脏读和不可重复读的问题，但可能发生幻读问题。</p>\n<p>提问：为什么上了写锁（写操作），别的事务还可以读操作？</p>\n<p>因为InnoDB有MVCC机制（多版本并发控制），可以使用快照读，而不会被阻塞。</p>\n<h4 id=\"可串行化（SERIALIZABLE）\"><a href=\"#可串行化（SERIALIZABLE）\" class=\"headerlink\" title=\"可串行化（SERIALIZABLE）\"></a>可串行化（SERIALIZABLE）</h4><p>各种问题（脏读、不可重复读、幻读）都不会发生，通过加锁实现（读锁和写锁）。</p>\n<h2 id=\"隔离级别的实现原理\"><a href=\"#隔离级别的实现原理\" class=\"headerlink\" title=\"隔离级别的实现原理\"></a>隔离级别的实现原理</h2><p>使用MySQL的默认隔离级别（可重复读）来进行说明。</p>\n<p>每条记录在更新的时候都会同时记录一条回滚操作（回滚操作日志undo log）。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。即通过回滚（rollback操作），可以回到前一个状态的值。</p>\n<p>假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。</p>\n<ul>\n<li><p>read-view A : 回滚段 将 2 改成 1</p>\n</li>\n<li><p>read-view B : 回滚段 将 3 改成 2</p>\n</li>\n<li><p>read-view C : 当前值 4 </p>\n</li>\n</ul>\n<p>read-view A -&gt; read-view B -&gt; read-view C</p>\n<p>当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。</p>\n<p>同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。</p>\n<p>提问：回滚操作日志（undo log）什么时候删除？</p>\n<p>MySQL会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除。</p>\n<p>提问：什么时候不需要了？</p>\n<p>当系统里么有比这个回滚日志更早的read-view的时候。</p>\n<p>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p>\n<p>另外，MVCC 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，InnoDB 通过数据行的 DB_TRX_ID 和 Read View 来判断数据的可见性，如不可见，则通过数据行的 DB_ROLL_PTR 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改</p>\n<h2 id=\"查看当前会话隔离级别\"><a href=\"#查看当前会话隔离级别\" class=\"headerlink\" title=\"查看当前会话隔离级别\"></a>查看当前会话隔离级别</h2><h4 id=\"方式1\"><a href=\"#方式1\" class=\"headerlink\" title=\"方式1\"></a>方式1</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令：SHOW VARIABLES LIKE &#x27;transaction_isolation&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; show variables like &#x27;transaction_isolation&#x27;;</span><br><span class=\"line\">+-----------------------+--------------+</span><br><span class=\"line\">| Variable_name  | Value |</span><br><span class=\"line\">+-----------------------+--------------+</span><br><span class=\"line\">| transaction_isolation | SERIALIZABLE |</span><br><span class=\"line\">+-----------------------+--------------+</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方式2\"><a href=\"#方式2\" class=\"headerlink\" title=\"方式2\"></a>方式2</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令：SELECT @@transaction_isolation;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select @@transaction_isolation;</span><br><span class=\"line\">+-------------------------+</span><br><span class=\"line\">| @@transaction_isolation |</span><br><span class=\"line\">+-------------------------+</span><br><span class=\"line\">| SERIALIZABLE            |</span><br><span class=\"line\">+-------------------------+</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select @@global.transaction_isolation;</span><br><span class=\"line\">+--------------------------------+</span><br><span class=\"line\">| @@global.transaction_isolation |</span><br><span class=\"line\">+--------------------------------+</span><br><span class=\"line\">| READ-UNCOMMITTED               |</span><br><span class=\"line\">+--------------------------------+</span><br><span class=\"line\">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"设置隔离级别\"><a href=\"#设置隔离级别\" class=\"headerlink\" title=\"设置隔离级别\"></a>设置隔离级别</h2><h4 id=\"方式1：通过set命令\"><a href=\"#方式1：通过set命令\" class=\"headerlink\" title=\"方式1：通过set命令\"></a>方式1：通过set命令</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;</span><br><span class=\"line\">其中level有4种值：</span><br><span class=\"line\">level: &#123;</span><br><span class=\"line\">     REPEATABLE READ</span><br><span class=\"line\">   | READ COMMITTED</span><br><span class=\"line\">   | READ UNCOMMITTED</span><br><span class=\"line\">   | SERIALIZABLE</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"关键词：GLOBAL\"><a href=\"#关键词：GLOBAL\" class=\"headerlink\" title=\"关键词：GLOBAL\"></a>关键词：GLOBAL</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET GLOBAL TRANSACTION ISOLATION LEVEL level;</span><br><span class=\"line\">eg: set global transaction isolation level read uncommitted;</span><br><span class=\"line\">* 只对执行完该语句之后产生的会话起作用</span><br><span class=\"line\">* 当前已经存在的会话无效</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"关键词：SESSION\"><a href=\"#关键词：SESSION\" class=\"headerlink\" title=\"关键词：SESSION\"></a>关键词：SESSION</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET SESSION TRANSACTION ISOLATION LEVEL level;</span><br><span class=\"line\">* 对当前会话的所有后续的事务有效</span><br><span class=\"line\">* 该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务</span><br><span class=\"line\">* 如果在事务之间执行，则对后续的事务有效。</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"无关键词\"><a href=\"#无关键词\" class=\"headerlink\" title=\"无关键词\"></a>无关键词</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET TRANSACTION ISOLATION LEVEL level;</span><br><span class=\"line\">* 只对当前会话中下一个即将开启的事务有效</span><br><span class=\"line\">* 下一个事务执行完后，后续事务将恢复到之前的隔离级别</span><br><span class=\"line\">* 该语句不能在已经开启的事务中间执行，会报错的</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方式2：通过服务启动项命令\"><a href=\"#方式2：通过服务启动项命令\" class=\"headerlink\" title=\"方式2：通过服务启动项命令\"></a>方式2：通过服务启动项命令</h4><blockquote>\n<p>可以修改启动参数transaction-isolation的值</p>\n<p>比方说我们在启动服务器时指定了–transaction-isolation=READ UNCOMMITTED，那么事务的默认隔离级别就从原来的REPEATABLE READ变成了READ UNCOMMITTED。</p>\n</blockquote>\n<h2 id=\"关于事务日志\"><a href=\"#关于事务日志\" class=\"headerlink\" title=\"关于事务日志\"></a>关于事务日志</h2><p>关于事务日志的说明中，我们可以看得出来，只要修改的数据已经写入到日志并且持久化了，数据本身还没有写入磁盘时，即使断电了，系统在重启的时候依然会将数据恢复。那么我们再来看看官网给出的innodb_flush_log_at_trx_commit 参数的介绍</p>\n<ul>\n<li>为0时，如果MySQL挂了或宕机可能会有1秒数据的丢失。</li>\n<li>为1时， 只要事务提交成功，redo log记录就一定在硬盘里，不会有任何数据丢失。如果事务执行期间MySQL挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。</li>\n<li>为2时， 只要事务提交成功，redo log buffer中的内容只写入文件系统缓存（page cache）。如果仅仅只是MySQL挂了不会有任何数据丢失，但是宕机可能会有1秒数据的丢失。</li>\n</ul>\n<p>该属性主要是为数据库的ACID原则进行服务的，并且默认为1，但是实际情况下设置为2会提高很多的事务性能，设置1的时候，innodb的缓存会在事务提交或者每秒钟时都会进行磁盘的刷新操作，2的时候，innodb缓存会在提交事务时写入到事务日志但不会刷新磁盘，然后在每秒钟时进行磁盘刷新操作，2要比1提高很多性能，事务没有commit时，断电了，此时肯定数据是没有更新成功的，因为都还没有来得及写入事务日志，事务提交后，在写入事务日志的时候，发生断电，此时无论是参数的值是1还是2，都应该恢复不了数据了，每秒钟刷新磁盘时，发生断电，此时既然事务日志已经持久化了，那么重启后，数据是会自动恢复的。</p>\n<h4 id=\"刷盘时机\"><a href=\"#刷盘时机\" class=\"headerlink\" title=\"刷盘时机\"></a>刷盘时机</h4><p>InnoDB 存储引擎为 redo log 的刷盘策略提供了 innodb_flush_log_at_trx_commit 参数，它支持三种策略：</p>\n<ul>\n<li><strong>0</strong> ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作，后台线程进行刷盘</li>\n<li><strong>1</strong> ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）</li>\n<li><strong>2</strong> ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache</li>\n</ul>\n<p>innodb_flush_log_at_trx_commit 参数默认为 1 ，也就是说当事务提交时会调用 fsync 对 redo log 进行刷盘</p>\n<p>另外，InnoDB 存储引擎有一个后台线程，每隔1 秒，就会把 redo log buffer 中的内容写到文件系统缓存（page cache），然后调用 fsync 刷盘。也就是说，一个没有提交事务的 redo log 记录，也可能会刷盘。因为在事务执行过程 redo log 记录是会写入redo log buffer 中，这些 redo log 记录会被后台线程刷盘。除了后台线程每秒1次的轮询操作，还有一种情况，当 redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动刷盘。</p>\n<h4 id=\"日志存储方式\"><a href=\"#日志存储方式\" class=\"headerlink\" title=\"日志存储方式\"></a>日志存储方式</h4><p>硬盘上存储的 redo log 日志文件不只一个，而是以一个日志文件组的形式出现的，每个的redo日志文件大小都是一样的。<br>比如可以配置为一组4个文件，每个文件的大小是 1GB，整个 redo log 日志文件组可以记录4G的内容。<br>它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，在个日志文件组中还有两个重要的属性，分别是 write pos、checkpoint</p>\n<ul>\n<li>write pos 是当前记录的位置，一边写一边后移</li>\n<li>checkpoint 是当前要擦除的位置，也是往后推移<br>每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。如果 write pos 追上 checkpoint ，表示日志文件组满了，这时候不能再写入新的 redo log 记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。</li>\n</ul>\n<h2 id=\"关于Autocommit\"><a href=\"#关于Autocommit\" class=\"headerlink\" title=\"关于Autocommit\"></a>关于Autocommit</h2><p>当变量autocommit的值为ON时，代表自动提交开启，改为OFF则变为手动提交。在手动提交模式下，可以使用下面两种指令开启事务：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start transaction;</span><br><span class=\"line\">begin;</span><br></pre></td></tr></table></figure>\n\n<p>结束事务的方式也有两种，事务确认提交</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">commit;</span><br><span class=\"line\">rollback;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; set @@autocommit=0;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; SHOW VARIABLES like &#x27;%autocommit%&#x27;;</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| Variable_name | Value |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| autocommit    | OFF   |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"悲观锁与乐观锁\"><a href=\"#悲观锁与乐观锁\" class=\"headerlink\" title=\"悲观锁与乐观锁\"></a>悲观锁与乐观锁</h2><ul>\n<li><p><strong>悲观锁</strong>：悲观锁指对数据被意外修改持保守态度，依赖数据库原生支持的锁机制来保证当前事务处理的安全性，防止其他并发事务对目标数据的破坏或破坏其他并发事务数据，将在事务开始执行前或执行中申请锁定，执行完后再释放锁定。这对于长事务来讲，可能会严重影响系统的并发处理能力</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LOCK TABLES a WRITE;</span><br><span class=\"line\">INSERT INTO a VALUES (1,23),(2,34),(4,33);</span><br><span class=\"line\">INSERT INTO a VALUES (8,26),(6,29);</span><br><span class=\"line\">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>\n\n<p>锁定表可以加速用多个语句执行的INSERT操作，因为索引缓存区仅在所有INSERT语句完成后刷新到磁盘上一次。一般有多少INSERT语句即有多少索引缓存区刷新，如果能用一个语句插入所有的行，就不需要锁定；对于事务表，应使用BEGIN和COMMIT代替LOCK TABLES来加快插入</p>\n</li>\n<li><p><strong>乐观锁</strong>：乐观锁相对悲观锁而言，先假想数据不会被并发操作修改，没有数据冲突，只在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则宣告失败，否则更新数据。这就要求避免使用长事务和锁机制，以免导致系统并发处理能力降低，保障系统生产效率。下面将说明使用乐观锁时的大致业务处理流程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">首 步：执行一次查询 select some_column as old_value from some_table where id = id_value (假设该值在当前业务处理过程中不会被其他并发事务修改)</span><br><span class=\"line\">...</span><br><span class=\"line\">第n步：old_value参与中间业务处理，比如old_value被自己修改 new_value = f(old_value)。这期间可能耗时很长，但不会为持有 some_column 而申请所在的行或表锁定，因此其他并发事务可以获得该锁</span><br><span class=\"line\">...</span><br><span class=\"line\">尾 步：执行条件更新 update some_table set some_column = new_value where id = id_value and some_column = old_value (条件更新中检查old_value是否被修改)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"三大日志\"><a href=\"#三大日志\" class=\"headerlink\" title=\"三大日志\"></a>三大日志</h2><p>MySQL InnoDB 引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。MySQL数据库的数据备份、主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。</p>\n"},{"title":"MyBatis-Plugin-Development","date":"2022-03-10T06:59:54.000Z","_content":"\n\n\n## MyBatis插件开发流程\n\n- 类实现Interceptor接口；\n\n- 类上添加注解\n\n  ```\n  @Intercepts({@Signature(type, method, args)})\n  ```\n\n  - **type**：需要拦截的对象，只可取四大对象之一Executor.class、StatementHandler.class、ParameterHandler.class、ResultSetHandler.class。\n  - **method**：拦截的对象方法。\n  - **args**：拦截的对象方法参数。\n\n- 实现拦截的方法Object intercept(Invocation invocation)。\n\n##  Interceptor接口\n\n```\npublic interface Interceptor {\n\n    /**\n     * 此方法将直接覆盖被拦截对象的原有方法\n     *\n     * @param invocation 通过该对象可以反射调度拦截对象的方法\n     * @return\n     * @throws Throwable\n     */\n    Object intercept(Invocation invocation) throws Throwable;\n\n    /**\n     * 为被拦截对象生成一个代理对象，并返回它\n     *\n     * @param target 被拦截的对象\n     * @return\n     */\n    Object plugin(Object target);\n\n    /**\n     * 设置插件配置的参数\n     *\n     * @param properties 插件配置的参数\n     */\n    void setProperties(Properties properties);\n\n}\n```\n\n## 步骤\n\n### 确定拦截的方法签名\n\n需要在实现Interceptor接口的类上加入@Intercepts({@Signature(type, method, args)})注解才能够运行插件。\n\n#### type－拦截的对象\n\n- Executor 执行的SQL 全过程，包括组装参数、组装结果返回和执行SQL的过程等都可以拦截。\n- StatementHandler 执行SQL的过程，拦截该对象可以重写执行SQL的过程。\n- ParameterHandler 执行SQL 的参数组装，拦截该对象可以重写组装参数的规则。\n- ResultSetHandler 执行结果的组装，拦截该对象可以重写组装结果的规则。\n\n对于分页插件，我们只需要拦截StatementHandler对象，重写SELECT类型的SQL语句，实现分页功能。\n\n\n\n#### method－拦截的方法\n\n我们已经能够确定拦截的对象是StatementHandler了，现在我们要确定拦截的是哪个方法，因为StatementHandler是通过prepare方法对SQL进行预编译的，所以我们需要对prepare方法进行拦截，在这个方法执行之前，完成SQL的重新编写，加入limit。\n\n**StatementHandler**\n\n```\npublic interface StatementHandler {\n\n  /**\n   * 预编译SQL\n   *\n   * @param connection\n   * @return\n   * @throws SQLException\n   */\n  Statement prepare(Connection connection)\n      throws SQLException;\n\n  /**\n   * 设置参数\n   *\n   * @param statement\n   * @throws SQLException\n   */\n  void parameterize(Statement statement)\n      throws SQLException;\n\n  /**\n   * 批处理\n   *\n   * @param statement\n   * @throws SQLException\n   */\n  void batch(Statement statement)\n      throws SQLException;\n\n  /**\n   * 执行更新操作\n   *\n   * @param statement\n   * @return 返回影响行数\n   * @throws SQLException\n   */\n  int update(Statement statement)\n      throws SQLException;\n\n  /**\n   * 执行查询操作，将结果交给ResultHandler进行结果的组装\n   *\n   * @param statement\n   * @param resultHandler\n   * @param <E>\n   * @return 返回查询的数据列表\n   * @throws SQLException\n   */\n  <E> List<E> query(Statement statement, ResultHandler resultHandler)\n      throws SQLException;\n\n  /**\n   * 得到绑定的sql\n   * \n   * @return\n   */\n  BoundSql getBoundSql();\n\n  /**\n   * 得到参数处理器\n   * \n   * @return\n   */\n  ParameterHandler getParameterHandler();\n\n}\n```\n\n#### args－拦截的参数\n\nargs是一个Class类型的数组，表示的是被拦截方法的参数列表。由于我们已经确定了拦截的是StatementHandler的prepare方法，而该方法只有一个参数Connection，所以我们只需要拦截这一个参数即可。\n\n### 实现拦截方法\n\n定义一个封装分页参数的类Page\n\n```\npublic class Page {\n\n    /**\n     * 当前页码\n     */\n    private Integer pageIndex;\n    /**\n     * 每页数据条数\n     */\n    private Integer pageSize;\n    /**\n     * 总数据数\n     */\n    private Integer total;\n    /**\n     * 总页数\n     */\n    private Integer totalPage;\n\n    public Page() {\n    }\n\n    public Page(Integer pageIndex, Integer pageSize) {\n        this.pageIndex = pageIndex;\n        this.pageSize = pageSize;\n    }\n\t// 省略get、set方法...\n}\n```\n\n实现插件分页的功能\n\n```\nimport org.apache.ibatis.executor.parameter.ParameterHandler;\nimport org.apache.ibatis.executor.statement.StatementHandler;\nimport org.apache.ibatis.mapping.BoundSql;\nimport org.apache.ibatis.mapping.MappedStatement;\nimport org.apache.ibatis.plugin.*;\nimport org.apache.ibatis.reflection.MetaObject;\nimport org.apache.ibatis.reflection.SystemMetaObject;\nimport org.apache.ibatis.scripting.defaults.DefaultParameterHandler;\nimport org.apache.ibatis.session.Configuration;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\n\n@Intercepts({@Signature(\n        type = StatementHandler.class,\n        method = \"prepare\",\n        args = {Connection.class}\n)})\npublic class PagingPlugin implements Interceptor {\n\n    /**\n     * 默认页码\n     */\n    private Integer defaultPageIndex;\n    /**\n     * 默认每页数据条数\n     */\n    private Integer defaultPageSize;\n\n    public Object intercept(Invocation invocation) throws Throwable {\n        StatementHandler statementHandler = getUnProxyObject(invocation);\n        MetaObject metaObject = SystemMetaObject.forObject(statementHandler);\n        String sql = getSql(metaObject);\n        if (!checkSelect(sql)) {\n            // 不是select语句，进入责任链下一层\n            return invocation.proceed();\n        }\n\n        BoundSql boundSql = (BoundSql) metaObject.getValue(\"delegate.boundSql\");\n        Object parameterObject = boundSql.getParameterObject();\n        Page page = getPage(parameterObject);\n        if (page == null) {\n            // 没有传入page对象，不执行分页处理，进入责任链下一层\n            return invocation.proceed();\n        }\n\n        // 设置分页默认值\n        if (page.getPageIndex() == null) {\n            page.setPageIndex(this.defaultPageIndex);\n        }\n        if (page.getPageSize() == null) {\n            page.setPageSize(this.defaultPageSize);\n        }\n        // 设置分页总数，数据总数\n        setTotalToPage(page, invocation, metaObject, boundSql);\n        // 校验分页参数\n        checkPage(page);\n        return changeSql(invocation, metaObject, boundSql, page);\n    }\n\n    public Object plugin(Object target) {\n        // 生成代理对象\n        return Plugin.wrap(target, this);\n    }\n\n    public void setProperties(Properties properties) {\n        // 初始化配置的默认页码，无配置则默认1\n        this.defaultPageIndex = Integer.parseInt(properties.getProperty(\"default.pageIndex\", \"1\"));\n        // 初始化配置的默认数据条数，无配置则默认20\n        this.defaultPageSize = Integer.parseInt(properties.getProperty(\"default.pageSize\", \"20\"));\n    }\n\n    /**\n     * 从代理对象中分离出真实对象\n     *\n     * @param invocation\n     * @return\n     */\n    private StatementHandler getUnProxyObject(Invocation invocation) {\n        // 取出被拦截的对象\n        StatementHandler statementHandler = (StatementHandler) invocation.getTarget();\n        MetaObject metaStmtHandler = SystemMetaObject.forObject(statementHandler);\n        Object object = null;\n        // 分离代理对象\n        while (metaStmtHandler.hasGetter(\"h\")) {\n            object = metaStmtHandler.getValue(\"h\");\n            metaStmtHandler = SystemMetaObject.forObject(object);\n        }\n\n        return object == null ? statementHandler : (StatementHandler) object;\n    }\n\n    /**\n     * 判断是否是select语句\n     *\n     * @param sql\n     * @return\n     */\n    private boolean checkSelect(String sql) {\n        // 去除sql的前后空格，并将sql转换成小写\n        sql = sql.trim().toLowerCase();\n        return sql.indexOf(\"select\") == 0;\n    }\n\n    /**\n     * 获取分页参数\n     *\n     * @param parameterObject\n     * @return\n     */\n    private Page getPage(Object parameterObject) {\n        if (parameterObject == null) {\n            return null;\n        }\n\n        if (parameterObject instanceof Map) {\n            // 如果传入的参数是map类型的，则遍历map取出Page对象\n            Map<String, Object> parameMap = (Map<String, Object>) parameterObject;\n            Set<String> keySet = parameMap.keySet();\n            for (String key : keySet) {\n                Object value = parameMap.get(key);\n                if (value instanceof Page) {\n                    // 返回Page对象\n                    return (Page) value;\n                }\n            }\n        } else if (parameterObject instanceof Page) {\n            // 如果传入的是Page类型，则直接返回该对象\n            return (Page) parameterObject;\n        }\n\n        // 初步判断并没有传入Page类型的参数，返回null\n        return null;\n    }\n\n    /**\n     * 获取数据总数\n     *\n     * @param invocation\n     * @param metaObject\n     * @param boundSql\n     * @return\n     */\n    private int getTotal(Invocation invocation, MetaObject metaObject, BoundSql boundSql) {\n        // 获取当前的mappedStatement对象\n        MappedStatement mappedStatement = (MappedStatement) metaObject.getValue(\"delegate.mappedStatement\");\n        // 获取配置对象\n        Configuration configuration = mappedStatement.getConfiguration();\n        // 获取当前需要执行的sql\n        String sql = getSql(metaObject);\n        // 改写sql语句，实现返回数据总数 $_paging取名是为了防止数据库表重名\n        String countSql = \"select count(*) as total from (\" + sql + \") $_paging\";\n        // 获取拦截方法参数，拦截的是connection对象\n        Connection connection = (Connection) invocation.getArgs()[0];\n        PreparedStatement pstmt = null;\n        int total = 0;\n\n        try {\n            // 预编译查询数据总数的sql语句\n            pstmt = connection.prepareStatement(countSql);\n            // 构建boundSql对象\n            BoundSql countBoundSql = new BoundSql(configuration, countSql, boundSql.getParameterMappings(),\n                    boundSql.getParameterObject());\n            // 构建parameterHandler用于设置sql参数\n            ParameterHandler parameterHandler = new DefaultParameterHandler(mappedStatement, boundSql.getParameterObject(),\n                    countBoundSql);\n            // 设置sql参数\n            parameterHandler.setParameters(pstmt);\n            //执行查询\n            ResultSet rs = pstmt.executeQuery();\n            while (rs.next()) {\n                total = rs.getInt(\"total\");\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (pstmt != null) {\n                try {\n                    pstmt.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        // 返回总数据数\n        return total;\n    }\n\n    /**\n     * 设置总数据数、总页数\n     *\n     * @param page\n     * @param invocation\n     * @param metaObject\n     * @param boundSql\n     */\n    private void setTotalToPage(Page page, Invocation invocation, MetaObject metaObject, BoundSql boundSql) {\n        // 总数据数\n        int total = getTotal(invocation, metaObject, boundSql);\n        // 计算总页数\n        int totalPage = total / page.getPageSize();\n        if (total % page.getPageSize() != 0) {\n            totalPage = totalPage + 1;\n        }\n\n        page.setTotal(total);\n        page.setTotalPage(totalPage);\n    }\n\n    /**\n     * 校验分页参数\n     *\n     * @param page\n     */\n    private void checkPage(Page page) {\n        // 如果当前页码大于总页数，抛出异常\n        if (page.getPageIndex() > page.getTotalPage()) {\n            throw new RuntimeException(\"当前页码［\" + page.getPageIndex() + \"］大于总页数［\" + page.getTotalPage() + \"］\");\n        }\n        // 如果当前页码小于总页数，抛出异常\n        if (page.getPageIndex() < 1) {\n            throw new RuntimeException(\"当前页码［\" + page.getPageIndex() + \"］小于［1］\");\n        }\n    }\n\n    /**\n     * 修改当前查询的sql\n     *\n     * @param invocation\n     * @param metaObject\n     * @param boundSql\n     * @param page\n     * @return\n     */\n    private Object changeSql(Invocation invocation, MetaObject metaObject, BoundSql boundSql, Page page) throws Exception {\n        // 获取当前查询的sql\n        String sql = getSql(metaObject);\n        // 修改sql，$_paging_table_limit取名是为了防止数据库表重名\n        String newSql = \"select * from (\" + sql + \") $_paging_table_limit limit ?, ?\";\n        // 设置当前sql为修改后的sql\n        setSql(metaObject, newSql);\n\n        // 获取PreparedStatement对象\n        PreparedStatement pstmt = (PreparedStatement) invocation.proceed();\n        // 获取sql的总参数个数\n        int parameCount = pstmt.getParameterMetaData().getParameterCount();\n        // 设置分页参数\n        pstmt.setInt(parameCount - 1, (page.getPageIndex() - 1) * page.getPageSize());\n        pstmt.setInt(parameCount, page.getPageSize());\n\n        return pstmt;\n    }\n\n    /**\n     * 获取当前查询的sql\n     *\n     * @param metaObject\n     * @return\n     */\n    private String getSql(MetaObject metaObject) {\n        return (String) metaObject.getValue(\"delegate.boundSql.sql\");\n    }\n\n    /**\n     * 设置当前查询的sql\n     *\n     * @param metaObject\n     */\n    private void setSql(MetaObject metaObject, String sql) {\n        metaObject.setValue(\"delegate.boundSql.sql\", sql);\n    }\n}\n```\n\n### 配置分页插件\n\n在mybatis-config.xml配置文件中配置自定义的分页插件\n\n```\n<plugins>\n\t<plugin interceptor=\"PagingPlugin\">\n\t\t<property name=\"default.pageIndex\" value=\"1\"/>\n\t\t<property name=\"default.pageSize\" value=\"20\"/>\n\t</plugin>\n</plugins>\n```\n\n### 实现DAO\n\n```\npublic class Role {\n\n   private Long id;\n   private String roleName;\n   private String note;\n   // 省略get、set...\n}\n```\n\n定义Mapper接口，通过分页对象查询角色列表\n\n```\npublic interface RoleMapper {\n    List<Role> listRoleByPage(Page page);\n}\n```\n\n定义Mapper.xml编写查询的SQL语句\n\n```\n<mapper namespace=\"RoleMapper\">\n    <select id=\"listRoleByPage\" resultType=\"Role\">\n        SELECT id, role_name, note FROM role\n    </select>\n</mapper>\n```\n\n### 测试分页插件\n\n测试代码\n\n```\n@Test\npublic void test() {\n\tInputStream inputStream = null;\n\tSqlSessionFactory sqlSessionFactory;\n\tSqlSession sqlSession = null;\n\ttry {\n\t\tinputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");\n\t\tsqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n\t\tsqlSession = sqlSessionFactory.openSession();\n\t\tRoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);\n\t\t// 分页参数，从第一页开始，每页显示5条数据\n\t\tPage page = new Page(1, 5);\n\t\tList<Role> roleList = roleMapper.listRoleByPage(page);\n\t\tSystem.out.println(\"===分页信息===\");\n\t\tSystem.out.println(\"当前页码：\" + page.getPageIndex());\n\t\tSystem.out.println(\"每页显示数据数：\" + page.getPageSize());\n\t\tSystem.out.println(\"总数据数：\" + page.getTotal());\n\t\tSystem.out.println(\"总页数：\" + page.getTotalPage());\n\t\tSystem.out.println(\"=============\");\n\t\tSystem.out.println(\"===数据列表===\");\n\t\tfor (Role role : roleList) {\n\t\t\tSystem.out.println(role);\n\t\t}\n\t} catch (IOException e) {\n\t\te.printStackTrace();\n\t} finally {\n\t\tif (sqlSession != null) {\n\t\t\tsqlSession.close();\n\t\t}\n\t\tif (inputStream != null) {\n\t\t\ttry {\n\t\t\t\tinputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n数据库role表中的全部数据信息\n\n| id   | role_name   | note       |\n| ---- | ----------- | ---------- |\n| 1    | SUPER_ADMIN | 超级管理员 |\n| 2    | admin       | 管理员     |\n| 3    | user        | 用户       |\n| 4    | user2       | 用户2      |\n| 8    | user3       | 用户3      |\n| 9    | test        | 测试       |\n| 10   | test2       | 测试2      |\n| 11   | test3       | 测试3      |\n| 12   | test4       | 测试4      |\n| 13   | test5       | 测试5      |\n\n代码执行结果\n\n```\n===分页信息===\n当前页码：1\n每页显示数据数：5\n总数据数：10\n总页数：2\n=============\n===数据列表===\nRole{id=1, roleName='SUPER_ADMIN', note=' 超级管理员'}\nRole{id=2, roleName='admin', note='管理员'}\nRole{id=3, roleName='user', note='用户'}\nRole{id=4, roleName='user2', note='用户2'}\nRole{id=8, roleName='user3', note='用户3'}\n```\n\n打印的SQL信息\n\n```\n==>  Preparing: select count(*) as total from (SELECT id, role_name, note FROM role) $_paging \n==> Parameters: \n<==    Columns: total\n<==        Row: 10\n<==      Total: 1\n==>  Preparing: select * from (SELECT id, role_name, note FROM role) $_paging_table_limit limit ?, ? \n==> Parameters: 0(Integer), 5(Integer)\n<==    Columns: id, role_name, note\n<==        Row: 1, SUPER_ADMIN,  超级管理员\n<==        Row: 2, admin, 管理员\n<==        Row: 3, user, 用户\n<==        Row: 4, user2, 用户2\n<==        Row: 8, user3, 用户3\n<==      Total: 5\n```","source":"_posts/MyBatis-Plugin-Development.md","raw":"---\ntitle: MyBatis-Plugin-Development\ndate: 2022-03-10 14:59:54\ntags: MyBatis\n---\n\n\n\n## MyBatis插件开发流程\n\n- 类实现Interceptor接口；\n\n- 类上添加注解\n\n  ```\n  @Intercepts({@Signature(type, method, args)})\n  ```\n\n  - **type**：需要拦截的对象，只可取四大对象之一Executor.class、StatementHandler.class、ParameterHandler.class、ResultSetHandler.class。\n  - **method**：拦截的对象方法。\n  - **args**：拦截的对象方法参数。\n\n- 实现拦截的方法Object intercept(Invocation invocation)。\n\n##  Interceptor接口\n\n```\npublic interface Interceptor {\n\n    /**\n     * 此方法将直接覆盖被拦截对象的原有方法\n     *\n     * @param invocation 通过该对象可以反射调度拦截对象的方法\n     * @return\n     * @throws Throwable\n     */\n    Object intercept(Invocation invocation) throws Throwable;\n\n    /**\n     * 为被拦截对象生成一个代理对象，并返回它\n     *\n     * @param target 被拦截的对象\n     * @return\n     */\n    Object plugin(Object target);\n\n    /**\n     * 设置插件配置的参数\n     *\n     * @param properties 插件配置的参数\n     */\n    void setProperties(Properties properties);\n\n}\n```\n\n## 步骤\n\n### 确定拦截的方法签名\n\n需要在实现Interceptor接口的类上加入@Intercepts({@Signature(type, method, args)})注解才能够运行插件。\n\n#### type－拦截的对象\n\n- Executor 执行的SQL 全过程，包括组装参数、组装结果返回和执行SQL的过程等都可以拦截。\n- StatementHandler 执行SQL的过程，拦截该对象可以重写执行SQL的过程。\n- ParameterHandler 执行SQL 的参数组装，拦截该对象可以重写组装参数的规则。\n- ResultSetHandler 执行结果的组装，拦截该对象可以重写组装结果的规则。\n\n对于分页插件，我们只需要拦截StatementHandler对象，重写SELECT类型的SQL语句，实现分页功能。\n\n\n\n#### method－拦截的方法\n\n我们已经能够确定拦截的对象是StatementHandler了，现在我们要确定拦截的是哪个方法，因为StatementHandler是通过prepare方法对SQL进行预编译的，所以我们需要对prepare方法进行拦截，在这个方法执行之前，完成SQL的重新编写，加入limit。\n\n**StatementHandler**\n\n```\npublic interface StatementHandler {\n\n  /**\n   * 预编译SQL\n   *\n   * @param connection\n   * @return\n   * @throws SQLException\n   */\n  Statement prepare(Connection connection)\n      throws SQLException;\n\n  /**\n   * 设置参数\n   *\n   * @param statement\n   * @throws SQLException\n   */\n  void parameterize(Statement statement)\n      throws SQLException;\n\n  /**\n   * 批处理\n   *\n   * @param statement\n   * @throws SQLException\n   */\n  void batch(Statement statement)\n      throws SQLException;\n\n  /**\n   * 执行更新操作\n   *\n   * @param statement\n   * @return 返回影响行数\n   * @throws SQLException\n   */\n  int update(Statement statement)\n      throws SQLException;\n\n  /**\n   * 执行查询操作，将结果交给ResultHandler进行结果的组装\n   *\n   * @param statement\n   * @param resultHandler\n   * @param <E>\n   * @return 返回查询的数据列表\n   * @throws SQLException\n   */\n  <E> List<E> query(Statement statement, ResultHandler resultHandler)\n      throws SQLException;\n\n  /**\n   * 得到绑定的sql\n   * \n   * @return\n   */\n  BoundSql getBoundSql();\n\n  /**\n   * 得到参数处理器\n   * \n   * @return\n   */\n  ParameterHandler getParameterHandler();\n\n}\n```\n\n#### args－拦截的参数\n\nargs是一个Class类型的数组，表示的是被拦截方法的参数列表。由于我们已经确定了拦截的是StatementHandler的prepare方法，而该方法只有一个参数Connection，所以我们只需要拦截这一个参数即可。\n\n### 实现拦截方法\n\n定义一个封装分页参数的类Page\n\n```\npublic class Page {\n\n    /**\n     * 当前页码\n     */\n    private Integer pageIndex;\n    /**\n     * 每页数据条数\n     */\n    private Integer pageSize;\n    /**\n     * 总数据数\n     */\n    private Integer total;\n    /**\n     * 总页数\n     */\n    private Integer totalPage;\n\n    public Page() {\n    }\n\n    public Page(Integer pageIndex, Integer pageSize) {\n        this.pageIndex = pageIndex;\n        this.pageSize = pageSize;\n    }\n\t// 省略get、set方法...\n}\n```\n\n实现插件分页的功能\n\n```\nimport org.apache.ibatis.executor.parameter.ParameterHandler;\nimport org.apache.ibatis.executor.statement.StatementHandler;\nimport org.apache.ibatis.mapping.BoundSql;\nimport org.apache.ibatis.mapping.MappedStatement;\nimport org.apache.ibatis.plugin.*;\nimport org.apache.ibatis.reflection.MetaObject;\nimport org.apache.ibatis.reflection.SystemMetaObject;\nimport org.apache.ibatis.scripting.defaults.DefaultParameterHandler;\nimport org.apache.ibatis.session.Configuration;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\n\n@Intercepts({@Signature(\n        type = StatementHandler.class,\n        method = \"prepare\",\n        args = {Connection.class}\n)})\npublic class PagingPlugin implements Interceptor {\n\n    /**\n     * 默认页码\n     */\n    private Integer defaultPageIndex;\n    /**\n     * 默认每页数据条数\n     */\n    private Integer defaultPageSize;\n\n    public Object intercept(Invocation invocation) throws Throwable {\n        StatementHandler statementHandler = getUnProxyObject(invocation);\n        MetaObject metaObject = SystemMetaObject.forObject(statementHandler);\n        String sql = getSql(metaObject);\n        if (!checkSelect(sql)) {\n            // 不是select语句，进入责任链下一层\n            return invocation.proceed();\n        }\n\n        BoundSql boundSql = (BoundSql) metaObject.getValue(\"delegate.boundSql\");\n        Object parameterObject = boundSql.getParameterObject();\n        Page page = getPage(parameterObject);\n        if (page == null) {\n            // 没有传入page对象，不执行分页处理，进入责任链下一层\n            return invocation.proceed();\n        }\n\n        // 设置分页默认值\n        if (page.getPageIndex() == null) {\n            page.setPageIndex(this.defaultPageIndex);\n        }\n        if (page.getPageSize() == null) {\n            page.setPageSize(this.defaultPageSize);\n        }\n        // 设置分页总数，数据总数\n        setTotalToPage(page, invocation, metaObject, boundSql);\n        // 校验分页参数\n        checkPage(page);\n        return changeSql(invocation, metaObject, boundSql, page);\n    }\n\n    public Object plugin(Object target) {\n        // 生成代理对象\n        return Plugin.wrap(target, this);\n    }\n\n    public void setProperties(Properties properties) {\n        // 初始化配置的默认页码，无配置则默认1\n        this.defaultPageIndex = Integer.parseInt(properties.getProperty(\"default.pageIndex\", \"1\"));\n        // 初始化配置的默认数据条数，无配置则默认20\n        this.defaultPageSize = Integer.parseInt(properties.getProperty(\"default.pageSize\", \"20\"));\n    }\n\n    /**\n     * 从代理对象中分离出真实对象\n     *\n     * @param invocation\n     * @return\n     */\n    private StatementHandler getUnProxyObject(Invocation invocation) {\n        // 取出被拦截的对象\n        StatementHandler statementHandler = (StatementHandler) invocation.getTarget();\n        MetaObject metaStmtHandler = SystemMetaObject.forObject(statementHandler);\n        Object object = null;\n        // 分离代理对象\n        while (metaStmtHandler.hasGetter(\"h\")) {\n            object = metaStmtHandler.getValue(\"h\");\n            metaStmtHandler = SystemMetaObject.forObject(object);\n        }\n\n        return object == null ? statementHandler : (StatementHandler) object;\n    }\n\n    /**\n     * 判断是否是select语句\n     *\n     * @param sql\n     * @return\n     */\n    private boolean checkSelect(String sql) {\n        // 去除sql的前后空格，并将sql转换成小写\n        sql = sql.trim().toLowerCase();\n        return sql.indexOf(\"select\") == 0;\n    }\n\n    /**\n     * 获取分页参数\n     *\n     * @param parameterObject\n     * @return\n     */\n    private Page getPage(Object parameterObject) {\n        if (parameterObject == null) {\n            return null;\n        }\n\n        if (parameterObject instanceof Map) {\n            // 如果传入的参数是map类型的，则遍历map取出Page对象\n            Map<String, Object> parameMap = (Map<String, Object>) parameterObject;\n            Set<String> keySet = parameMap.keySet();\n            for (String key : keySet) {\n                Object value = parameMap.get(key);\n                if (value instanceof Page) {\n                    // 返回Page对象\n                    return (Page) value;\n                }\n            }\n        } else if (parameterObject instanceof Page) {\n            // 如果传入的是Page类型，则直接返回该对象\n            return (Page) parameterObject;\n        }\n\n        // 初步判断并没有传入Page类型的参数，返回null\n        return null;\n    }\n\n    /**\n     * 获取数据总数\n     *\n     * @param invocation\n     * @param metaObject\n     * @param boundSql\n     * @return\n     */\n    private int getTotal(Invocation invocation, MetaObject metaObject, BoundSql boundSql) {\n        // 获取当前的mappedStatement对象\n        MappedStatement mappedStatement = (MappedStatement) metaObject.getValue(\"delegate.mappedStatement\");\n        // 获取配置对象\n        Configuration configuration = mappedStatement.getConfiguration();\n        // 获取当前需要执行的sql\n        String sql = getSql(metaObject);\n        // 改写sql语句，实现返回数据总数 $_paging取名是为了防止数据库表重名\n        String countSql = \"select count(*) as total from (\" + sql + \") $_paging\";\n        // 获取拦截方法参数，拦截的是connection对象\n        Connection connection = (Connection) invocation.getArgs()[0];\n        PreparedStatement pstmt = null;\n        int total = 0;\n\n        try {\n            // 预编译查询数据总数的sql语句\n            pstmt = connection.prepareStatement(countSql);\n            // 构建boundSql对象\n            BoundSql countBoundSql = new BoundSql(configuration, countSql, boundSql.getParameterMappings(),\n                    boundSql.getParameterObject());\n            // 构建parameterHandler用于设置sql参数\n            ParameterHandler parameterHandler = new DefaultParameterHandler(mappedStatement, boundSql.getParameterObject(),\n                    countBoundSql);\n            // 设置sql参数\n            parameterHandler.setParameters(pstmt);\n            //执行查询\n            ResultSet rs = pstmt.executeQuery();\n            while (rs.next()) {\n                total = rs.getInt(\"total\");\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (pstmt != null) {\n                try {\n                    pstmt.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        // 返回总数据数\n        return total;\n    }\n\n    /**\n     * 设置总数据数、总页数\n     *\n     * @param page\n     * @param invocation\n     * @param metaObject\n     * @param boundSql\n     */\n    private void setTotalToPage(Page page, Invocation invocation, MetaObject metaObject, BoundSql boundSql) {\n        // 总数据数\n        int total = getTotal(invocation, metaObject, boundSql);\n        // 计算总页数\n        int totalPage = total / page.getPageSize();\n        if (total % page.getPageSize() != 0) {\n            totalPage = totalPage + 1;\n        }\n\n        page.setTotal(total);\n        page.setTotalPage(totalPage);\n    }\n\n    /**\n     * 校验分页参数\n     *\n     * @param page\n     */\n    private void checkPage(Page page) {\n        // 如果当前页码大于总页数，抛出异常\n        if (page.getPageIndex() > page.getTotalPage()) {\n            throw new RuntimeException(\"当前页码［\" + page.getPageIndex() + \"］大于总页数［\" + page.getTotalPage() + \"］\");\n        }\n        // 如果当前页码小于总页数，抛出异常\n        if (page.getPageIndex() < 1) {\n            throw new RuntimeException(\"当前页码［\" + page.getPageIndex() + \"］小于［1］\");\n        }\n    }\n\n    /**\n     * 修改当前查询的sql\n     *\n     * @param invocation\n     * @param metaObject\n     * @param boundSql\n     * @param page\n     * @return\n     */\n    private Object changeSql(Invocation invocation, MetaObject metaObject, BoundSql boundSql, Page page) throws Exception {\n        // 获取当前查询的sql\n        String sql = getSql(metaObject);\n        // 修改sql，$_paging_table_limit取名是为了防止数据库表重名\n        String newSql = \"select * from (\" + sql + \") $_paging_table_limit limit ?, ?\";\n        // 设置当前sql为修改后的sql\n        setSql(metaObject, newSql);\n\n        // 获取PreparedStatement对象\n        PreparedStatement pstmt = (PreparedStatement) invocation.proceed();\n        // 获取sql的总参数个数\n        int parameCount = pstmt.getParameterMetaData().getParameterCount();\n        // 设置分页参数\n        pstmt.setInt(parameCount - 1, (page.getPageIndex() - 1) * page.getPageSize());\n        pstmt.setInt(parameCount, page.getPageSize());\n\n        return pstmt;\n    }\n\n    /**\n     * 获取当前查询的sql\n     *\n     * @param metaObject\n     * @return\n     */\n    private String getSql(MetaObject metaObject) {\n        return (String) metaObject.getValue(\"delegate.boundSql.sql\");\n    }\n\n    /**\n     * 设置当前查询的sql\n     *\n     * @param metaObject\n     */\n    private void setSql(MetaObject metaObject, String sql) {\n        metaObject.setValue(\"delegate.boundSql.sql\", sql);\n    }\n}\n```\n\n### 配置分页插件\n\n在mybatis-config.xml配置文件中配置自定义的分页插件\n\n```\n<plugins>\n\t<plugin interceptor=\"PagingPlugin\">\n\t\t<property name=\"default.pageIndex\" value=\"1\"/>\n\t\t<property name=\"default.pageSize\" value=\"20\"/>\n\t</plugin>\n</plugins>\n```\n\n### 实现DAO\n\n```\npublic class Role {\n\n   private Long id;\n   private String roleName;\n   private String note;\n   // 省略get、set...\n}\n```\n\n定义Mapper接口，通过分页对象查询角色列表\n\n```\npublic interface RoleMapper {\n    List<Role> listRoleByPage(Page page);\n}\n```\n\n定义Mapper.xml编写查询的SQL语句\n\n```\n<mapper namespace=\"RoleMapper\">\n    <select id=\"listRoleByPage\" resultType=\"Role\">\n        SELECT id, role_name, note FROM role\n    </select>\n</mapper>\n```\n\n### 测试分页插件\n\n测试代码\n\n```\n@Test\npublic void test() {\n\tInputStream inputStream = null;\n\tSqlSessionFactory sqlSessionFactory;\n\tSqlSession sqlSession = null;\n\ttry {\n\t\tinputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");\n\t\tsqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n\t\tsqlSession = sqlSessionFactory.openSession();\n\t\tRoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);\n\t\t// 分页参数，从第一页开始，每页显示5条数据\n\t\tPage page = new Page(1, 5);\n\t\tList<Role> roleList = roleMapper.listRoleByPage(page);\n\t\tSystem.out.println(\"===分页信息===\");\n\t\tSystem.out.println(\"当前页码：\" + page.getPageIndex());\n\t\tSystem.out.println(\"每页显示数据数：\" + page.getPageSize());\n\t\tSystem.out.println(\"总数据数：\" + page.getTotal());\n\t\tSystem.out.println(\"总页数：\" + page.getTotalPage());\n\t\tSystem.out.println(\"=============\");\n\t\tSystem.out.println(\"===数据列表===\");\n\t\tfor (Role role : roleList) {\n\t\t\tSystem.out.println(role);\n\t\t}\n\t} catch (IOException e) {\n\t\te.printStackTrace();\n\t} finally {\n\t\tif (sqlSession != null) {\n\t\t\tsqlSession.close();\n\t\t}\n\t\tif (inputStream != null) {\n\t\t\ttry {\n\t\t\t\tinputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n数据库role表中的全部数据信息\n\n| id   | role_name   | note       |\n| ---- | ----------- | ---------- |\n| 1    | SUPER_ADMIN | 超级管理员 |\n| 2    | admin       | 管理员     |\n| 3    | user        | 用户       |\n| 4    | user2       | 用户2      |\n| 8    | user3       | 用户3      |\n| 9    | test        | 测试       |\n| 10   | test2       | 测试2      |\n| 11   | test3       | 测试3      |\n| 12   | test4       | 测试4      |\n| 13   | test5       | 测试5      |\n\n代码执行结果\n\n```\n===分页信息===\n当前页码：1\n每页显示数据数：5\n总数据数：10\n总页数：2\n=============\n===数据列表===\nRole{id=1, roleName='SUPER_ADMIN', note=' 超级管理员'}\nRole{id=2, roleName='admin', note='管理员'}\nRole{id=3, roleName='user', note='用户'}\nRole{id=4, roleName='user2', note='用户2'}\nRole{id=8, roleName='user3', note='用户3'}\n```\n\n打印的SQL信息\n\n```\n==>  Preparing: select count(*) as total from (SELECT id, role_name, note FROM role) $_paging \n==> Parameters: \n<==    Columns: total\n<==        Row: 10\n<==      Total: 1\n==>  Preparing: select * from (SELECT id, role_name, note FROM role) $_paging_table_limit limit ?, ? \n==> Parameters: 0(Integer), 5(Integer)\n<==    Columns: id, role_name, note\n<==        Row: 1, SUPER_ADMIN,  超级管理员\n<==        Row: 2, admin, 管理员\n<==        Row: 3, user, 用户\n<==        Row: 4, user2, 用户2\n<==        Row: 8, user3, 用户3\n<==      Total: 5\n```","slug":"MyBatis-Plugin-Development","published":1,"updated":"2022-03-10T07:28:41.020Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0vrkoq6000710lnbou89t0j","content":"<h2 id=\"MyBatis插件开发流程\"><a href=\"#MyBatis插件开发流程\" class=\"headerlink\" title=\"MyBatis插件开发流程\"></a>MyBatis插件开发流程</h2><ul>\n<li><p>类实现Interceptor接口；</p>\n</li>\n<li><p>类上添加注解</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Intercepts(&#123;@Signature(type, method, args)&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>type</strong>：需要拦截的对象，只可取四大对象之一Executor.class、StatementHandler.class、ParameterHandler.class、ResultSetHandler.class。</li>\n<li><strong>method</strong>：拦截的对象方法。</li>\n<li><strong>args</strong>：拦截的对象方法参数。</li>\n</ul>\n</li>\n<li><p>实现拦截的方法Object intercept(Invocation invocation)。</p>\n</li>\n</ul>\n<h2 id=\"Interceptor接口\"><a href=\"#Interceptor接口\" class=\"headerlink\" title=\"Interceptor接口\"></a>Interceptor接口</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Interceptor &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 此方法将直接覆盖被拦截对象的原有方法</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param invocation 通过该对象可以反射调度拦截对象的方法</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     * @throws Throwable</span><br><span class=\"line\">     */</span><br><span class=\"line\">    Object intercept(Invocation invocation) throws Throwable;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 为被拦截对象生成一个代理对象，并返回它</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param target 被拦截的对象</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    Object plugin(Object target);</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 设置插件配置的参数</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param properties 插件配置的参数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    void setProperties(Properties properties);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><h3 id=\"确定拦截的方法签名\"><a href=\"#确定拦截的方法签名\" class=\"headerlink\" title=\"确定拦截的方法签名\"></a>确定拦截的方法签名</h3><p>需要在实现Interceptor接口的类上加入@Intercepts({@Signature(type, method, args)})注解才能够运行插件。</p>\n<h4 id=\"type－拦截的对象\"><a href=\"#type－拦截的对象\" class=\"headerlink\" title=\"type－拦截的对象\"></a>type－拦截的对象</h4><ul>\n<li>Executor 执行的SQL 全过程，包括组装参数、组装结果返回和执行SQL的过程等都可以拦截。</li>\n<li>StatementHandler 执行SQL的过程，拦截该对象可以重写执行SQL的过程。</li>\n<li>ParameterHandler 执行SQL 的参数组装，拦截该对象可以重写组装参数的规则。</li>\n<li>ResultSetHandler 执行结果的组装，拦截该对象可以重写组装结果的规则。</li>\n</ul>\n<p>对于分页插件，我们只需要拦截StatementHandler对象，重写SELECT类型的SQL语句，实现分页功能。</p>\n<h4 id=\"method－拦截的方法\"><a href=\"#method－拦截的方法\" class=\"headerlink\" title=\"method－拦截的方法\"></a>method－拦截的方法</h4><p>我们已经能够确定拦截的对象是StatementHandler了，现在我们要确定拦截的是哪个方法，因为StatementHandler是通过prepare方法对SQL进行预编译的，所以我们需要对prepare方法进行拦截，在这个方法执行之前，完成SQL的重新编写，加入limit。</p>\n<p><strong>StatementHandler</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface StatementHandler &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * 预编译SQL</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @param connection</span><br><span class=\"line\">   * @return</span><br><span class=\"line\">   * @throws SQLException</span><br><span class=\"line\">   */</span><br><span class=\"line\">  Statement prepare(Connection connection)</span><br><span class=\"line\">      throws SQLException;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * 设置参数</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @param statement</span><br><span class=\"line\">   * @throws SQLException</span><br><span class=\"line\">   */</span><br><span class=\"line\">  void parameterize(Statement statement)</span><br><span class=\"line\">      throws SQLException;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * 批处理</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @param statement</span><br><span class=\"line\">   * @throws SQLException</span><br><span class=\"line\">   */</span><br><span class=\"line\">  void batch(Statement statement)</span><br><span class=\"line\">      throws SQLException;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * 执行更新操作</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @param statement</span><br><span class=\"line\">   * @return 返回影响行数</span><br><span class=\"line\">   * @throws SQLException</span><br><span class=\"line\">   */</span><br><span class=\"line\">  int update(Statement statement)</span><br><span class=\"line\">      throws SQLException;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * 执行查询操作，将结果交给ResultHandler进行结果的组装</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @param statement</span><br><span class=\"line\">   * @param resultHandler</span><br><span class=\"line\">   * @param &lt;E&gt;</span><br><span class=\"line\">   * @return 返回查询的数据列表</span><br><span class=\"line\">   * @throws SQLException</span><br><span class=\"line\">   */</span><br><span class=\"line\">  &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler)</span><br><span class=\"line\">      throws SQLException;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * 得到绑定的sql</span><br><span class=\"line\">   * </span><br><span class=\"line\">   * @return</span><br><span class=\"line\">   */</span><br><span class=\"line\">  BoundSql getBoundSql();</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * 得到参数处理器</span><br><span class=\"line\">   * </span><br><span class=\"line\">   * @return</span><br><span class=\"line\">   */</span><br><span class=\"line\">  ParameterHandler getParameterHandler();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"args－拦截的参数\"><a href=\"#args－拦截的参数\" class=\"headerlink\" title=\"args－拦截的参数\"></a>args－拦截的参数</h4><p>args是一个Class类型的数组，表示的是被拦截方法的参数列表。由于我们已经确定了拦截的是StatementHandler的prepare方法，而该方法只有一个参数Connection，所以我们只需要拦截这一个参数即可。</p>\n<h3 id=\"实现拦截方法\"><a href=\"#实现拦截方法\" class=\"headerlink\" title=\"实现拦截方法\"></a>实现拦截方法</h3><p>定义一个封装分页参数的类Page</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Page &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 当前页码</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private Integer pageIndex;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 每页数据条数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private Integer pageSize;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 总数据数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private Integer total;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 总页数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private Integer totalPage;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Page() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Page(Integer pageIndex, Integer pageSize) &#123;</span><br><span class=\"line\">        this.pageIndex = pageIndex;</span><br><span class=\"line\">        this.pageSize = pageSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t// 省略get、set方法...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现插件分页的功能</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.apache.ibatis.executor.parameter.ParameterHandler;</span><br><span class=\"line\">import org.apache.ibatis.executor.statement.StatementHandler;</span><br><span class=\"line\">import org.apache.ibatis.mapping.BoundSql;</span><br><span class=\"line\">import org.apache.ibatis.mapping.MappedStatement;</span><br><span class=\"line\">import org.apache.ibatis.plugin.*;</span><br><span class=\"line\">import org.apache.ibatis.reflection.MetaObject;</span><br><span class=\"line\">import org.apache.ibatis.reflection.SystemMetaObject;</span><br><span class=\"line\">import org.apache.ibatis.scripting.defaults.DefaultParameterHandler;</span><br><span class=\"line\">import org.apache.ibatis.session.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.sql.Connection;</span><br><span class=\"line\">import java.sql.PreparedStatement;</span><br><span class=\"line\">import java.sql.ResultSet;</span><br><span class=\"line\">import java.sql.SQLException;</span><br><span class=\"line\">import java.util.Map;</span><br><span class=\"line\">import java.util.Properties;</span><br><span class=\"line\">import java.util.Set;</span><br><span class=\"line\"></span><br><span class=\"line\">@Intercepts(&#123;@Signature(</span><br><span class=\"line\">        type = StatementHandler.class,</span><br><span class=\"line\">        method = &quot;prepare&quot;,</span><br><span class=\"line\">        args = &#123;Connection.class&#125;</span><br><span class=\"line\">)&#125;)</span><br><span class=\"line\">public class PagingPlugin implements Interceptor &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 默认页码</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private Integer defaultPageIndex;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 默认每页数据条数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private Integer defaultPageSize;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class=\"line\">        StatementHandler statementHandler = getUnProxyObject(invocation);</span><br><span class=\"line\">        MetaObject metaObject = SystemMetaObject.forObject(statementHandler);</span><br><span class=\"line\">        String sql = getSql(metaObject);</span><br><span class=\"line\">        if (!checkSelect(sql)) &#123;</span><br><span class=\"line\">            // 不是select语句，进入责任链下一层</span><br><span class=\"line\">            return invocation.proceed();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        BoundSql boundSql = (BoundSql) metaObject.getValue(&quot;delegate.boundSql&quot;);</span><br><span class=\"line\">        Object parameterObject = boundSql.getParameterObject();</span><br><span class=\"line\">        Page page = getPage(parameterObject);</span><br><span class=\"line\">        if (page == null) &#123;</span><br><span class=\"line\">            // 没有传入page对象，不执行分页处理，进入责任链下一层</span><br><span class=\"line\">            return invocation.proceed();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 设置分页默认值</span><br><span class=\"line\">        if (page.getPageIndex() == null) &#123;</span><br><span class=\"line\">            page.setPageIndex(this.defaultPageIndex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (page.getPageSize() == null) &#123;</span><br><span class=\"line\">            page.setPageSize(this.defaultPageSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 设置分页总数，数据总数</span><br><span class=\"line\">        setTotalToPage(page, invocation, metaObject, boundSql);</span><br><span class=\"line\">        // 校验分页参数</span><br><span class=\"line\">        checkPage(page);</span><br><span class=\"line\">        return changeSql(invocation, metaObject, boundSql, page);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Object plugin(Object target) &#123;</span><br><span class=\"line\">        // 生成代理对象</span><br><span class=\"line\">        return Plugin.wrap(target, this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setProperties(Properties properties) &#123;</span><br><span class=\"line\">        // 初始化配置的默认页码，无配置则默认1</span><br><span class=\"line\">        this.defaultPageIndex = Integer.parseInt(properties.getProperty(&quot;default.pageIndex&quot;, &quot;1&quot;));</span><br><span class=\"line\">        // 初始化配置的默认数据条数，无配置则默认20</span><br><span class=\"line\">        this.defaultPageSize = Integer.parseInt(properties.getProperty(&quot;default.pageSize&quot;, &quot;20&quot;));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 从代理对象中分离出真实对象</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param invocation</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private StatementHandler getUnProxyObject(Invocation invocation) &#123;</span><br><span class=\"line\">        // 取出被拦截的对象</span><br><span class=\"line\">        StatementHandler statementHandler = (StatementHandler) invocation.getTarget();</span><br><span class=\"line\">        MetaObject metaStmtHandler = SystemMetaObject.forObject(statementHandler);</span><br><span class=\"line\">        Object object = null;</span><br><span class=\"line\">        // 分离代理对象</span><br><span class=\"line\">        while (metaStmtHandler.hasGetter(&quot;h&quot;)) &#123;</span><br><span class=\"line\">            object = metaStmtHandler.getValue(&quot;h&quot;);</span><br><span class=\"line\">            metaStmtHandler = SystemMetaObject.forObject(object);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return object == null ? statementHandler : (StatementHandler) object;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 判断是否是select语句</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param sql</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private boolean checkSelect(String sql) &#123;</span><br><span class=\"line\">        // 去除sql的前后空格，并将sql转换成小写</span><br><span class=\"line\">        sql = sql.trim().toLowerCase();</span><br><span class=\"line\">        return sql.indexOf(&quot;select&quot;) == 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 获取分页参数</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param parameterObject</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private Page getPage(Object parameterObject) &#123;</span><br><span class=\"line\">        if (parameterObject == null) &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (parameterObject instanceof Map) &#123;</span><br><span class=\"line\">            // 如果传入的参数是map类型的，则遍历map取出Page对象</span><br><span class=\"line\">            Map&lt;String, Object&gt; parameMap = (Map&lt;String, Object&gt;) parameterObject;</span><br><span class=\"line\">            Set&lt;String&gt; keySet = parameMap.keySet();</span><br><span class=\"line\">            for (String key : keySet) &#123;</span><br><span class=\"line\">                Object value = parameMap.get(key);</span><br><span class=\"line\">                if (value instanceof Page) &#123;</span><br><span class=\"line\">                    // 返回Page对象</span><br><span class=\"line\">                    return (Page) value;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else if (parameterObject instanceof Page) &#123;</span><br><span class=\"line\">            // 如果传入的是Page类型，则直接返回该对象</span><br><span class=\"line\">            return (Page) parameterObject;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 初步判断并没有传入Page类型的参数，返回null</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 获取数据总数</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param invocation</span><br><span class=\"line\">     * @param metaObject</span><br><span class=\"line\">     * @param boundSql</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private int getTotal(Invocation invocation, MetaObject metaObject, BoundSql boundSql) &#123;</span><br><span class=\"line\">        // 获取当前的mappedStatement对象</span><br><span class=\"line\">        MappedStatement mappedStatement = (MappedStatement) metaObject.getValue(&quot;delegate.mappedStatement&quot;);</span><br><span class=\"line\">        // 获取配置对象</span><br><span class=\"line\">        Configuration configuration = mappedStatement.getConfiguration();</span><br><span class=\"line\">        // 获取当前需要执行的sql</span><br><span class=\"line\">        String sql = getSql(metaObject);</span><br><span class=\"line\">        // 改写sql语句，实现返回数据总数 $_paging取名是为了防止数据库表重名</span><br><span class=\"line\">        String countSql = &quot;select count(*) as total from (&quot; + sql + &quot;) $_paging&quot;;</span><br><span class=\"line\">        // 获取拦截方法参数，拦截的是connection对象</span><br><span class=\"line\">        Connection connection = (Connection) invocation.getArgs()[0];</span><br><span class=\"line\">        PreparedStatement pstmt = null;</span><br><span class=\"line\">        int total = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            // 预编译查询数据总数的sql语句</span><br><span class=\"line\">            pstmt = connection.prepareStatement(countSql);</span><br><span class=\"line\">            // 构建boundSql对象</span><br><span class=\"line\">            BoundSql countBoundSql = new BoundSql(configuration, countSql, boundSql.getParameterMappings(),</span><br><span class=\"line\">                    boundSql.getParameterObject());</span><br><span class=\"line\">            // 构建parameterHandler用于设置sql参数</span><br><span class=\"line\">            ParameterHandler parameterHandler = new DefaultParameterHandler(mappedStatement, boundSql.getParameterObject(),</span><br><span class=\"line\">                    countBoundSql);</span><br><span class=\"line\">            // 设置sql参数</span><br><span class=\"line\">            parameterHandler.setParameters(pstmt);</span><br><span class=\"line\">            //执行查询</span><br><span class=\"line\">            ResultSet rs = pstmt.executeQuery();</span><br><span class=\"line\">            while (rs.next()) &#123;</span><br><span class=\"line\">                total = rs.getInt(&quot;total&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (SQLException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            if (pstmt != null) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    pstmt.close();</span><br><span class=\"line\">                &#125; catch (SQLException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 返回总数据数</span><br><span class=\"line\">        return total;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 设置总数据数、总页数</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param page</span><br><span class=\"line\">     * @param invocation</span><br><span class=\"line\">     * @param metaObject</span><br><span class=\"line\">     * @param boundSql</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void setTotalToPage(Page page, Invocation invocation, MetaObject metaObject, BoundSql boundSql) &#123;</span><br><span class=\"line\">        // 总数据数</span><br><span class=\"line\">        int total = getTotal(invocation, metaObject, boundSql);</span><br><span class=\"line\">        // 计算总页数</span><br><span class=\"line\">        int totalPage = total / page.getPageSize();</span><br><span class=\"line\">        if (total % page.getPageSize() != 0) &#123;</span><br><span class=\"line\">            totalPage = totalPage + 1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        page.setTotal(total);</span><br><span class=\"line\">        page.setTotalPage(totalPage);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 校验分页参数</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param page</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void checkPage(Page page) &#123;</span><br><span class=\"line\">        // 如果当前页码大于总页数，抛出异常</span><br><span class=\"line\">        if (page.getPageIndex() &gt; page.getTotalPage()) &#123;</span><br><span class=\"line\">            throw new RuntimeException(&quot;当前页码［&quot; + page.getPageIndex() + &quot;］大于总页数［&quot; + page.getTotalPage() + &quot;］&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 如果当前页码小于总页数，抛出异常</span><br><span class=\"line\">        if (page.getPageIndex() &lt; 1) &#123;</span><br><span class=\"line\">            throw new RuntimeException(&quot;当前页码［&quot; + page.getPageIndex() + &quot;］小于［1］&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 修改当前查询的sql</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param invocation</span><br><span class=\"line\">     * @param metaObject</span><br><span class=\"line\">     * @param boundSql</span><br><span class=\"line\">     * @param page</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private Object changeSql(Invocation invocation, MetaObject metaObject, BoundSql boundSql, Page page) throws Exception &#123;</span><br><span class=\"line\">        // 获取当前查询的sql</span><br><span class=\"line\">        String sql = getSql(metaObject);</span><br><span class=\"line\">        // 修改sql，$_paging_table_limit取名是为了防止数据库表重名</span><br><span class=\"line\">        String newSql = &quot;select * from (&quot; + sql + &quot;) $_paging_table_limit limit ?, ?&quot;;</span><br><span class=\"line\">        // 设置当前sql为修改后的sql</span><br><span class=\"line\">        setSql(metaObject, newSql);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 获取PreparedStatement对象</span><br><span class=\"line\">        PreparedStatement pstmt = (PreparedStatement) invocation.proceed();</span><br><span class=\"line\">        // 获取sql的总参数个数</span><br><span class=\"line\">        int parameCount = pstmt.getParameterMetaData().getParameterCount();</span><br><span class=\"line\">        // 设置分页参数</span><br><span class=\"line\">        pstmt.setInt(parameCount - 1, (page.getPageIndex() - 1) * page.getPageSize());</span><br><span class=\"line\">        pstmt.setInt(parameCount, page.getPageSize());</span><br><span class=\"line\"></span><br><span class=\"line\">        return pstmt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 获取当前查询的sql</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param metaObject</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private String getSql(MetaObject metaObject) &#123;</span><br><span class=\"line\">        return (String) metaObject.getValue(&quot;delegate.boundSql.sql&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 设置当前查询的sql</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param metaObject</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void setSql(MetaObject metaObject, String sql) &#123;</span><br><span class=\"line\">        metaObject.setValue(&quot;delegate.boundSql.sql&quot;, sql);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置分页插件\"><a href=\"#配置分页插件\" class=\"headerlink\" title=\"配置分页插件\"></a>配置分页插件</h3><p>在mybatis-config.xml配置文件中配置自定义的分页插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;plugins&gt;</span><br><span class=\"line\">\t&lt;plugin interceptor=&quot;PagingPlugin&quot;&gt;</span><br><span class=\"line\">\t\t&lt;property name=&quot;default.pageIndex&quot; value=&quot;1&quot;/&gt;</span><br><span class=\"line\">\t\t&lt;property name=&quot;default.pageSize&quot; value=&quot;20&quot;/&gt;</span><br><span class=\"line\">\t&lt;/plugin&gt;</span><br><span class=\"line\">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实现DAO\"><a href=\"#实现DAO\" class=\"headerlink\" title=\"实现DAO\"></a>实现DAO</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Role &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   private Long id;</span><br><span class=\"line\">   private String roleName;</span><br><span class=\"line\">   private String note;</span><br><span class=\"line\">   // 省略get、set...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义Mapper接口，通过分页对象查询角色列表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface RoleMapper &#123;</span><br><span class=\"line\">    List&lt;Role&gt; listRoleByPage(Page page);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义Mapper.xml编写查询的SQL语句</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;mapper namespace=&quot;RoleMapper&quot;&gt;</span><br><span class=\"line\">    &lt;select id=&quot;listRoleByPage&quot; resultType=&quot;Role&quot;&gt;</span><br><span class=\"line\">        SELECT id, role_name, note FROM role</span><br><span class=\"line\">    &lt;/select&gt;</span><br><span class=\"line\">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试分页插件\"><a href=\"#测试分页插件\" class=\"headerlink\" title=\"测试分页插件\"></a>测试分页插件</h3><p>测试代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test() &#123;</span><br><span class=\"line\">\tInputStream inputStream = null;</span><br><span class=\"line\">\tSqlSessionFactory sqlSessionFactory;</span><br><span class=\"line\">\tSqlSession sqlSession = null;</span><br><span class=\"line\">\ttry &#123;</span><br><span class=\"line\">\t\tinputStream = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class=\"line\">\t\tsqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class=\"line\">\t\tsqlSession = sqlSessionFactory.openSession();</span><br><span class=\"line\">\t\tRoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);</span><br><span class=\"line\">\t\t// 分页参数，从第一页开始，每页显示5条数据</span><br><span class=\"line\">\t\tPage page = new Page(1, 5);</span><br><span class=\"line\">\t\tList&lt;Role&gt; roleList = roleMapper.listRoleByPage(page);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;===分页信息===&quot;);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;当前页码：&quot; + page.getPageIndex());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;每页显示数据数：&quot; + page.getPageSize());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;总数据数：&quot; + page.getTotal());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;总页数：&quot; + page.getTotalPage());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;=============&quot;);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;===数据列表===&quot;);</span><br><span class=\"line\">\t\tfor (Role role : roleList) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(role);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; catch (IOException e) &#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125; finally &#123;</span><br><span class=\"line\">\t\tif (sqlSession != null) &#123;</span><br><span class=\"line\">\t\t\tsqlSession.close();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif (inputStream != null) &#123;</span><br><span class=\"line\">\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\tinputStream.close();</span><br><span class=\"line\">\t\t\t&#125; catch (IOException e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>数据库role表中的全部数据信息</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>role_name</th>\n<th>note</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>SUPER_ADMIN</td>\n<td>超级管理员</td>\n</tr>\n<tr>\n<td>2</td>\n<td>admin</td>\n<td>管理员</td>\n</tr>\n<tr>\n<td>3</td>\n<td>user</td>\n<td>用户</td>\n</tr>\n<tr>\n<td>4</td>\n<td>user2</td>\n<td>用户2</td>\n</tr>\n<tr>\n<td>8</td>\n<td>user3</td>\n<td>用户3</td>\n</tr>\n<tr>\n<td>9</td>\n<td>test</td>\n<td>测试</td>\n</tr>\n<tr>\n<td>10</td>\n<td>test2</td>\n<td>测试2</td>\n</tr>\n<tr>\n<td>11</td>\n<td>test3</td>\n<td>测试3</td>\n</tr>\n<tr>\n<td>12</td>\n<td>test4</td>\n<td>测试4</td>\n</tr>\n<tr>\n<td>13</td>\n<td>test5</td>\n<td>测试5</td>\n</tr>\n</tbody></table>\n<p>代码执行结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">===分页信息===</span><br><span class=\"line\">当前页码：1</span><br><span class=\"line\">每页显示数据数：5</span><br><span class=\"line\">总数据数：10</span><br><span class=\"line\">总页数：2</span><br><span class=\"line\">=============</span><br><span class=\"line\">===数据列表===</span><br><span class=\"line\">Role&#123;id=1, roleName=&#x27;SUPER_ADMIN&#x27;, note=&#x27; 超级管理员&#x27;&#125;</span><br><span class=\"line\">Role&#123;id=2, roleName=&#x27;admin&#x27;, note=&#x27;管理员&#x27;&#125;</span><br><span class=\"line\">Role&#123;id=3, roleName=&#x27;user&#x27;, note=&#x27;用户&#x27;&#125;</span><br><span class=\"line\">Role&#123;id=4, roleName=&#x27;user2&#x27;, note=&#x27;用户2&#x27;&#125;</span><br><span class=\"line\">Role&#123;id=8, roleName=&#x27;user3&#x27;, note=&#x27;用户3&#x27;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>打印的SQL信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==&gt;  Preparing: select count(*) as total from (SELECT id, role_name, note FROM role) $_paging </span><br><span class=\"line\">==&gt; Parameters: </span><br><span class=\"line\">&lt;==    Columns: total</span><br><span class=\"line\">&lt;==        Row: 10</span><br><span class=\"line\">&lt;==      Total: 1</span><br><span class=\"line\">==&gt;  Preparing: select * from (SELECT id, role_name, note FROM role) $_paging_table_limit limit ?, ? </span><br><span class=\"line\">==&gt; Parameters: 0(Integer), 5(Integer)</span><br><span class=\"line\">&lt;==    Columns: id, role_name, note</span><br><span class=\"line\">&lt;==        Row: 1, SUPER_ADMIN,  超级管理员</span><br><span class=\"line\">&lt;==        Row: 2, admin, 管理员</span><br><span class=\"line\">&lt;==        Row: 3, user, 用户</span><br><span class=\"line\">&lt;==        Row: 4, user2, 用户2</span><br><span class=\"line\">&lt;==        Row: 8, user3, 用户3</span><br><span class=\"line\">&lt;==      Total: 5</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"MyBatis插件开发流程\"><a href=\"#MyBatis插件开发流程\" class=\"headerlink\" title=\"MyBatis插件开发流程\"></a>MyBatis插件开发流程</h2><ul>\n<li><p>类实现Interceptor接口；</p>\n</li>\n<li><p>类上添加注解</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Intercepts(&#123;@Signature(type, method, args)&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>type</strong>：需要拦截的对象，只可取四大对象之一Executor.class、StatementHandler.class、ParameterHandler.class、ResultSetHandler.class。</li>\n<li><strong>method</strong>：拦截的对象方法。</li>\n<li><strong>args</strong>：拦截的对象方法参数。</li>\n</ul>\n</li>\n<li><p>实现拦截的方法Object intercept(Invocation invocation)。</p>\n</li>\n</ul>\n<h2 id=\"Interceptor接口\"><a href=\"#Interceptor接口\" class=\"headerlink\" title=\"Interceptor接口\"></a>Interceptor接口</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Interceptor &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 此方法将直接覆盖被拦截对象的原有方法</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param invocation 通过该对象可以反射调度拦截对象的方法</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     * @throws Throwable</span><br><span class=\"line\">     */</span><br><span class=\"line\">    Object intercept(Invocation invocation) throws Throwable;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 为被拦截对象生成一个代理对象，并返回它</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param target 被拦截的对象</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    Object plugin(Object target);</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 设置插件配置的参数</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param properties 插件配置的参数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    void setProperties(Properties properties);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><h3 id=\"确定拦截的方法签名\"><a href=\"#确定拦截的方法签名\" class=\"headerlink\" title=\"确定拦截的方法签名\"></a>确定拦截的方法签名</h3><p>需要在实现Interceptor接口的类上加入@Intercepts({@Signature(type, method, args)})注解才能够运行插件。</p>\n<h4 id=\"type－拦截的对象\"><a href=\"#type－拦截的对象\" class=\"headerlink\" title=\"type－拦截的对象\"></a>type－拦截的对象</h4><ul>\n<li>Executor 执行的SQL 全过程，包括组装参数、组装结果返回和执行SQL的过程等都可以拦截。</li>\n<li>StatementHandler 执行SQL的过程，拦截该对象可以重写执行SQL的过程。</li>\n<li>ParameterHandler 执行SQL 的参数组装，拦截该对象可以重写组装参数的规则。</li>\n<li>ResultSetHandler 执行结果的组装，拦截该对象可以重写组装结果的规则。</li>\n</ul>\n<p>对于分页插件，我们只需要拦截StatementHandler对象，重写SELECT类型的SQL语句，实现分页功能。</p>\n<h4 id=\"method－拦截的方法\"><a href=\"#method－拦截的方法\" class=\"headerlink\" title=\"method－拦截的方法\"></a>method－拦截的方法</h4><p>我们已经能够确定拦截的对象是StatementHandler了，现在我们要确定拦截的是哪个方法，因为StatementHandler是通过prepare方法对SQL进行预编译的，所以我们需要对prepare方法进行拦截，在这个方法执行之前，完成SQL的重新编写，加入limit。</p>\n<p><strong>StatementHandler</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface StatementHandler &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * 预编译SQL</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @param connection</span><br><span class=\"line\">   * @return</span><br><span class=\"line\">   * @throws SQLException</span><br><span class=\"line\">   */</span><br><span class=\"line\">  Statement prepare(Connection connection)</span><br><span class=\"line\">      throws SQLException;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * 设置参数</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @param statement</span><br><span class=\"line\">   * @throws SQLException</span><br><span class=\"line\">   */</span><br><span class=\"line\">  void parameterize(Statement statement)</span><br><span class=\"line\">      throws SQLException;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * 批处理</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @param statement</span><br><span class=\"line\">   * @throws SQLException</span><br><span class=\"line\">   */</span><br><span class=\"line\">  void batch(Statement statement)</span><br><span class=\"line\">      throws SQLException;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * 执行更新操作</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @param statement</span><br><span class=\"line\">   * @return 返回影响行数</span><br><span class=\"line\">   * @throws SQLException</span><br><span class=\"line\">   */</span><br><span class=\"line\">  int update(Statement statement)</span><br><span class=\"line\">      throws SQLException;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * 执行查询操作，将结果交给ResultHandler进行结果的组装</span><br><span class=\"line\">   *</span><br><span class=\"line\">   * @param statement</span><br><span class=\"line\">   * @param resultHandler</span><br><span class=\"line\">   * @param &lt;E&gt;</span><br><span class=\"line\">   * @return 返回查询的数据列表</span><br><span class=\"line\">   * @throws SQLException</span><br><span class=\"line\">   */</span><br><span class=\"line\">  &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler)</span><br><span class=\"line\">      throws SQLException;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * 得到绑定的sql</span><br><span class=\"line\">   * </span><br><span class=\"line\">   * @return</span><br><span class=\"line\">   */</span><br><span class=\"line\">  BoundSql getBoundSql();</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * 得到参数处理器</span><br><span class=\"line\">   * </span><br><span class=\"line\">   * @return</span><br><span class=\"line\">   */</span><br><span class=\"line\">  ParameterHandler getParameterHandler();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"args－拦截的参数\"><a href=\"#args－拦截的参数\" class=\"headerlink\" title=\"args－拦截的参数\"></a>args－拦截的参数</h4><p>args是一个Class类型的数组，表示的是被拦截方法的参数列表。由于我们已经确定了拦截的是StatementHandler的prepare方法，而该方法只有一个参数Connection，所以我们只需要拦截这一个参数即可。</p>\n<h3 id=\"实现拦截方法\"><a href=\"#实现拦截方法\" class=\"headerlink\" title=\"实现拦截方法\"></a>实现拦截方法</h3><p>定义一个封装分页参数的类Page</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Page &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 当前页码</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private Integer pageIndex;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 每页数据条数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private Integer pageSize;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 总数据数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private Integer total;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 总页数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private Integer totalPage;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Page() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Page(Integer pageIndex, Integer pageSize) &#123;</span><br><span class=\"line\">        this.pageIndex = pageIndex;</span><br><span class=\"line\">        this.pageSize = pageSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t// 省略get、set方法...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现插件分页的功能</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.apache.ibatis.executor.parameter.ParameterHandler;</span><br><span class=\"line\">import org.apache.ibatis.executor.statement.StatementHandler;</span><br><span class=\"line\">import org.apache.ibatis.mapping.BoundSql;</span><br><span class=\"line\">import org.apache.ibatis.mapping.MappedStatement;</span><br><span class=\"line\">import org.apache.ibatis.plugin.*;</span><br><span class=\"line\">import org.apache.ibatis.reflection.MetaObject;</span><br><span class=\"line\">import org.apache.ibatis.reflection.SystemMetaObject;</span><br><span class=\"line\">import org.apache.ibatis.scripting.defaults.DefaultParameterHandler;</span><br><span class=\"line\">import org.apache.ibatis.session.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.sql.Connection;</span><br><span class=\"line\">import java.sql.PreparedStatement;</span><br><span class=\"line\">import java.sql.ResultSet;</span><br><span class=\"line\">import java.sql.SQLException;</span><br><span class=\"line\">import java.util.Map;</span><br><span class=\"line\">import java.util.Properties;</span><br><span class=\"line\">import java.util.Set;</span><br><span class=\"line\"></span><br><span class=\"line\">@Intercepts(&#123;@Signature(</span><br><span class=\"line\">        type = StatementHandler.class,</span><br><span class=\"line\">        method = &quot;prepare&quot;,</span><br><span class=\"line\">        args = &#123;Connection.class&#125;</span><br><span class=\"line\">)&#125;)</span><br><span class=\"line\">public class PagingPlugin implements Interceptor &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 默认页码</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private Integer defaultPageIndex;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 默认每页数据条数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private Integer defaultPageSize;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class=\"line\">        StatementHandler statementHandler = getUnProxyObject(invocation);</span><br><span class=\"line\">        MetaObject metaObject = SystemMetaObject.forObject(statementHandler);</span><br><span class=\"line\">        String sql = getSql(metaObject);</span><br><span class=\"line\">        if (!checkSelect(sql)) &#123;</span><br><span class=\"line\">            // 不是select语句，进入责任链下一层</span><br><span class=\"line\">            return invocation.proceed();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        BoundSql boundSql = (BoundSql) metaObject.getValue(&quot;delegate.boundSql&quot;);</span><br><span class=\"line\">        Object parameterObject = boundSql.getParameterObject();</span><br><span class=\"line\">        Page page = getPage(parameterObject);</span><br><span class=\"line\">        if (page == null) &#123;</span><br><span class=\"line\">            // 没有传入page对象，不执行分页处理，进入责任链下一层</span><br><span class=\"line\">            return invocation.proceed();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 设置分页默认值</span><br><span class=\"line\">        if (page.getPageIndex() == null) &#123;</span><br><span class=\"line\">            page.setPageIndex(this.defaultPageIndex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (page.getPageSize() == null) &#123;</span><br><span class=\"line\">            page.setPageSize(this.defaultPageSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 设置分页总数，数据总数</span><br><span class=\"line\">        setTotalToPage(page, invocation, metaObject, boundSql);</span><br><span class=\"line\">        // 校验分页参数</span><br><span class=\"line\">        checkPage(page);</span><br><span class=\"line\">        return changeSql(invocation, metaObject, boundSql, page);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Object plugin(Object target) &#123;</span><br><span class=\"line\">        // 生成代理对象</span><br><span class=\"line\">        return Plugin.wrap(target, this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setProperties(Properties properties) &#123;</span><br><span class=\"line\">        // 初始化配置的默认页码，无配置则默认1</span><br><span class=\"line\">        this.defaultPageIndex = Integer.parseInt(properties.getProperty(&quot;default.pageIndex&quot;, &quot;1&quot;));</span><br><span class=\"line\">        // 初始化配置的默认数据条数，无配置则默认20</span><br><span class=\"line\">        this.defaultPageSize = Integer.parseInt(properties.getProperty(&quot;default.pageSize&quot;, &quot;20&quot;));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 从代理对象中分离出真实对象</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param invocation</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private StatementHandler getUnProxyObject(Invocation invocation) &#123;</span><br><span class=\"line\">        // 取出被拦截的对象</span><br><span class=\"line\">        StatementHandler statementHandler = (StatementHandler) invocation.getTarget();</span><br><span class=\"line\">        MetaObject metaStmtHandler = SystemMetaObject.forObject(statementHandler);</span><br><span class=\"line\">        Object object = null;</span><br><span class=\"line\">        // 分离代理对象</span><br><span class=\"line\">        while (metaStmtHandler.hasGetter(&quot;h&quot;)) &#123;</span><br><span class=\"line\">            object = metaStmtHandler.getValue(&quot;h&quot;);</span><br><span class=\"line\">            metaStmtHandler = SystemMetaObject.forObject(object);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return object == null ? statementHandler : (StatementHandler) object;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 判断是否是select语句</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param sql</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private boolean checkSelect(String sql) &#123;</span><br><span class=\"line\">        // 去除sql的前后空格，并将sql转换成小写</span><br><span class=\"line\">        sql = sql.trim().toLowerCase();</span><br><span class=\"line\">        return sql.indexOf(&quot;select&quot;) == 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 获取分页参数</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param parameterObject</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private Page getPage(Object parameterObject) &#123;</span><br><span class=\"line\">        if (parameterObject == null) &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (parameterObject instanceof Map) &#123;</span><br><span class=\"line\">            // 如果传入的参数是map类型的，则遍历map取出Page对象</span><br><span class=\"line\">            Map&lt;String, Object&gt; parameMap = (Map&lt;String, Object&gt;) parameterObject;</span><br><span class=\"line\">            Set&lt;String&gt; keySet = parameMap.keySet();</span><br><span class=\"line\">            for (String key : keySet) &#123;</span><br><span class=\"line\">                Object value = parameMap.get(key);</span><br><span class=\"line\">                if (value instanceof Page) &#123;</span><br><span class=\"line\">                    // 返回Page对象</span><br><span class=\"line\">                    return (Page) value;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else if (parameterObject instanceof Page) &#123;</span><br><span class=\"line\">            // 如果传入的是Page类型，则直接返回该对象</span><br><span class=\"line\">            return (Page) parameterObject;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 初步判断并没有传入Page类型的参数，返回null</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 获取数据总数</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param invocation</span><br><span class=\"line\">     * @param metaObject</span><br><span class=\"line\">     * @param boundSql</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private int getTotal(Invocation invocation, MetaObject metaObject, BoundSql boundSql) &#123;</span><br><span class=\"line\">        // 获取当前的mappedStatement对象</span><br><span class=\"line\">        MappedStatement mappedStatement = (MappedStatement) metaObject.getValue(&quot;delegate.mappedStatement&quot;);</span><br><span class=\"line\">        // 获取配置对象</span><br><span class=\"line\">        Configuration configuration = mappedStatement.getConfiguration();</span><br><span class=\"line\">        // 获取当前需要执行的sql</span><br><span class=\"line\">        String sql = getSql(metaObject);</span><br><span class=\"line\">        // 改写sql语句，实现返回数据总数 $_paging取名是为了防止数据库表重名</span><br><span class=\"line\">        String countSql = &quot;select count(*) as total from (&quot; + sql + &quot;) $_paging&quot;;</span><br><span class=\"line\">        // 获取拦截方法参数，拦截的是connection对象</span><br><span class=\"line\">        Connection connection = (Connection) invocation.getArgs()[0];</span><br><span class=\"line\">        PreparedStatement pstmt = null;</span><br><span class=\"line\">        int total = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            // 预编译查询数据总数的sql语句</span><br><span class=\"line\">            pstmt = connection.prepareStatement(countSql);</span><br><span class=\"line\">            // 构建boundSql对象</span><br><span class=\"line\">            BoundSql countBoundSql = new BoundSql(configuration, countSql, boundSql.getParameterMappings(),</span><br><span class=\"line\">                    boundSql.getParameterObject());</span><br><span class=\"line\">            // 构建parameterHandler用于设置sql参数</span><br><span class=\"line\">            ParameterHandler parameterHandler = new DefaultParameterHandler(mappedStatement, boundSql.getParameterObject(),</span><br><span class=\"line\">                    countBoundSql);</span><br><span class=\"line\">            // 设置sql参数</span><br><span class=\"line\">            parameterHandler.setParameters(pstmt);</span><br><span class=\"line\">            //执行查询</span><br><span class=\"line\">            ResultSet rs = pstmt.executeQuery();</span><br><span class=\"line\">            while (rs.next()) &#123;</span><br><span class=\"line\">                total = rs.getInt(&quot;total&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (SQLException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            if (pstmt != null) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    pstmt.close();</span><br><span class=\"line\">                &#125; catch (SQLException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 返回总数据数</span><br><span class=\"line\">        return total;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 设置总数据数、总页数</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param page</span><br><span class=\"line\">     * @param invocation</span><br><span class=\"line\">     * @param metaObject</span><br><span class=\"line\">     * @param boundSql</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void setTotalToPage(Page page, Invocation invocation, MetaObject metaObject, BoundSql boundSql) &#123;</span><br><span class=\"line\">        // 总数据数</span><br><span class=\"line\">        int total = getTotal(invocation, metaObject, boundSql);</span><br><span class=\"line\">        // 计算总页数</span><br><span class=\"line\">        int totalPage = total / page.getPageSize();</span><br><span class=\"line\">        if (total % page.getPageSize() != 0) &#123;</span><br><span class=\"line\">            totalPage = totalPage + 1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        page.setTotal(total);</span><br><span class=\"line\">        page.setTotalPage(totalPage);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 校验分页参数</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param page</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void checkPage(Page page) &#123;</span><br><span class=\"line\">        // 如果当前页码大于总页数，抛出异常</span><br><span class=\"line\">        if (page.getPageIndex() &gt; page.getTotalPage()) &#123;</span><br><span class=\"line\">            throw new RuntimeException(&quot;当前页码［&quot; + page.getPageIndex() + &quot;］大于总页数［&quot; + page.getTotalPage() + &quot;］&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 如果当前页码小于总页数，抛出异常</span><br><span class=\"line\">        if (page.getPageIndex() &lt; 1) &#123;</span><br><span class=\"line\">            throw new RuntimeException(&quot;当前页码［&quot; + page.getPageIndex() + &quot;］小于［1］&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 修改当前查询的sql</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param invocation</span><br><span class=\"line\">     * @param metaObject</span><br><span class=\"line\">     * @param boundSql</span><br><span class=\"line\">     * @param page</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private Object changeSql(Invocation invocation, MetaObject metaObject, BoundSql boundSql, Page page) throws Exception &#123;</span><br><span class=\"line\">        // 获取当前查询的sql</span><br><span class=\"line\">        String sql = getSql(metaObject);</span><br><span class=\"line\">        // 修改sql，$_paging_table_limit取名是为了防止数据库表重名</span><br><span class=\"line\">        String newSql = &quot;select * from (&quot; + sql + &quot;) $_paging_table_limit limit ?, ?&quot;;</span><br><span class=\"line\">        // 设置当前sql为修改后的sql</span><br><span class=\"line\">        setSql(metaObject, newSql);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 获取PreparedStatement对象</span><br><span class=\"line\">        PreparedStatement pstmt = (PreparedStatement) invocation.proceed();</span><br><span class=\"line\">        // 获取sql的总参数个数</span><br><span class=\"line\">        int parameCount = pstmt.getParameterMetaData().getParameterCount();</span><br><span class=\"line\">        // 设置分页参数</span><br><span class=\"line\">        pstmt.setInt(parameCount - 1, (page.getPageIndex() - 1) * page.getPageSize());</span><br><span class=\"line\">        pstmt.setInt(parameCount, page.getPageSize());</span><br><span class=\"line\"></span><br><span class=\"line\">        return pstmt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 获取当前查询的sql</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param metaObject</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private String getSql(MetaObject metaObject) &#123;</span><br><span class=\"line\">        return (String) metaObject.getValue(&quot;delegate.boundSql.sql&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 设置当前查询的sql</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param metaObject</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void setSql(MetaObject metaObject, String sql) &#123;</span><br><span class=\"line\">        metaObject.setValue(&quot;delegate.boundSql.sql&quot;, sql);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置分页插件\"><a href=\"#配置分页插件\" class=\"headerlink\" title=\"配置分页插件\"></a>配置分页插件</h3><p>在mybatis-config.xml配置文件中配置自定义的分页插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;plugins&gt;</span><br><span class=\"line\">\t&lt;plugin interceptor=&quot;PagingPlugin&quot;&gt;</span><br><span class=\"line\">\t\t&lt;property name=&quot;default.pageIndex&quot; value=&quot;1&quot;/&gt;</span><br><span class=\"line\">\t\t&lt;property name=&quot;default.pageSize&quot; value=&quot;20&quot;/&gt;</span><br><span class=\"line\">\t&lt;/plugin&gt;</span><br><span class=\"line\">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实现DAO\"><a href=\"#实现DAO\" class=\"headerlink\" title=\"实现DAO\"></a>实现DAO</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Role &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   private Long id;</span><br><span class=\"line\">   private String roleName;</span><br><span class=\"line\">   private String note;</span><br><span class=\"line\">   // 省略get、set...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义Mapper接口，通过分页对象查询角色列表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface RoleMapper &#123;</span><br><span class=\"line\">    List&lt;Role&gt; listRoleByPage(Page page);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义Mapper.xml编写查询的SQL语句</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;mapper namespace=&quot;RoleMapper&quot;&gt;</span><br><span class=\"line\">    &lt;select id=&quot;listRoleByPage&quot; resultType=&quot;Role&quot;&gt;</span><br><span class=\"line\">        SELECT id, role_name, note FROM role</span><br><span class=\"line\">    &lt;/select&gt;</span><br><span class=\"line\">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试分页插件\"><a href=\"#测试分页插件\" class=\"headerlink\" title=\"测试分页插件\"></a>测试分页插件</h3><p>测试代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test() &#123;</span><br><span class=\"line\">\tInputStream inputStream = null;</span><br><span class=\"line\">\tSqlSessionFactory sqlSessionFactory;</span><br><span class=\"line\">\tSqlSession sqlSession = null;</span><br><span class=\"line\">\ttry &#123;</span><br><span class=\"line\">\t\tinputStream = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class=\"line\">\t\tsqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class=\"line\">\t\tsqlSession = sqlSessionFactory.openSession();</span><br><span class=\"line\">\t\tRoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);</span><br><span class=\"line\">\t\t// 分页参数，从第一页开始，每页显示5条数据</span><br><span class=\"line\">\t\tPage page = new Page(1, 5);</span><br><span class=\"line\">\t\tList&lt;Role&gt; roleList = roleMapper.listRoleByPage(page);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;===分页信息===&quot;);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;当前页码：&quot; + page.getPageIndex());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;每页显示数据数：&quot; + page.getPageSize());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;总数据数：&quot; + page.getTotal());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;总页数：&quot; + page.getTotalPage());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;=============&quot;);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;===数据列表===&quot;);</span><br><span class=\"line\">\t\tfor (Role role : roleList) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(role);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; catch (IOException e) &#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125; finally &#123;</span><br><span class=\"line\">\t\tif (sqlSession != null) &#123;</span><br><span class=\"line\">\t\t\tsqlSession.close();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif (inputStream != null) &#123;</span><br><span class=\"line\">\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\tinputStream.close();</span><br><span class=\"line\">\t\t\t&#125; catch (IOException e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>数据库role表中的全部数据信息</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>role_name</th>\n<th>note</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>SUPER_ADMIN</td>\n<td>超级管理员</td>\n</tr>\n<tr>\n<td>2</td>\n<td>admin</td>\n<td>管理员</td>\n</tr>\n<tr>\n<td>3</td>\n<td>user</td>\n<td>用户</td>\n</tr>\n<tr>\n<td>4</td>\n<td>user2</td>\n<td>用户2</td>\n</tr>\n<tr>\n<td>8</td>\n<td>user3</td>\n<td>用户3</td>\n</tr>\n<tr>\n<td>9</td>\n<td>test</td>\n<td>测试</td>\n</tr>\n<tr>\n<td>10</td>\n<td>test2</td>\n<td>测试2</td>\n</tr>\n<tr>\n<td>11</td>\n<td>test3</td>\n<td>测试3</td>\n</tr>\n<tr>\n<td>12</td>\n<td>test4</td>\n<td>测试4</td>\n</tr>\n<tr>\n<td>13</td>\n<td>test5</td>\n<td>测试5</td>\n</tr>\n</tbody></table>\n<p>代码执行结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">===分页信息===</span><br><span class=\"line\">当前页码：1</span><br><span class=\"line\">每页显示数据数：5</span><br><span class=\"line\">总数据数：10</span><br><span class=\"line\">总页数：2</span><br><span class=\"line\">=============</span><br><span class=\"line\">===数据列表===</span><br><span class=\"line\">Role&#123;id=1, roleName=&#x27;SUPER_ADMIN&#x27;, note=&#x27; 超级管理员&#x27;&#125;</span><br><span class=\"line\">Role&#123;id=2, roleName=&#x27;admin&#x27;, note=&#x27;管理员&#x27;&#125;</span><br><span class=\"line\">Role&#123;id=3, roleName=&#x27;user&#x27;, note=&#x27;用户&#x27;&#125;</span><br><span class=\"line\">Role&#123;id=4, roleName=&#x27;user2&#x27;, note=&#x27;用户2&#x27;&#125;</span><br><span class=\"line\">Role&#123;id=8, roleName=&#x27;user3&#x27;, note=&#x27;用户3&#x27;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>打印的SQL信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==&gt;  Preparing: select count(*) as total from (SELECT id, role_name, note FROM role) $_paging </span><br><span class=\"line\">==&gt; Parameters: </span><br><span class=\"line\">&lt;==    Columns: total</span><br><span class=\"line\">&lt;==        Row: 10</span><br><span class=\"line\">&lt;==      Total: 1</span><br><span class=\"line\">==&gt;  Preparing: select * from (SELECT id, role_name, note FROM role) $_paging_table_limit limit ?, ? </span><br><span class=\"line\">==&gt; Parameters: 0(Integer), 5(Integer)</span><br><span class=\"line\">&lt;==    Columns: id, role_name, note</span><br><span class=\"line\">&lt;==        Row: 1, SUPER_ADMIN,  超级管理员</span><br><span class=\"line\">&lt;==        Row: 2, admin, 管理员</span><br><span class=\"line\">&lt;==        Row: 3, user, 用户</span><br><span class=\"line\">&lt;==        Row: 4, user2, 用户2</span><br><span class=\"line\">&lt;==        Row: 8, user3, 用户3</span><br><span class=\"line\">&lt;==      Total: 5</span><br></pre></td></tr></table></figure>"},{"title":"Run-Time-Data-Areas","date":"2022-03-09T09:40:20.000Z","_content":"\n\n\n## The pc Register - 程序计数器\n\n线程私有内存，保存**当前线程所执行的字节码的行号指示器**，这里和计算机组成原理中的计数器不太一样，计组中的 PC 指的是**下一条要执行的指令**的地址。JVM 中常有多个线程执行，故每条线程都需要有一个独立的程序计数器。\n\n如果线程执行的是 Java 方法，哪儿计数器记录的就是正在执行的虚拟机字节码指令的地址；如果执行的是 Native 方法，这个计数器则为空。\n\nP.S. 这块内存无OutOfMemoryError\n\n## Java Virtual Machine Stacks - Java 虚拟机栈\n\n线程私有，虚拟机栈描述的是 Java 方法执行的内存模型，每个方法在执行时会创建一个栈帧，栈帧中保存有局部变量表、操作数栈、动态链接和方法出口等。粗略来讲 Java 内存区分为堆和栈，实际上『栈』指的往往是虚拟机栈中的局部变量表部分。\n\n局部变量表中存放了编译期可知的各种基本数据类型、对象引用类型和 returnAddress 类型。方法运行期间局部变量表大小不变。\n\n## Native Method Stacks - 本地方法栈\n\n和虚拟机栈类似，不过区别在于虚拟机栈为 Java 方法（字节码）服务，而本地方法栈为 Native 方法服务（类似 C 语言中的栈）。具体实现可将这两者合二为一。\n\n## Heap - 堆\n\n堆是被所有线程共享的一块内存区域。一般来说所有的对象实例和数组都要在堆上分配，但一些优化技术导致不一定所有对象实例都在堆上分配。\n\n## Method Area - 方法区\n\n各线程共享的一块内存区域，和操作系统中进程中的『文本段』有些类似，用于存储虚拟机加载的类信息、常量、静态常量和即时编译器编译后的代码数据等。\n\n## Run-Time Constant Pool - 运行时常量池\n\n这一部分是方法区的一部分，用于保存 Class 文件中编译期生成的字面值和符号引用。\n\n## 直接内存\n\n这一部分并不是虚拟机运行时的数据区域，用于 Native 函数分配堆外内存，提高性能用（不必在操作系统堆和 Java 堆复制数据）。","source":"_posts/Run-Time-Data-Areas.md","raw":"---\ntitle: Run-Time-Data-Areas\ndate: 2022-03-09 17:40:20\ntags: Java\n---\n\n\n\n## The pc Register - 程序计数器\n\n线程私有内存，保存**当前线程所执行的字节码的行号指示器**，这里和计算机组成原理中的计数器不太一样，计组中的 PC 指的是**下一条要执行的指令**的地址。JVM 中常有多个线程执行，故每条线程都需要有一个独立的程序计数器。\n\n如果线程执行的是 Java 方法，哪儿计数器记录的就是正在执行的虚拟机字节码指令的地址；如果执行的是 Native 方法，这个计数器则为空。\n\nP.S. 这块内存无OutOfMemoryError\n\n## Java Virtual Machine Stacks - Java 虚拟机栈\n\n线程私有，虚拟机栈描述的是 Java 方法执行的内存模型，每个方法在执行时会创建一个栈帧，栈帧中保存有局部变量表、操作数栈、动态链接和方法出口等。粗略来讲 Java 内存区分为堆和栈，实际上『栈』指的往往是虚拟机栈中的局部变量表部分。\n\n局部变量表中存放了编译期可知的各种基本数据类型、对象引用类型和 returnAddress 类型。方法运行期间局部变量表大小不变。\n\n## Native Method Stacks - 本地方法栈\n\n和虚拟机栈类似，不过区别在于虚拟机栈为 Java 方法（字节码）服务，而本地方法栈为 Native 方法服务（类似 C 语言中的栈）。具体实现可将这两者合二为一。\n\n## Heap - 堆\n\n堆是被所有线程共享的一块内存区域。一般来说所有的对象实例和数组都要在堆上分配，但一些优化技术导致不一定所有对象实例都在堆上分配。\n\n## Method Area - 方法区\n\n各线程共享的一块内存区域，和操作系统中进程中的『文本段』有些类似，用于存储虚拟机加载的类信息、常量、静态常量和即时编译器编译后的代码数据等。\n\n## Run-Time Constant Pool - 运行时常量池\n\n这一部分是方法区的一部分，用于保存 Class 文件中编译期生成的字面值和符号引用。\n\n## 直接内存\n\n这一部分并不是虚拟机运行时的数据区域，用于 Native 函数分配堆外内存，提高性能用（不必在操作系统堆和 Java 堆复制数据）。","slug":"Run-Time-Data-Areas","published":1,"updated":"2022-03-10T07:01:35.270Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0vrkoq7000a10ln3itbec95","content":"<h2 id=\"The-pc-Register-程序计数器\"><a href=\"#The-pc-Register-程序计数器\" class=\"headerlink\" title=\"The pc Register - 程序计数器\"></a>The pc Register - 程序计数器</h2><p>线程私有内存，保存<strong>当前线程所执行的字节码的行号指示器</strong>，这里和计算机组成原理中的计数器不太一样，计组中的 PC 指的是<strong>下一条要执行的指令</strong>的地址。JVM 中常有多个线程执行，故每条线程都需要有一个独立的程序计数器。</p>\n<p>如果线程执行的是 Java 方法，哪儿计数器记录的就是正在执行的虚拟机字节码指令的地址；如果执行的是 Native 方法，这个计数器则为空。</p>\n<p>P.S. 这块内存无OutOfMemoryError</p>\n<h2 id=\"Java-Virtual-Machine-Stacks-Java-虚拟机栈\"><a href=\"#Java-Virtual-Machine-Stacks-Java-虚拟机栈\" class=\"headerlink\" title=\"Java Virtual Machine Stacks - Java 虚拟机栈\"></a>Java Virtual Machine Stacks - Java 虚拟机栈</h2><p>线程私有，虚拟机栈描述的是 Java 方法执行的内存模型，每个方法在执行时会创建一个栈帧，栈帧中保存有局部变量表、操作数栈、动态链接和方法出口等。粗略来讲 Java 内存区分为堆和栈，实际上『栈』指的往往是虚拟机栈中的局部变量表部分。</p>\n<p>局部变量表中存放了编译期可知的各种基本数据类型、对象引用类型和 returnAddress 类型。方法运行期间局部变量表大小不变。</p>\n<h2 id=\"Native-Method-Stacks-本地方法栈\"><a href=\"#Native-Method-Stacks-本地方法栈\" class=\"headerlink\" title=\"Native Method Stacks - 本地方法栈\"></a>Native Method Stacks - 本地方法栈</h2><p>和虚拟机栈类似，不过区别在于虚拟机栈为 Java 方法（字节码）服务，而本地方法栈为 Native 方法服务（类似 C 语言中的栈）。具体实现可将这两者合二为一。</p>\n<h2 id=\"Heap-堆\"><a href=\"#Heap-堆\" class=\"headerlink\" title=\"Heap - 堆\"></a>Heap - 堆</h2><p>堆是被所有线程共享的一块内存区域。一般来说所有的对象实例和数组都要在堆上分配，但一些优化技术导致不一定所有对象实例都在堆上分配。</p>\n<h2 id=\"Method-Area-方法区\"><a href=\"#Method-Area-方法区\" class=\"headerlink\" title=\"Method Area - 方法区\"></a>Method Area - 方法区</h2><p>各线程共享的一块内存区域，和操作系统中进程中的『文本段』有些类似，用于存储虚拟机加载的类信息、常量、静态常量和即时编译器编译后的代码数据等。</p>\n<h2 id=\"Run-Time-Constant-Pool-运行时常量池\"><a href=\"#Run-Time-Constant-Pool-运行时常量池\" class=\"headerlink\" title=\"Run-Time Constant Pool - 运行时常量池\"></a>Run-Time Constant Pool - 运行时常量池</h2><p>这一部分是方法区的一部分，用于保存 Class 文件中编译期生成的字面值和符号引用。</p>\n<h2 id=\"直接内存\"><a href=\"#直接内存\" class=\"headerlink\" title=\"直接内存\"></a>直接内存</h2><p>这一部分并不是虚拟机运行时的数据区域，用于 Native 函数分配堆外内存，提高性能用（不必在操作系统堆和 Java 堆复制数据）。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"The-pc-Register-程序计数器\"><a href=\"#The-pc-Register-程序计数器\" class=\"headerlink\" title=\"The pc Register - 程序计数器\"></a>The pc Register - 程序计数器</h2><p>线程私有内存，保存<strong>当前线程所执行的字节码的行号指示器</strong>，这里和计算机组成原理中的计数器不太一样，计组中的 PC 指的是<strong>下一条要执行的指令</strong>的地址。JVM 中常有多个线程执行，故每条线程都需要有一个独立的程序计数器。</p>\n<p>如果线程执行的是 Java 方法，哪儿计数器记录的就是正在执行的虚拟机字节码指令的地址；如果执行的是 Native 方法，这个计数器则为空。</p>\n<p>P.S. 这块内存无OutOfMemoryError</p>\n<h2 id=\"Java-Virtual-Machine-Stacks-Java-虚拟机栈\"><a href=\"#Java-Virtual-Machine-Stacks-Java-虚拟机栈\" class=\"headerlink\" title=\"Java Virtual Machine Stacks - Java 虚拟机栈\"></a>Java Virtual Machine Stacks - Java 虚拟机栈</h2><p>线程私有，虚拟机栈描述的是 Java 方法执行的内存模型，每个方法在执行时会创建一个栈帧，栈帧中保存有局部变量表、操作数栈、动态链接和方法出口等。粗略来讲 Java 内存区分为堆和栈，实际上『栈』指的往往是虚拟机栈中的局部变量表部分。</p>\n<p>局部变量表中存放了编译期可知的各种基本数据类型、对象引用类型和 returnAddress 类型。方法运行期间局部变量表大小不变。</p>\n<h2 id=\"Native-Method-Stacks-本地方法栈\"><a href=\"#Native-Method-Stacks-本地方法栈\" class=\"headerlink\" title=\"Native Method Stacks - 本地方法栈\"></a>Native Method Stacks - 本地方法栈</h2><p>和虚拟机栈类似，不过区别在于虚拟机栈为 Java 方法（字节码）服务，而本地方法栈为 Native 方法服务（类似 C 语言中的栈）。具体实现可将这两者合二为一。</p>\n<h2 id=\"Heap-堆\"><a href=\"#Heap-堆\" class=\"headerlink\" title=\"Heap - 堆\"></a>Heap - 堆</h2><p>堆是被所有线程共享的一块内存区域。一般来说所有的对象实例和数组都要在堆上分配，但一些优化技术导致不一定所有对象实例都在堆上分配。</p>\n<h2 id=\"Method-Area-方法区\"><a href=\"#Method-Area-方法区\" class=\"headerlink\" title=\"Method Area - 方法区\"></a>Method Area - 方法区</h2><p>各线程共享的一块内存区域，和操作系统中进程中的『文本段』有些类似，用于存储虚拟机加载的类信息、常量、静态常量和即时编译器编译后的代码数据等。</p>\n<h2 id=\"Run-Time-Constant-Pool-运行时常量池\"><a href=\"#Run-Time-Constant-Pool-运行时常量池\" class=\"headerlink\" title=\"Run-Time Constant Pool - 运行时常量池\"></a>Run-Time Constant Pool - 运行时常量池</h2><p>这一部分是方法区的一部分，用于保存 Class 文件中编译期生成的字面值和符号引用。</p>\n<h2 id=\"直接内存\"><a href=\"#直接内存\" class=\"headerlink\" title=\"直接内存\"></a>直接内存</h2><p>这一部分并不是虚拟机运行时的数据区域，用于 Native 函数分配堆外内存，提高性能用（不必在操作系统堆和 Java 堆复制数据）。</p>\n"},{"title":"Observer","date":"2022-03-11T02:06:15.000Z","_content":"\n\n\n## 观察者模式结构\n\n观察者模式（Observer）又称发布-订阅模式（Publish-Subscribe：Pub/Sub），它是一种通知机制。\n\n1. **发布者** （Publisher） 向对应的订阅者发送事件，发布者内部有一个订阅者列表的数据结构，支持添加和移除订阅者。\n2. **订阅者** （Subscriber） 声明了通知接口。 在绝大多数情况下， 该接口仅包含一个方法，用来处理发布的事件。\n3. **具体订阅者** （Concrete Subscribers） 具体订阅者类实现了订阅者的接口，不同事件的处理逻辑。\n4. **事件**（Event）声明了事件接口。一个标识接口，标识是一个事件。\n5. **具体事件**（Concrete Event）具体事件，当事件通过发布者去发布的时候，发布者会遍历订阅列表执行对应的订阅者的方法。\n\n订阅者也叫观察者，被观察者就是发布的具体事件。在消息队列中，利用了发布-订阅模式工作，被观察者对应消息发送者（生产者），订阅者对应的是消费者。消息队列中内部有发布者的功能，订阅者将自己注册到里面，可以接收对应的系统发送的消息。 [参考代码](https://github.com/kangpanwork/Observer)\n\n","source":"_posts/Observer.md","raw":"---\ntitle: Observer\ndate: 2022-03-11 10:06:15\ntags: Design\n---\n\n\n\n## 观察者模式结构\n\n观察者模式（Observer）又称发布-订阅模式（Publish-Subscribe：Pub/Sub），它是一种通知机制。\n\n1. **发布者** （Publisher） 向对应的订阅者发送事件，发布者内部有一个订阅者列表的数据结构，支持添加和移除订阅者。\n2. **订阅者** （Subscriber） 声明了通知接口。 在绝大多数情况下， 该接口仅包含一个方法，用来处理发布的事件。\n3. **具体订阅者** （Concrete Subscribers） 具体订阅者类实现了订阅者的接口，不同事件的处理逻辑。\n4. **事件**（Event）声明了事件接口。一个标识接口，标识是一个事件。\n5. **具体事件**（Concrete Event）具体事件，当事件通过发布者去发布的时候，发布者会遍历订阅列表执行对应的订阅者的方法。\n\n订阅者也叫观察者，被观察者就是发布的具体事件。在消息队列中，利用了发布-订阅模式工作，被观察者对应消息发送者（生产者），订阅者对应的是消费者。消息队列中内部有发布者的功能，订阅者将自己注册到里面，可以接收对应的系统发送的消息。 [参考代码](https://github.com/kangpanwork/Observer)\n\n","slug":"Observer","published":1,"updated":"2022-03-11T10:00:09.676Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0vrkoq8000b10lnakymd3a5","content":"<h2 id=\"观察者模式结构\"><a href=\"#观察者模式结构\" class=\"headerlink\" title=\"观察者模式结构\"></a>观察者模式结构</h2><p>观察者模式（Observer）又称发布-订阅模式（Publish-Subscribe：Pub/Sub），它是一种通知机制。</p>\n<ol>\n<li><strong>发布者</strong> （Publisher） 向对应的订阅者发送事件，发布者内部有一个订阅者列表的数据结构，支持添加和移除订阅者。</li>\n<li><strong>订阅者</strong> （Subscriber） 声明了通知接口。 在绝大多数情况下， 该接口仅包含一个方法，用来处理发布的事件。</li>\n<li><strong>具体订阅者</strong> （Concrete Subscribers） 具体订阅者类实现了订阅者的接口，不同事件的处理逻辑。</li>\n<li><strong>事件</strong>（Event）声明了事件接口。一个标识接口，标识是一个事件。</li>\n<li><strong>具体事件</strong>（Concrete Event）具体事件，当事件通过发布者去发布的时候，发布者会遍历订阅列表执行对应的订阅者的方法。</li>\n</ol>\n<p>订阅者也叫观察者，被观察者就是发布的具体事件。在消息队列中，利用了发布-订阅模式工作，被观察者对应消息发送者（生产者），订阅者对应的是消费者。消息队列中内部有发布者的功能，订阅者将自己注册到里面，可以接收对应的系统发送的消息。 <a href=\"https://github.com/kangpanwork/Observer\">参考代码</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"观察者模式结构\"><a href=\"#观察者模式结构\" class=\"headerlink\" title=\"观察者模式结构\"></a>观察者模式结构</h2><p>观察者模式（Observer）又称发布-订阅模式（Publish-Subscribe：Pub/Sub），它是一种通知机制。</p>\n<ol>\n<li><strong>发布者</strong> （Publisher） 向对应的订阅者发送事件，发布者内部有一个订阅者列表的数据结构，支持添加和移除订阅者。</li>\n<li><strong>订阅者</strong> （Subscriber） 声明了通知接口。 在绝大多数情况下， 该接口仅包含一个方法，用来处理发布的事件。</li>\n<li><strong>具体订阅者</strong> （Concrete Subscribers） 具体订阅者类实现了订阅者的接口，不同事件的处理逻辑。</li>\n<li><strong>事件</strong>（Event）声明了事件接口。一个标识接口，标识是一个事件。</li>\n<li><strong>具体事件</strong>（Concrete Event）具体事件，当事件通过发布者去发布的时候，发布者会遍历订阅列表执行对应的订阅者的方法。</li>\n</ol>\n<p>订阅者也叫观察者，被观察者就是发布的具体事件。在消息队列中，利用了发布-订阅模式工作，被观察者对应消息发送者（生产者），订阅者对应的是消费者。消息队列中内部有发布者的功能，订阅者将自己注册到里面，可以接收对应的系统发送的消息。 <a href=\"https://github.com/kangpanwork/Observer\">参考代码</a></p>\n"},{"title":"俞敏洪在同济大学的的演讲","date":"2022-03-17T07:27:31.000Z","_content":"\n同济大学的同学们大家晚上好！ \n\n\n  其实人活着就挺好，至于生命有没有意义另当别论。活着每天都会有太阳升起来，每天都会看到太阳落下去。你就可以看到朝霞，看到晚霞，看到月亮升起和落下，看到满天的繁星，这就是活着的最美好的意义所在。 \n\n\n  没想到同济大学的同学们把我如此“高大”的形象放在大屏幕上，这就是理想与现实的差距。所以我相信同学们看到我的第一眼一定感到非常的失望。实际上，每一 个人都是非常普通的，我们很多时候会发现生命中非常重要的东西跟我们未来的幸福和成功其实没有太多的联系。比如，有人认为，相貌跟未来的成功会有很多的联 系；有人认为，自己的家庭背景会跟成功有必然的联；有人认为，上名牌大学的人会成功，在大学里成绩好的人比学习成绩差的人更加容易取得成功……所有这些因 素可能有部分是对的，但大部分基本无效，比如说相貌。 \n\n\n  如果说一个人的相貌和成功有关，那就不会有马云和阿里巴巴，因为如果在座的同学认为马云长得好看，那一定是审美出了问题。 \n\n\n  当然，这并不意味着相貌好看的人就做不成事情，比如说，另外一位大家比较熟悉的公司老总百度老总李彦宏。李彦宏非常英俊潇洒，他所有的照片看上去都像电 影明星一样，但是他也取得了成功。所以不管相貌如何，都能取得成功，只不过李彦宏和马云坐在一起吃饭的时候，他们通常不太愿意坐在相邻的椅子上，因为两个 人的对照到了惨不忍睹的地步，解决的方法就是把我放到他们两个中间，起到一个过渡的作用。像我这样，相貌没有什么特点的人也能取得成功。所以不管是男是 女，最重要的是自己内心世界的丰富，自己风度和气质的培养，自己胸怀的扩展以及对理想目标坚定不移的追求。随着年龄的增加，这些会慢慢变成你的智慧，所有 这一切才是构成你成功的真正的本质。 \n\n\n  那么成功和家庭背景有没有关系呢？我们常可以看到一些权贵富贾出身的人，他们一出生就含着金钥匙。比如，我们可能会看到，自己左边的一些同学穿着名牌服 装，右边的拎着名牌的皮包，前面坐着市委书记的女儿，后面坐着中央领导的儿子，而你可能就一个来自普通工人家庭的大学生。 \n\n\n  有的时候你会心存不满，但这个世界本来就充满着不公平，而很多不公平常常就在你的眼前闪现。你会说，这个世界怎么会对我这样，为什么他什么都有，而我什么 都没有？我在大学里也有过这种很正常的心理。比如，我的同学有部长的儿子、有大学教授的女儿，而我却是一个农民的儿子。3次高考后才走进了北京大学，穿着 布衣挑着扁担走进去的。你会发现你总赶不上他们的状态，倒不如说赶不上他们的脚步。你会发现即使他们停下来一辈子什么都不做，他们所拥有的东西都比你 多。 \n\n\n  比如，在大学一年级的时候，班上那个部长的孩子每周五都有开着奔驰280的司机把他接回去。你想我们那个时候连自行车都买不起，他居然坐着奔驰280，那 是一种什么样的感觉。你感到这辈子基本就完蛋了。但是同学们你们要记住一个真理，生命总是往前走的，我们要走一辈子。我们既不是只走过大学四年，或研究 生，我们要走一辈子。可能走到80、90岁，虽然走到80、90岁时，人生到底怎么样你是不知道的，你惟一能做的就是要坚持走下去。所以我非常骄傲地从一 个农民的儿子走到北大最后又走到了今天。我的心态很平衡，但其实我走了很远。当然，有的同学会说，你进了北大就已经很成功了。确实，北大增加了我很多成功 的因素。比如，因为北大读书气氛很浓厚，所以我读了很多的书，思维变得很敏锐。 \n\n\n  北大确实有人文的环境，蔡元培的铜像就树立在未名湖边上，但是每年进北大的有好几千人，出北大的也有几千人，能够成功的到底有多少呢？事实上，北大学生成功的比率并不比任何一个大学生成功比例高。 \n\n\n  所有的成功意味着你大学毕业后要进一步付出努力，如果大学就意味成功的话，那么也就没有马云了。我跟马云有很多相同的地方，他高考考了3年，我也考了3 年，他考的是英语专业，我也考的是英语专业，第三年我去了北大，他去了杭州师范学院。我相信很多同学都没听说过这个学院，那我觉得我这辈子应该比他更加成 功吧，但是非常不幸的是，从今天来看，阿里巴巴上市的市值就是新东方的3倍，而我除了做成一个新东方便什么都没了。不仅如此，他还有淘宝网、支付宝…… \n\n\n  所以，你未来的成功和你上什么大学没有什么联系，只不过以后出国就业更加的容易一点。一辈子能不能走出精彩，大学为你奠定了基础，但不能决定你的一生。到 大学毕业人生也只过了四分之一，接下来的时间我们该怎么过呢？首先是一定要坚持走下去，因为你不活了就什么都没有了。不管你相信不相信来世，我始终相信今 生今世就是我们最好的天堂。所以我最讨厌自杀或者以自杀为威胁，我觉得这是对生命不尊重。有种理念，叫做“好死不如赖活着”。因为从我40多年的人生经验 来体会，你在那坐久了，说不定天上真的会掉下馅饼来，当然也可能掉下块陨石。但不管怎样，不要自我了断，生命中会有很多奇迹发生。假如杨振宁教授不活到 82岁，他怎么知道还能结第二次婚呢？\n\n\n  但是同学们，人生总是要有份期待，哪怕是没有希望的期待。同学们可以想一下我们历史上有很多人物，比如说姜太公在河边钓鱼，到了80岁那一年，周文王在他 边上走过，发现这个老头用直的鱼竿钓鱼，跟他一聊便发现这个老头很有智慧，所以把他带回去，两人一起打下了周朝的天下。齐白石同志在50岁的时候还在做木 工，根本不是个伟大的画家，他的所有伟大的作品都是在80岁到90岁的时候完成的。所以生命总有这样的现象，有的人在年轻的时候有作为，有的人中年时候有 作为，有的人老年时候有作为。花儿总是在不同的季节开放，如果所有的鲜花都在春天开放完毕了，到了夏天、秋天、冬天没有任何的花儿开放你还会觉得这个自然 界是如此的美丽动人吗？ \n\n\n  所以大家想一想，如果人生所有的精彩都在大学里过完了，后面永远都是平淡，你觉得这人生会完美吗？换句话说，你大学里过的不那么精彩，毕业后却变得越来越 精彩是不是更加好呢？事实证明，我们很多同学在大学里的成绩总是名列前茅，可是大学毕业后却怎么也做不出什么事情来了。因为在社会上，并不是成绩在起作 用。成绩只能证明你智商比别人高，但并不能决定你一辈子就一定有出息。 \n\n\n  成功并不仅仅是你的成绩所决定的，最重要的是与社会打交道的能力，为人处世的能力。在各种混乱的人际关系中，寻找机会的能力，以及你最后领导一帮人跟你 一起创事业的能力。而所有的这一切都不是由你的成绩决定的。当然我并不是说，在大学不要好好学，拿到大学毕业证书这是必然的，因为在未来我们会发现这样一 个现象，假如，连大学本科文凭都拿不到的话，你的生命将充满艰难。\n\n\n   现在读过大学的人很多，有人说现在上大学没什么意思，因为找不到工作。确实到现在为止，今年应届毕业生找到工作的比例只有40%左右，但我相信这只是一 个临时现象，因为中国的产业结构还没有调整过来。从历史来看，中国大学生远远不多，因为中国从制造业正在转向咨询、信息、物流、服务等与世界沟通交流的行 业，也就意味着在座的所有大学生都具备这样的工作能力，必然能找到工作。 \n\n\n  一次有个大学生告诉我，俞老师我要创业，不上大学了。我说为什么，他说要向比尔·盖茨学习。我说世界上有几个比尔·盖茨，不就一个嘛，他说没关系，他可以 成为第二个。我说，那你为什么不上大学呢？他说，我考试不及格，上不下去了。这还是没法跟比尔·盖茨比的，人家是觉得自己的知识已经远远超过了老师，觉得 上大学已经是时间的浪费，要把自己的创造力及时的发挥出来，所以钻到自己的汽车库里研究微软去了。这是两种完全不一样的概念。 \n\n\n  当然我刚刚强调的是你学习成绩好并不一定今后就做的好。有一份统计数据，将大学成绩前10名和后10名的同学做过一个调研，以20年一个阶段来说，大学 最后10名的同学财富总量以及获得的社会地位，居然比前10名还要高。这就意味着，即便在大学里最落后的同学也不要放弃自己。比如，我在北大努力了5年， 在毕业的时候就是以全班倒数第五名毕业的，但现在我们班的第一名到第五名全在新东方。所以，我们永远都不要放弃自己。   \n  最精彩的人生是到老年的时候能够写出一部回忆录来，自己会因曾经经历过的生命而感动，会感动别人继续为生命的精彩而奋斗，这时候我才能说我的生命很充实。\n\n我10年前就碰到一个特别令人感动的故事：有一个大学生来找我，因为非常贫困，但想出国，想上新东方的班，但是他没钱所以跟我说他很想上新东方的课，但没 钱，能不能暑假在新东方兼职做教室管理员，并且安排他到班，查完学生的听课证扫完地后就在后面听课，我说当然可以。没想到这个学生又提了个要求，如果两个 月的兼职真的做的很好的话，能否给他500元工资让他买个录音机，我说没有问题。结果那孩子做了两个月，所有接触过他的人都说这孩子刻苦认真，所以到了两 个月后，我给他一千块钱的工资让他买录音机。他买好后，边听着录音机边流着泪。我知道他被自己的行为感动了，以后肯定有大出息，果不其然几年后他被耶鲁大 学以全额奖学金录取了，现在还在美国工作，年薪13万5千美元。所以说只有被自己感动的生命才会精彩。 \n\n\n   其实我也有一些让自己感动的故事，比如说我高考落榜。当时想着一定要考进大学，但没想过进北大，所以就拼命读书。有的时候你会发现你低着头一直往前走，目 标就会在你的后面。所以当我拿到北大录取通知书的时候，真的是仰天大笑然后嚎啕大哭，跟范进中举一模一样。但如果当时没有坚持的话，也许我现在仍然只是一 个农民的儿子。比如，当时我们村有个人跟我一样考了两年，他总分还比我高三分，当时我跟他说一起考第三年吧，但他的母亲说别考了，找个女人结婚算了，但当 时我跟我妈说你让我再考一年，结果第三年我真的考上了。所以我得出两个结论，1、人必须往前跑，不一定要跑的快，但是要跑的久；2、不能停下来，你不能三 天打渔两天晒网，要持之以恒。 \n\n\n  我走到今天没有一天懒惰过，我现在每天依然要工作近16个小时，从高考那天开始每天如此。但我发现，我还是比不过有些同事。从小学到高中，我学习也挺认真 的，成绩总是在前10到20名之间，而在大学我学习更加认真，但最后却以全班倒数第五名毕业。龟兔赛跑的故事我们从小学就知道了，而生活中也经常体现出 来。因为跑得快的人往往会停下来，而跑得慢的不能因为慢就不跑。只要跑，早晚会达到你所向往的终点。所以我们不要去计较大学时候谁的成绩高低，只要不停的 去追求就可以了。 \n\n\n  一个聪明的人一辈子所创造的成就不一定比一个笨的人所创造的多，因为笨的人每天都在创造，而聪明的人可能创造一段时间会停下，即便是爱迪生这种超级天才， 小时候也被认为是个白痴。爱因斯坦九岁才会说话，还好他有个好妈妈一直认为他是个天才，才使他成为一个伟大的科学家。所以当我的儿子到4岁时还不会说话， 我老婆着急地带他到处求医时，我说，别看，4岁不会说话很正常的。我老婆说，为什么正常，我说，不会说话是语言功能发育不完全，不代表头脑就不发达。所以 永远不要用你的现状去判断你的未来，只要你坚持就一定能获得你所意想不到的东西。 \n\n\n  后来我班级里很多同学都联系出国，我看了羡慕，想要追赶他们的步伐，所以也开始联系出国。整整4年，联系了无数的美国大学和专业，没有一个美国大学给我奖 学金。尽管拿到了几张录取通知书，但去美国大使馆签证，每次都拒签。当然，现在我的签证除了伊拉克的没有，其他国家几乎都有了。现在美国给我的签证是10 年多次往返商务签证。因为新东方是在美国上市的，他必须允许我任何一天随时随地都能进入美国。所以当我儿时的朋友到现在还在面向黄河，这辈子还没有走出过 我们镇的时候，我已经走遍了世界各地。大家想，在徐霞客、苏轼那个没有任何交通工具的时代，都能游遍山水，写下许多让我们感动和动人的文字，而在我们这个 科技兴盛的时代，如果没有在世界上留下一些的文字和足迹，你怎么对得起自己。 \n\n\n  有的同学说，俞老师因为你现在有钱了所以可以这么做。坦率的说，以前我没钱我也会这样做。因为小时候我最崇拜的人物就是徐霞客，因为他是我的老乡，住在 我家隔壁。只不过他是400年前住在我家隔壁，要知道地方上的名人对地方上少年的影响是非常巨大的。有次，我坐在长江边上看日出日落，我就在想徐霞客怎么 能走那么远呢？所以也会向往这辈子我是否能跟他走的一样远。 \n\n\n  正是因为有这样一个榜样在，我才会发现高考一次、两次我都不绝望，因为我知道走出农村边界的惟一办法就是考上大学。我想把农村户口变成城市户口，因为当时 城市户口是可以到处走的。尽管我平时很平和，但心中总是有一种愿望，叫做穿越地平线走向远方的渴望，就是看到眼前的地平线我总是不满足的，我总是希望翻开 地平线看看另一边到底是什么样的。 \n\n\n  大家都知道，只要你不断的超越地平线一定会有很多的风景在你眼前展示出来。这跟你有没有钱没关系。而我曾怀揣100元人民币，走到了泰山，走到了黄山，走 到了九华山，走到了庐山。我一边走一边帮人家干活，走到九华山发现没钱了，就睡到一个农民家里。那个农民在江边给我弄了个床，还找我要钱，而我口袋里只有 5块钱。于是，我就说帮他一起插秧来抵消住宿费。他左看右看说，大学生怎么会插秧呢？结果插了一天我插了四分之三，而他只插了四分之一，把他感动的半死不 活。他说，你怎么会插的那么快呢？我说，我14岁那年就获得过我们县的插秧冠军。然后，他晚上杀了一只鸡要我一起喝酒。他越聊越觉得我不像大学生更像农 民。第二天我走的时候，他居然掏了10块钱给我说，我知道你口袋里没钱了，明天还要去庐山，这点钱就给你当路费。 \n\n\n  生命是有各种活法的，但是哪怕你坐到书斋中间，一辈子也要让自己的生命变的伟大。陈景润一辈子没出过书斋，不也是世界上最伟大的数学家？所以不管在什么状 态下也要像一首诗写的那样“相信未来，热爱生命”。所以只有当我们的生命有了期待以后，才会有进步。有的时候，我们选择前进，不是因为我们有多么坚强。有 这么一句话让我很感动，也变成了我的座右铭：“坚持下去不是因为我很坚强，而是因为我别无选择。”新东方有一个运动，叫做徒步50公里。任何一个新东方新 入职的老师和员工都必须徒步50公里，而未来的每一年也都要徒步50公里。很多人从来没走过那么远的路，一般走到10公里就走不动了，尤其是要爬山涉水地 走。每次我都会带着新东方员工走，走到一半的时候会有人想退缩，我说不行，你可以不走，但是把辞职报告先递上来。当走到25公里的时候你只有3个选择，第 一，继续往前走；第二，往后退；但当你走到一半的时候，你往后退也是25公里，还不如坚持往前走呢；第三，站在原地不动。而在人生旅途中停止不前还有什么 希望呢？ \n\n\n  我们人生有很多迷茫和痛苦，而只要你坚持往前走，痛苦往往会解决掉。在走的过程中，我也痛苦得流过泪，也曾经痛苦得嚎啕大哭过，但我知道真的坚持下去不是 因为你坚强而是因为你别无选择。走到最后你会发现总会有成果。我没想到新东方能从培训13个学生，现在变成培训175万学生、其实所有这一切你都不一定要 去想，只要坚持往前走就行了。 \n\n\n  我们生命中总要去追寻一种经历，有的时候我们觉得人连条鱼都不如，因为我在加拿大的时候，我看过加拿大三文鱼回流，每次它回流产卵的时候，我总会发现生命 及其壮观，鱼卵产在沙子里会被其他动物吃掉很多。第二年春天的时候剩下的鱼卵会变成小鱼，小鱼会顺流而下，流到湖里，而在湖里又会被其他鱼类吃掉一些。一 年后，长大的鱼会顺着大河奔入海洋，然后绕太平洋一周，每四年一个循环。如果三文鱼就在海洋中待着不回到湖里产卵，它就不会死，但它是受到内心的召唤集中 在河口开始往前游，一旦游进河的时候就再也不吃任何东西拼命地往前游，然后游到目的地开始配对产卵，产好后就双双死亡。你会看到成千上万的红色死鱼漂在河 上，而老鹰和黑熊就在边上等着。 \n\n\n  我看了后特别感动，一条小小的三文鱼也知道，生的使命是不能放弃。那我们人生的使命呢，比如父母为我们献出了青春财富，把你养育成人。而我们未来变成父母 后也是一样。我们孩子的成长就是你的使命，而我们其他的使命感，如何让自己活得更加幸福，如何帮助别人，让这个社会变得更加有意义。为什么宗教人士会活得 相对简单，因为他们灌输了一种使命感。而连一条鱼都经历了小溪流、湖泊、大海，他尝到了淡水的清香和海水的苦涩，完成了生命的周期。如果我们这一辈子都没 有苦涩，没有幸福和甜美，那生命是很遗憾的。 \n\n\n  而你现在的状况并不决定于你的未来，我在北大的时候受到的打击比较多，首先是身份上的悬殊，确实我是穿着大补丁走进校园的，我们体育老师上课从来不叫我的 名字的，都是叫那个大补丁来做个动作。因为我在农村锻炼过，跳跃性动作做得蛮好看，所以我常常被叫出来做演示。 \n\n\n  开学第一天晚上，全班开班会，我起来讲了一句话。现在新东方的王强老师是我们班级的班长，站起来跟我说你能不能不讲日语。因为我一直在农村上学，所以我们 的语文老师从来没用普通话给我们上过课，我当时根本不知道普通话该怎么说。北大当时按照英语成绩分班，我当时因为高考英语考得蛮好所以被分到了A班，其实 我的听说水平并不好，所以到了A班一个月以后就被贬到了C班，而C班主要是针对那些语音语调及听力障碍的同学。等后来，我发现我和同学的智商真的有差距， 我的那些同学平时看他们学习也并不怎么认真怎么一到期末考试就能考出好成绩，我每天学习时间都要比他们多两三个小时，但每次期末考试都在全班倒数几名。这 让我的心情非常郁闷。 \n\n\n  当时，我们班50个同学，25个男生25个女生。一开始我听完这个数字就特别兴奋，但是没想到我们班的女生没一个正眼瞧我一眼的。到了2001年的时候我 们全班同学聚会，大家从世界各地赶回来。蓦然回首，大家突然发现班上那个挺没出息的，普通话也讲不好的，默默无闻的那个人怎么就成了全班最出色的了。这个 时候女同学们都热情的走上来握住我的手，后悔当初没下手。 \n\n\n  所以后来大学女生问我，俞老师我们现在找男朋友要什么标准，我说很简单，参考我的长相。当然如果长得像我，那是绝对不能放过的。凡是长得比我难看的也不要放过，因为这个世界上的规律就是，越难看的人内涵越丰富。 \n\n   大三的时候我最喜欢读的是《红楼梦》，而且刚好读到林黛玉咳嗽而死的那一章。结果发现自己也在吐血。到医院，医生一查说得了肺结核立刻关起来，一关就是 一年。我跟医生说像我这样的小伙子怎么会得肺结核呢？医生让我讲讲现状。我说，您看我学习特别刻苦，可成绩就是上不去，班里没有一个女孩子喜欢我。他说， 这种情况不得肺结核是完全不可能的。 \n\n\n  但这个病也给我带来了心态上的调整，因为我在大学一二年级，想要追赶我的同学就是我的精神支柱。但是到了三年级，病了一年后我完全改变了，我觉得活着就挺 好。然后我就给自己订了一个最低标准，至少保证大学毕业拿到毕业证书，最后国家给我分配一份工作就挺好。虽然我并没有放弃努力，结果反而获得一个更加开阔 的心胸。所以，到现在为止我学会了永远不要去比，因为总有比你更加优秀的，也总有比你更加落后的。 \n\n\n  这个世界上最正确的是跟自己比，想一想今天是不是比昨天进步了一点，想一想明年是不是比今年更加好一点。想一想，10年以后的你是不是比今年的你要更加出色。这样的心态一直保持到我大学毕业。 \n\n\n  大学毕业的时候，每个人都要上去讲一段话，比如后半辈子怎么过，我就上去讲了这么一段话：我说，同学们大家都很厉害，我追了大家5年没追上，但是请大家记 住了，以后扮演一个骆驼的同学肯定不会放弃自己，你们5年干成的事情我干10年，你们10年干成的事情我干20年，你们20年干成的事情我干40年，实在 不行我会保持心情愉快身体健康，到了80岁后把你们一个个送走了我再走。这是我个人保持到现在的人生态度，而我认为这种人生态度对我来说非常有效。 \n\n\n  有人问我，如果新东方没了怎么办？其实新东方早晚会没的，因为它已经是一个商业化运作的教育机构。大家想一想，前些天我们看到的一个消息，GE公司是美 国的标志，不照样濒临破产了吗？新东方可能以后也会这样，变成历史的痕迹。但是我想，即使新东方没有了我依然很成功，因为我的心态很成功。我追求生命的那 种向往和穿越地平线的渴望不会改变。我认为，新东方给我的是一种精神，一种力量，而不是新东方本身给我带来多少钱，当然如果新东方给我更多的钱，我也愿意 要，不要钱才是傻瓜呢。但更重要的是，有了钱能否做出一些更加有意义的事情来。比如说我现在一直都想做一个小小的私立大学，可能我无法做到像同济大学那么 大，但做到它的十分之一总是可以的吧？我在北京已经买了一块地，正在建大学校区，造完后它就跟新东方的上市公司脱钩了，变成一个非营利性的大学校园，那它 可能就变成了你做的另外一件事情。 \n\n\n  如何把自己的生命变的更充实是最重要的事情，所以说，哪天新东方不存在了是非常正常的。如果新东方没了，我照样会过来跟大家做讲座，而且心情会更加的开 朗。因为没有繁琐的事情了。我只要换个题目就行了今天叫“度过有意义的生命”，下次我改成“我是如何把新东方做没了的”。 \n\n\n  而在大学中，我们要做的几件事情就是：第一，把自己的知识结构打造完整；第二，就是要在大学里尽可能的多交朋友，因为你终身的朋友、合作者一定来自于你的 大学；第三，如果有可能的话，在大学里谈一场比较专一的恋爱，因为回顾我北大的生活一片灰色。我想为什么会是灰色呢？其实，不是因为成绩不好，而是因为在 大学5年我从来没有过花前月下的时光。所以一直成了我大学时代的遗憾。去年北京大学让我给所有北大新生做开学典礼的时候，我给他们强调一句，什么都不重 要，重要的是谈恋爱，而且谈恋爱也不用害怕失败，因为自杀也自杀不了，未名湖就那么浅，跳下去还能爬起来；第四，就是为未来的工作做好打算。未来的工作跟 你有多少朋友、跟你的专业知识学的多少是相关的。好好掌握你的专业，再差的专业也一定有人用，只要你学的好。 \n\n\n  我有一个朋友学的是越南语，越南语的确很少用，但所有的中央领导去越南都要找他，因为他是一流的越南语同声翻译专家。我还有一个大学同学研究蒋介石，研究 了10年，穷困潦倒。但后来他去美国做了一个报告，美国方面帮他召开了一个中国现代史人物研讨会，他在报告上讲了自己的研究经过，结果下面一个老教授热泪 盈眶。下来后一问，这个老教授也在美国研究了30年蒋介石，孤苦伶仃，就是找不到另一个研究蒋介石的，没想到有个“傻瓜”也在研究蒋介石。于是5万美元一 年，让我同学跟着他在美国读研究生，然后读了四年的博士生。读完以后老头退休，他就变成了那个学校的教授。我去看他的时候，他已经在纽约买了套小房子，买 了辆车娶了个老婆养了条狗。当时他跟我说，俞敏洪你看现在这一切都是蒋介石“给”我的。 \n\n\n  我想用这个例子来说明什么呢？就是研究什么不重要，重要的是只要你真的喜欢就去做，然后就会有人用你。反过来，如果你觉得这个专业你不太喜欢，但很适合我 找工作，这要不要学？当然要学。我就是这样一个状态，我从来没喜欢过英语，当初考英语只是因为数学不行。不喜欢英语是因为我的模仿能力不强。像我的班长王 强，能够把任何话都模仿的惟妙惟肖。我普通话练了一年，才练成大家能听懂的样子。我老婆是天津人，跟我一吵架就用天津话骂我，但是我到现在为止只会说一句 天津话。就是当她拿起棍子打我的时候，我向她大吼一声，“干嘛”（天津话）。 \n\n\n  但是后来我发现英语成了我生命中的工具，因为英语，我在北大当了老师。其实当初留北大并不是成绩好，而是当时正好四六级考试，北大各个系的同学都要学两 年英语，结果北大急缺老师。而一些优秀的毕业生都去了外交部、经贸部，工资又高。后来我们系主任急了说，最后5名给我留下来。留下来的5个人现在都变成博 士生导师了，可见现在北大教育质量如何。当然这是句玩笑话，他们后来也经过自己的努力，经历了很多次考试成了很优秀的教师。 \n\n\n  在登山的时候，你会在乎登山杖你喜欢不喜欢吗？不会，你只会在乎能否帮你登上山顶。那么英语就是我的登山杖，尽管我不是特别的喜欢，但我知道我要想攀上更 高的人生的山峰就必须需要这个登山杖。我本来想把自己变成中国英语专家前100位的，后来发现一点戏都没有，因为中国留学生归来的越来越多了，有的在国外 待了10年、20年，回来了怎么看英语水平都比我高。那我只能缩小范围，想变成英语语法专家。后来发现背单词不用动脑筋，所以就开始拼命地背单词，结果变 成了中国还算不错的词汇专家。 \n\n\n  除了学专业外，同学们要在大学里多读书。新东方人读书都非常多。读书多，就意味着眼界更加的开阔，更加会思考问题，更具有创新精神。新东方流传一句话叫做 “底蕴的厚度决定事业的高度”。底蕴的厚度主要来自于两方面，第一多读书，读了大量的书你的知识结构自然就会完整，就会产生智慧；第二就是多人生经历。把 人生经历的智慧和读书的智慧结合起来就会变成真正的大智慧，就会变成你未来创造事业的无穷无尽的源泉和工具。 \n\n\n  比如，新东方招聘重要岗位的人才都是我面试。我只有几个问题，第一你大学读了多少本书，如果你说只读了几十本书，那肯定我不会要你。我心中的最低标准是 200本书，而我在大学里读了800本书。新东方还有更红火的王强老师，在大学里读了1200本书，平均每天一本。有的人会问我，读过了忘了跟没读过有什 么区别呢？其实完全不一样。就像你谈恋爱，一个谈过恋爱后又变成光棍汉的人和一个光棍汉相比是有自信的。因为当他看到别人在谈恋爱的时候，他会在旁边“嘿 嘿，想当初老子也是谈过恋爱的嘛”。实在不行来不及读，你可以到书店看着那些书，记着那些名字用手摸一下，这样也能增加一点人文气质。 \n\n\n  我有一个理念，人活着要过一种诗意的生活，我们有多少时候是停下来看看月亮的，在假期去内蒙看一下漫天的繁星的，有多少同学看着朝霞和晚霞时心中感受过生 命的涌动的。当然也要身体力行。大学时候，有一个非常著名的诗人叫海子，写了著名的诗句“面朝大海，春暖花开”，但非常可惜的是他没能抵抗现实社会的压 力，卧轨自杀了。所以我们说一个人不能只在语言上表达诗意，还要在现实中去表达诗意。所以你必须克服现实中的障碍和挫折。有首诗叫“大漠孤烟直，长河落日 圆”。我对“长河落日圆”有非常深刻的感觉，但对“大漠孤烟直”却没有什么概念。所以，进入北大校门之后第一件事情就是走向沙漠，走向戈壁滩，走向大草 原。而到今天为止，这些地方成了我的精神家园。如果生命中一有过不去的事情，我就去蒙古草原上跟牧民一起骑马。牧民曾经说过，在汉人当中从来没看到像你那 样不要命的。 \n\n\n  回过来讲诗意的生活，在大学里打游戏上MSN不叫诗意的生活，而在一张床上拿着书一边看书然后慢慢地睡着那就是一种诗意。要关注时事政治，要把握一些世界 大事。这种能力将在你日后创业的过程中起到很大的作用。另外就是要尽可能地多交朋友，交朋友首先你要做个好人，你要做一个让人放心的人。在中国企业界就是 这样的状态，如果你是个好心的人，在困难的时候一定会有人帮助。比如，蒙牛的牛根生大家都听说过，他为人处世很实在。所以蒙牛出事后，他需要资金，只需要 打个电话我们就会把钱汇过去。而为什么连合同都不签我们就给他，道理很简单，信任。 \n\n\n  我也碰到过这样的情况，03年的时候遇到SARS，我们马上给学生退学费，新东方的流动资金一下子退光了。而当时我算下来，账上还缺2000万。于是我分 别给两个朋友打了电话，一人一千万当天晚上就搞定了。所以，你变成一个让别人相信的人，比做一个让别人防着你的人，得到的好处要多得多。而建立这种信任， 要做到以下几个要素：要以别人为中心不要以自己为中心；要有服务精神。 \n\n\n  当时我那些大学同学觉得我没出息，但为什么会回来跟我创业呢？这跟我大学里的行为有关。我大学里是个学习不好但挺喜欢帮别人的人。我们宿舍当时从来不排值 日生，因为地全是我扫的。还有就是宿舍的水也基本都是我打，而他们之所以后来放弃国外优秀的条件来和我一起创业还是跟我当时宿舍打水有关系。若干年后，我 去找那些大学同学回来，他们说连你那么没出息的人在中国都赚钱了那我们回来还了得？第二个理由是，我们知道你是个特别好的人，你有饭吃不会给我们喝粥，你 有粥喝不会让我们饿死，所以就回来了。所以在大学毕业连一个朋友都没有的人，这辈子想成功几乎是不可能的。 \n\n\n  还有在大学里要交几个真正能帮助你的人，比如：心胸比你开阔，眼光比你敏锐。我在大学里交的就是这样的朋友，做人就要跟着牛人跑。比如，王强老师有天才的 一面，而这些是我学不到。他喜欢读书，他一进大学就会把生活费一分为二，一份用来买书，一份用来买饭票，饭票吃完了决不用买书的钱，他宁可偷别人的饭票， 我觉得这个习惯很好，我也一分为二，饭票吃完了我就偷他的。每到周末我们就去买书，我不知道买什么书，所以他买什么我跟着买什么，他被我弄烦了说你能不能 不跟着我，我说你是我的班长有责任帮助落后同学。其实我知道他想把我赶走，因为当时他是我们班女生追求的对象，如果我不跟着他他就会带女生出去买书，我当 时就看穿了他这个阴谋。到现在为止我的读书老师就是王强，他的藏书接近6万本，他每当看到有好的便宜的书就会帮我买，贵的会发个消息让我自己买。\n\n\n  到现在为止我都要不断的读书。因为每当聚会，他们谈起好书的时候，一旦我没读过就会被他们说“你大学时候不用功，怎么现在还是这样。”所以，我们的读书氛 围之所以非常的浓厚，最重要的原因就是王强，而你非常需要这样的朋友。还有就是徐小平老师。大学里我觉得这个老师很好，很想认识。一个礼拜后我买了支小钢 笔送给他，敲开他家的门，他问我，你是谁。我说，我是你的学生，听了你的课后很感动，所以想跟你交个朋友，这是我带给你的小礼物。徐小平一看我手中拿着礼 物就让我进去了，进了他家的门发现有一大群年轻老师在那。原来他有个习惯，一到周五晚上都会招一批老师来他家聊天。我当然很想听，问我能不能留下来听，他 说不行啊，我们聊的都是些男男女女的问题，像你这样的纯情少年会被污染的。幸亏我反应快说，徐老师我在这方面刚好需要启蒙教育。机会总是自己发现的。我发 现没有人给他们烧水，于是，我就帮他们烧水煮方便面。连续去了4个礼拜，到了第5个礼拜我不去了。为什么不去，不是因为我烦了，而是我觉得一个人在该显示 重要性的时候一定要显示出来。果然徐小平一个电话过来说，你这个兔崽子怎么还不过来。我知道，不是我离不开他们而是他们离不开我了。从此，在一年的时间 里，我不停听他们聊天，等到我办新东方的时候，我去的第一家就是徐小平家。我跟他说新东方不缺英语老师，但缺有思想的人物，所以希望你回去管理新东方的思 想。所以在大学里要做的另外一件事情就是一定要交朋友，让自己变成一个别人信赖的人。 \n\n\n  而如果能谈一场恋爱还是很不错的。但谈恋爱有一个非常重要的前提条件就是要一心一意地爱。所谓一心一意的爱不是说，大学里只能谈一次恋爱，而是说一次只能谈一个。要爱到一个什么程度呢？要有这样的一个感觉，“为什么我的眼睛充满泪水？是因为我爱你爱的深沉”。 \n\n\n  第二个要素就是当你真的爱上一个人后，要以恰当的方式告诉他你爱他而不能只放在心里。我在大学就吃亏在爱上不少女孩子，但只放在心里，怕被别人拒绝。但 其实人的追求最好还是表现出来，就算被一个女孩子拒绝了，她回家一定会在日记上写上，“今天又有一个男孩追我咯”。有一年去美国，跟一个以前班里很喜欢的 女孩一起吃饭，她和她老公跟我一起吃饭。吃饭的时候我跟她说，其实我在大学对你特别有好感。她当时一拍大腿说当时你为什么不告诉我呢？ \n\n\n  第三条就是谈的要大度，所谓的大度就是说当另一个人爱上其他人的时候一定要大度的对他说，你的幸福就是我的幸福，你的快乐就是我的快乐。我始终觉得人在世界上总是有缘分的，如果大学没有人爱你，在你以后的人生中总是会有人爱你，等你一起牵手走向今后的旅程。 \n\n\n  我是一个特别热爱生命的人我走路连蚂蚁都不敢踩，我想踩死那只公蚂蚁那只母蚂蚁怎么办。我吃鱼都不敢吃，我想吃了那条母鱼那公鱼该多痛苦啊，所以我一般不 吃鱼要吃吃两条。当然，大学的恋爱是一个过程，不管研究生还是本科生，毕业以后真结婚的比恋爱要少的多。比如我们班十几对谈恋爱，大学毕业后结婚了三对， 两年后离婚了两对。现在还剩下一对，这一对就是王强老师和他的夫人，我大学的同班同学。他们两人现在还过着幸福的生活。 \n\n\n  那么如果对大学的爱情有不满的也没有关系，看看我就行了。很多人都以为我不正常了，但是我还是照样地结婚了，照样找到心爱的人，照样生孩子，也有了比较 美好的家庭。总而言之，生活就是这样美好的往前走。有平凡，有激动，有慢慢长夜，也有美丽的日子，这就是我们的生活。 \n\n\n  还有就是工作问题。工作问题是一个比较简单的问题。我相信同济大学的同学在找工作的时候都不会有太大的困难，但是有同学问我要不要创业。人生一辈子不创一 次业一定是一件非常糟糕的事情。人一辈子总是要为自己干件事情，创业就是为自己干的事情。一份工作大家一起干，但是你并不一定大学毕业就要创业。为什么 呢？因为创业需要经验和许多前提条件。 \n\n\n  第一，你的专业知识能在你创业中的运用；第二，你有能和同学朋友相处并且有分配利益关系的能力；第三，你要有对付中国社会如此复杂局面的能力；第四，你要 有基本的商业操作原则或者商业运作知识；第五，自己要是个具有领导力的人；第六，你要有自己领域的运作知识和专业知识。 \n\n\n  比如，你想搞个培训学校，那你的运作知识从什么地方来呢？这个运作知识需要你通过观察别人怎么做得来的。如果当初我直接从北大出来就做新东方，那我是永 远做不成的。我做新东方有两个前提条件。第一个，我在北大做了六年老师，所以做老师做的不错。还有第二个前提条件，我做新东方以前，我在另外一家培训机构 干了近三年，我就在观察它是怎么做的。我碰到许多大学创业失败的人。我说你们怎么不创业了？他们说，同学之间只要一碰到利益关系，互相全是“狗屁”。是不 是这样？是的，但是你会处理了就不是“狗屁”了。我和新东方这帮朋友也有利益关系，但是我不就处理好了吗？所以说现在关键是考虑有没有这样的本领。要创业 但是我鼓励同学们先去某一个行业至少观察一到两年，最好是三到四年，慢慢积累自己的才能，自己也慢慢变得成熟，个性也慢慢变得稳定，最后再创业这样失败的 机会也少了很多。 \n\n\n  创业有两种状态，第一种就是从零做起，我自己就是从零做起，马云也是从零做起。第二种创业就像杨元庆，也算创业，杨元庆是接柳传志的班最后变成了联想老 总。美国著名的管理学家、企业家杰特威尔逊，他也是从一个普通工人做起，做了20年变成公司的老总；在公司老总的位置上干了20年把公司变成了全世界最大 的公司。这也是创业，不一定是自己干。 \n\n\n  有学生问，俞老师，我怎么把一个培训机构和你干得一样大？很简单先到新东方来打扫卫生，如果你把卫生打扫的非常干净，那么我把你提升为卫生部长，如果你 卫生部长干得好你就变成新东方后勤主任，等到你变成新东方后勤主任的时候，我就把你送到哈佛大学去学习了，学习完了回来我就把后勤行政全部交给你，你就变 成后勤行政总裁。第几位？第二位。我“一翘辫子”你就是总裁了对不对？所以我们的成熟是慢慢来的，就像一棵树长大也是慢慢长大，哪有一下子就能变成自己创 业成功的人？虽然这种人还是有的，但也是少数。我是32岁创业的，32岁才有了新东方。所以不要着急，人一辈子做多大的事都无所谓。 \n\n\n  还是我的老话：把生命活得精彩一点。我的比喻就是大树与小草的比喻，还有另外一个比喻：人的生活就像溪流一样，总有一个梦想——流进大海。有的人这一辈子 没有流向大海，这条河就是不完整的。长江流向大海，黄河流向大海，但长江、黄河以自己不同的方式流向大海。长江开山劈石穿过大山流向大海，黄河没有开山劈 石，结果绕过九曲十八弯。但是不管怎么样，生命再弯最后目标不变。我们惟一要记住的就是要像黄河、长江一样不断地向前流，但是不能变成黄河、长江里面的泥 沙，最后自己沉淀下去，把生命给沉淀没了。总而言之，生命的精彩只靠自己不靠别人。从来没有什么救世主，想要活得精彩、幸福，只能靠我们身边的每一个朋友 的共同努力！\n","source":"_posts/俞敏洪在同济大学的的演讲.md","raw":"---\ntitle: 俞敏洪在同济大学的的演讲\ndate: 2022-03-17 15:27:31\ntags: Other\n---\n\n同济大学的同学们大家晚上好！ \n\n\n  其实人活着就挺好，至于生命有没有意义另当别论。活着每天都会有太阳升起来，每天都会看到太阳落下去。你就可以看到朝霞，看到晚霞，看到月亮升起和落下，看到满天的繁星，这就是活着的最美好的意义所在。 \n\n\n  没想到同济大学的同学们把我如此“高大”的形象放在大屏幕上，这就是理想与现实的差距。所以我相信同学们看到我的第一眼一定感到非常的失望。实际上，每一 个人都是非常普通的，我们很多时候会发现生命中非常重要的东西跟我们未来的幸福和成功其实没有太多的联系。比如，有人认为，相貌跟未来的成功会有很多的联 系；有人认为，自己的家庭背景会跟成功有必然的联；有人认为，上名牌大学的人会成功，在大学里成绩好的人比学习成绩差的人更加容易取得成功……所有这些因 素可能有部分是对的，但大部分基本无效，比如说相貌。 \n\n\n  如果说一个人的相貌和成功有关，那就不会有马云和阿里巴巴，因为如果在座的同学认为马云长得好看，那一定是审美出了问题。 \n\n\n  当然，这并不意味着相貌好看的人就做不成事情，比如说，另外一位大家比较熟悉的公司老总百度老总李彦宏。李彦宏非常英俊潇洒，他所有的照片看上去都像电 影明星一样，但是他也取得了成功。所以不管相貌如何，都能取得成功，只不过李彦宏和马云坐在一起吃饭的时候，他们通常不太愿意坐在相邻的椅子上，因为两个 人的对照到了惨不忍睹的地步，解决的方法就是把我放到他们两个中间，起到一个过渡的作用。像我这样，相貌没有什么特点的人也能取得成功。所以不管是男是 女，最重要的是自己内心世界的丰富，自己风度和气质的培养，自己胸怀的扩展以及对理想目标坚定不移的追求。随着年龄的增加，这些会慢慢变成你的智慧，所有 这一切才是构成你成功的真正的本质。 \n\n\n  那么成功和家庭背景有没有关系呢？我们常可以看到一些权贵富贾出身的人，他们一出生就含着金钥匙。比如，我们可能会看到，自己左边的一些同学穿着名牌服 装，右边的拎着名牌的皮包，前面坐着市委书记的女儿，后面坐着中央领导的儿子，而你可能就一个来自普通工人家庭的大学生。 \n\n\n  有的时候你会心存不满，但这个世界本来就充满着不公平，而很多不公平常常就在你的眼前闪现。你会说，这个世界怎么会对我这样，为什么他什么都有，而我什么 都没有？我在大学里也有过这种很正常的心理。比如，我的同学有部长的儿子、有大学教授的女儿，而我却是一个农民的儿子。3次高考后才走进了北京大学，穿着 布衣挑着扁担走进去的。你会发现你总赶不上他们的状态，倒不如说赶不上他们的脚步。你会发现即使他们停下来一辈子什么都不做，他们所拥有的东西都比你 多。 \n\n\n  比如，在大学一年级的时候，班上那个部长的孩子每周五都有开着奔驰280的司机把他接回去。你想我们那个时候连自行车都买不起，他居然坐着奔驰280，那 是一种什么样的感觉。你感到这辈子基本就完蛋了。但是同学们你们要记住一个真理，生命总是往前走的，我们要走一辈子。我们既不是只走过大学四年，或研究 生，我们要走一辈子。可能走到80、90岁，虽然走到80、90岁时，人生到底怎么样你是不知道的，你惟一能做的就是要坚持走下去。所以我非常骄傲地从一 个农民的儿子走到北大最后又走到了今天。我的心态很平衡，但其实我走了很远。当然，有的同学会说，你进了北大就已经很成功了。确实，北大增加了我很多成功 的因素。比如，因为北大读书气氛很浓厚，所以我读了很多的书，思维变得很敏锐。 \n\n\n  北大确实有人文的环境，蔡元培的铜像就树立在未名湖边上，但是每年进北大的有好几千人，出北大的也有几千人，能够成功的到底有多少呢？事实上，北大学生成功的比率并不比任何一个大学生成功比例高。 \n\n\n  所有的成功意味着你大学毕业后要进一步付出努力，如果大学就意味成功的话，那么也就没有马云了。我跟马云有很多相同的地方，他高考考了3年，我也考了3 年，他考的是英语专业，我也考的是英语专业，第三年我去了北大，他去了杭州师范学院。我相信很多同学都没听说过这个学院，那我觉得我这辈子应该比他更加成 功吧，但是非常不幸的是，从今天来看，阿里巴巴上市的市值就是新东方的3倍，而我除了做成一个新东方便什么都没了。不仅如此，他还有淘宝网、支付宝…… \n\n\n  所以，你未来的成功和你上什么大学没有什么联系，只不过以后出国就业更加的容易一点。一辈子能不能走出精彩，大学为你奠定了基础，但不能决定你的一生。到 大学毕业人生也只过了四分之一，接下来的时间我们该怎么过呢？首先是一定要坚持走下去，因为你不活了就什么都没有了。不管你相信不相信来世，我始终相信今 生今世就是我们最好的天堂。所以我最讨厌自杀或者以自杀为威胁，我觉得这是对生命不尊重。有种理念，叫做“好死不如赖活着”。因为从我40多年的人生经验 来体会，你在那坐久了，说不定天上真的会掉下馅饼来，当然也可能掉下块陨石。但不管怎样，不要自我了断，生命中会有很多奇迹发生。假如杨振宁教授不活到 82岁，他怎么知道还能结第二次婚呢？\n\n\n  但是同学们，人生总是要有份期待，哪怕是没有希望的期待。同学们可以想一下我们历史上有很多人物，比如说姜太公在河边钓鱼，到了80岁那一年，周文王在他 边上走过，发现这个老头用直的鱼竿钓鱼，跟他一聊便发现这个老头很有智慧，所以把他带回去，两人一起打下了周朝的天下。齐白石同志在50岁的时候还在做木 工，根本不是个伟大的画家，他的所有伟大的作品都是在80岁到90岁的时候完成的。所以生命总有这样的现象，有的人在年轻的时候有作为，有的人中年时候有 作为，有的人老年时候有作为。花儿总是在不同的季节开放，如果所有的鲜花都在春天开放完毕了，到了夏天、秋天、冬天没有任何的花儿开放你还会觉得这个自然 界是如此的美丽动人吗？ \n\n\n  所以大家想一想，如果人生所有的精彩都在大学里过完了，后面永远都是平淡，你觉得这人生会完美吗？换句话说，你大学里过的不那么精彩，毕业后却变得越来越 精彩是不是更加好呢？事实证明，我们很多同学在大学里的成绩总是名列前茅，可是大学毕业后却怎么也做不出什么事情来了。因为在社会上，并不是成绩在起作 用。成绩只能证明你智商比别人高，但并不能决定你一辈子就一定有出息。 \n\n\n  成功并不仅仅是你的成绩所决定的，最重要的是与社会打交道的能力，为人处世的能力。在各种混乱的人际关系中，寻找机会的能力，以及你最后领导一帮人跟你 一起创事业的能力。而所有的这一切都不是由你的成绩决定的。当然我并不是说，在大学不要好好学，拿到大学毕业证书这是必然的，因为在未来我们会发现这样一 个现象，假如，连大学本科文凭都拿不到的话，你的生命将充满艰难。\n\n\n   现在读过大学的人很多，有人说现在上大学没什么意思，因为找不到工作。确实到现在为止，今年应届毕业生找到工作的比例只有40%左右，但我相信这只是一 个临时现象，因为中国的产业结构还没有调整过来。从历史来看，中国大学生远远不多，因为中国从制造业正在转向咨询、信息、物流、服务等与世界沟通交流的行 业，也就意味着在座的所有大学生都具备这样的工作能力，必然能找到工作。 \n\n\n  一次有个大学生告诉我，俞老师我要创业，不上大学了。我说为什么，他说要向比尔·盖茨学习。我说世界上有几个比尔·盖茨，不就一个嘛，他说没关系，他可以 成为第二个。我说，那你为什么不上大学呢？他说，我考试不及格，上不下去了。这还是没法跟比尔·盖茨比的，人家是觉得自己的知识已经远远超过了老师，觉得 上大学已经是时间的浪费，要把自己的创造力及时的发挥出来，所以钻到自己的汽车库里研究微软去了。这是两种完全不一样的概念。 \n\n\n  当然我刚刚强调的是你学习成绩好并不一定今后就做的好。有一份统计数据，将大学成绩前10名和后10名的同学做过一个调研，以20年一个阶段来说，大学 最后10名的同学财富总量以及获得的社会地位，居然比前10名还要高。这就意味着，即便在大学里最落后的同学也不要放弃自己。比如，我在北大努力了5年， 在毕业的时候就是以全班倒数第五名毕业的，但现在我们班的第一名到第五名全在新东方。所以，我们永远都不要放弃自己。   \n  最精彩的人生是到老年的时候能够写出一部回忆录来，自己会因曾经经历过的生命而感动，会感动别人继续为生命的精彩而奋斗，这时候我才能说我的生命很充实。\n\n我10年前就碰到一个特别令人感动的故事：有一个大学生来找我，因为非常贫困，但想出国，想上新东方的班，但是他没钱所以跟我说他很想上新东方的课，但没 钱，能不能暑假在新东方兼职做教室管理员，并且安排他到班，查完学生的听课证扫完地后就在后面听课，我说当然可以。没想到这个学生又提了个要求，如果两个 月的兼职真的做的很好的话，能否给他500元工资让他买个录音机，我说没有问题。结果那孩子做了两个月，所有接触过他的人都说这孩子刻苦认真，所以到了两 个月后，我给他一千块钱的工资让他买录音机。他买好后，边听着录音机边流着泪。我知道他被自己的行为感动了，以后肯定有大出息，果不其然几年后他被耶鲁大 学以全额奖学金录取了，现在还在美国工作，年薪13万5千美元。所以说只有被自己感动的生命才会精彩。 \n\n\n   其实我也有一些让自己感动的故事，比如说我高考落榜。当时想着一定要考进大学，但没想过进北大，所以就拼命读书。有的时候你会发现你低着头一直往前走，目 标就会在你的后面。所以当我拿到北大录取通知书的时候，真的是仰天大笑然后嚎啕大哭，跟范进中举一模一样。但如果当时没有坚持的话，也许我现在仍然只是一 个农民的儿子。比如，当时我们村有个人跟我一样考了两年，他总分还比我高三分，当时我跟他说一起考第三年吧，但他的母亲说别考了，找个女人结婚算了，但当 时我跟我妈说你让我再考一年，结果第三年我真的考上了。所以我得出两个结论，1、人必须往前跑，不一定要跑的快，但是要跑的久；2、不能停下来，你不能三 天打渔两天晒网，要持之以恒。 \n\n\n  我走到今天没有一天懒惰过，我现在每天依然要工作近16个小时，从高考那天开始每天如此。但我发现，我还是比不过有些同事。从小学到高中，我学习也挺认真 的，成绩总是在前10到20名之间，而在大学我学习更加认真，但最后却以全班倒数第五名毕业。龟兔赛跑的故事我们从小学就知道了，而生活中也经常体现出 来。因为跑得快的人往往会停下来，而跑得慢的不能因为慢就不跑。只要跑，早晚会达到你所向往的终点。所以我们不要去计较大学时候谁的成绩高低，只要不停的 去追求就可以了。 \n\n\n  一个聪明的人一辈子所创造的成就不一定比一个笨的人所创造的多，因为笨的人每天都在创造，而聪明的人可能创造一段时间会停下，即便是爱迪生这种超级天才， 小时候也被认为是个白痴。爱因斯坦九岁才会说话，还好他有个好妈妈一直认为他是个天才，才使他成为一个伟大的科学家。所以当我的儿子到4岁时还不会说话， 我老婆着急地带他到处求医时，我说，别看，4岁不会说话很正常的。我老婆说，为什么正常，我说，不会说话是语言功能发育不完全，不代表头脑就不发达。所以 永远不要用你的现状去判断你的未来，只要你坚持就一定能获得你所意想不到的东西。 \n\n\n  后来我班级里很多同学都联系出国，我看了羡慕，想要追赶他们的步伐，所以也开始联系出国。整整4年，联系了无数的美国大学和专业，没有一个美国大学给我奖 学金。尽管拿到了几张录取通知书，但去美国大使馆签证，每次都拒签。当然，现在我的签证除了伊拉克的没有，其他国家几乎都有了。现在美国给我的签证是10 年多次往返商务签证。因为新东方是在美国上市的，他必须允许我任何一天随时随地都能进入美国。所以当我儿时的朋友到现在还在面向黄河，这辈子还没有走出过 我们镇的时候，我已经走遍了世界各地。大家想，在徐霞客、苏轼那个没有任何交通工具的时代，都能游遍山水，写下许多让我们感动和动人的文字，而在我们这个 科技兴盛的时代，如果没有在世界上留下一些的文字和足迹，你怎么对得起自己。 \n\n\n  有的同学说，俞老师因为你现在有钱了所以可以这么做。坦率的说，以前我没钱我也会这样做。因为小时候我最崇拜的人物就是徐霞客，因为他是我的老乡，住在 我家隔壁。只不过他是400年前住在我家隔壁，要知道地方上的名人对地方上少年的影响是非常巨大的。有次，我坐在长江边上看日出日落，我就在想徐霞客怎么 能走那么远呢？所以也会向往这辈子我是否能跟他走的一样远。 \n\n\n  正是因为有这样一个榜样在，我才会发现高考一次、两次我都不绝望，因为我知道走出农村边界的惟一办法就是考上大学。我想把农村户口变成城市户口，因为当时 城市户口是可以到处走的。尽管我平时很平和，但心中总是有一种愿望，叫做穿越地平线走向远方的渴望，就是看到眼前的地平线我总是不满足的，我总是希望翻开 地平线看看另一边到底是什么样的。 \n\n\n  大家都知道，只要你不断的超越地平线一定会有很多的风景在你眼前展示出来。这跟你有没有钱没关系。而我曾怀揣100元人民币，走到了泰山，走到了黄山，走 到了九华山，走到了庐山。我一边走一边帮人家干活，走到九华山发现没钱了，就睡到一个农民家里。那个农民在江边给我弄了个床，还找我要钱，而我口袋里只有 5块钱。于是，我就说帮他一起插秧来抵消住宿费。他左看右看说，大学生怎么会插秧呢？结果插了一天我插了四分之三，而他只插了四分之一，把他感动的半死不 活。他说，你怎么会插的那么快呢？我说，我14岁那年就获得过我们县的插秧冠军。然后，他晚上杀了一只鸡要我一起喝酒。他越聊越觉得我不像大学生更像农 民。第二天我走的时候，他居然掏了10块钱给我说，我知道你口袋里没钱了，明天还要去庐山，这点钱就给你当路费。 \n\n\n  生命是有各种活法的，但是哪怕你坐到书斋中间，一辈子也要让自己的生命变的伟大。陈景润一辈子没出过书斋，不也是世界上最伟大的数学家？所以不管在什么状 态下也要像一首诗写的那样“相信未来，热爱生命”。所以只有当我们的生命有了期待以后，才会有进步。有的时候，我们选择前进，不是因为我们有多么坚强。有 这么一句话让我很感动，也变成了我的座右铭：“坚持下去不是因为我很坚强，而是因为我别无选择。”新东方有一个运动，叫做徒步50公里。任何一个新东方新 入职的老师和员工都必须徒步50公里，而未来的每一年也都要徒步50公里。很多人从来没走过那么远的路，一般走到10公里就走不动了，尤其是要爬山涉水地 走。每次我都会带着新东方员工走，走到一半的时候会有人想退缩，我说不行，你可以不走，但是把辞职报告先递上来。当走到25公里的时候你只有3个选择，第 一，继续往前走；第二，往后退；但当你走到一半的时候，你往后退也是25公里，还不如坚持往前走呢；第三，站在原地不动。而在人生旅途中停止不前还有什么 希望呢？ \n\n\n  我们人生有很多迷茫和痛苦，而只要你坚持往前走，痛苦往往会解决掉。在走的过程中，我也痛苦得流过泪，也曾经痛苦得嚎啕大哭过，但我知道真的坚持下去不是 因为你坚强而是因为你别无选择。走到最后你会发现总会有成果。我没想到新东方能从培训13个学生，现在变成培训175万学生、其实所有这一切你都不一定要 去想，只要坚持往前走就行了。 \n\n\n  我们生命中总要去追寻一种经历，有的时候我们觉得人连条鱼都不如，因为我在加拿大的时候，我看过加拿大三文鱼回流，每次它回流产卵的时候，我总会发现生命 及其壮观，鱼卵产在沙子里会被其他动物吃掉很多。第二年春天的时候剩下的鱼卵会变成小鱼，小鱼会顺流而下，流到湖里，而在湖里又会被其他鱼类吃掉一些。一 年后，长大的鱼会顺着大河奔入海洋，然后绕太平洋一周，每四年一个循环。如果三文鱼就在海洋中待着不回到湖里产卵，它就不会死，但它是受到内心的召唤集中 在河口开始往前游，一旦游进河的时候就再也不吃任何东西拼命地往前游，然后游到目的地开始配对产卵，产好后就双双死亡。你会看到成千上万的红色死鱼漂在河 上，而老鹰和黑熊就在边上等着。 \n\n\n  我看了后特别感动，一条小小的三文鱼也知道，生的使命是不能放弃。那我们人生的使命呢，比如父母为我们献出了青春财富，把你养育成人。而我们未来变成父母 后也是一样。我们孩子的成长就是你的使命，而我们其他的使命感，如何让自己活得更加幸福，如何帮助别人，让这个社会变得更加有意义。为什么宗教人士会活得 相对简单，因为他们灌输了一种使命感。而连一条鱼都经历了小溪流、湖泊、大海，他尝到了淡水的清香和海水的苦涩，完成了生命的周期。如果我们这一辈子都没 有苦涩，没有幸福和甜美，那生命是很遗憾的。 \n\n\n  而你现在的状况并不决定于你的未来，我在北大的时候受到的打击比较多，首先是身份上的悬殊，确实我是穿着大补丁走进校园的，我们体育老师上课从来不叫我的 名字的，都是叫那个大补丁来做个动作。因为我在农村锻炼过，跳跃性动作做得蛮好看，所以我常常被叫出来做演示。 \n\n\n  开学第一天晚上，全班开班会，我起来讲了一句话。现在新东方的王强老师是我们班级的班长，站起来跟我说你能不能不讲日语。因为我一直在农村上学，所以我们 的语文老师从来没用普通话给我们上过课，我当时根本不知道普通话该怎么说。北大当时按照英语成绩分班，我当时因为高考英语考得蛮好所以被分到了A班，其实 我的听说水平并不好，所以到了A班一个月以后就被贬到了C班，而C班主要是针对那些语音语调及听力障碍的同学。等后来，我发现我和同学的智商真的有差距， 我的那些同学平时看他们学习也并不怎么认真怎么一到期末考试就能考出好成绩，我每天学习时间都要比他们多两三个小时，但每次期末考试都在全班倒数几名。这 让我的心情非常郁闷。 \n\n\n  当时，我们班50个同学，25个男生25个女生。一开始我听完这个数字就特别兴奋，但是没想到我们班的女生没一个正眼瞧我一眼的。到了2001年的时候我 们全班同学聚会，大家从世界各地赶回来。蓦然回首，大家突然发现班上那个挺没出息的，普通话也讲不好的，默默无闻的那个人怎么就成了全班最出色的了。这个 时候女同学们都热情的走上来握住我的手，后悔当初没下手。 \n\n\n  所以后来大学女生问我，俞老师我们现在找男朋友要什么标准，我说很简单，参考我的长相。当然如果长得像我，那是绝对不能放过的。凡是长得比我难看的也不要放过，因为这个世界上的规律就是，越难看的人内涵越丰富。 \n\n   大三的时候我最喜欢读的是《红楼梦》，而且刚好读到林黛玉咳嗽而死的那一章。结果发现自己也在吐血。到医院，医生一查说得了肺结核立刻关起来，一关就是 一年。我跟医生说像我这样的小伙子怎么会得肺结核呢？医生让我讲讲现状。我说，您看我学习特别刻苦，可成绩就是上不去，班里没有一个女孩子喜欢我。他说， 这种情况不得肺结核是完全不可能的。 \n\n\n  但这个病也给我带来了心态上的调整，因为我在大学一二年级，想要追赶我的同学就是我的精神支柱。但是到了三年级，病了一年后我完全改变了，我觉得活着就挺 好。然后我就给自己订了一个最低标准，至少保证大学毕业拿到毕业证书，最后国家给我分配一份工作就挺好。虽然我并没有放弃努力，结果反而获得一个更加开阔 的心胸。所以，到现在为止我学会了永远不要去比，因为总有比你更加优秀的，也总有比你更加落后的。 \n\n\n  这个世界上最正确的是跟自己比，想一想今天是不是比昨天进步了一点，想一想明年是不是比今年更加好一点。想一想，10年以后的你是不是比今年的你要更加出色。这样的心态一直保持到我大学毕业。 \n\n\n  大学毕业的时候，每个人都要上去讲一段话，比如后半辈子怎么过，我就上去讲了这么一段话：我说，同学们大家都很厉害，我追了大家5年没追上，但是请大家记 住了，以后扮演一个骆驼的同学肯定不会放弃自己，你们5年干成的事情我干10年，你们10年干成的事情我干20年，你们20年干成的事情我干40年，实在 不行我会保持心情愉快身体健康，到了80岁后把你们一个个送走了我再走。这是我个人保持到现在的人生态度，而我认为这种人生态度对我来说非常有效。 \n\n\n  有人问我，如果新东方没了怎么办？其实新东方早晚会没的，因为它已经是一个商业化运作的教育机构。大家想一想，前些天我们看到的一个消息，GE公司是美 国的标志，不照样濒临破产了吗？新东方可能以后也会这样，变成历史的痕迹。但是我想，即使新东方没有了我依然很成功，因为我的心态很成功。我追求生命的那 种向往和穿越地平线的渴望不会改变。我认为，新东方给我的是一种精神，一种力量，而不是新东方本身给我带来多少钱，当然如果新东方给我更多的钱，我也愿意 要，不要钱才是傻瓜呢。但更重要的是，有了钱能否做出一些更加有意义的事情来。比如说我现在一直都想做一个小小的私立大学，可能我无法做到像同济大学那么 大，但做到它的十分之一总是可以的吧？我在北京已经买了一块地，正在建大学校区，造完后它就跟新东方的上市公司脱钩了，变成一个非营利性的大学校园，那它 可能就变成了你做的另外一件事情。 \n\n\n  如何把自己的生命变的更充实是最重要的事情，所以说，哪天新东方不存在了是非常正常的。如果新东方没了，我照样会过来跟大家做讲座，而且心情会更加的开 朗。因为没有繁琐的事情了。我只要换个题目就行了今天叫“度过有意义的生命”，下次我改成“我是如何把新东方做没了的”。 \n\n\n  而在大学中，我们要做的几件事情就是：第一，把自己的知识结构打造完整；第二，就是要在大学里尽可能的多交朋友，因为你终身的朋友、合作者一定来自于你的 大学；第三，如果有可能的话，在大学里谈一场比较专一的恋爱，因为回顾我北大的生活一片灰色。我想为什么会是灰色呢？其实，不是因为成绩不好，而是因为在 大学5年我从来没有过花前月下的时光。所以一直成了我大学时代的遗憾。去年北京大学让我给所有北大新生做开学典礼的时候，我给他们强调一句，什么都不重 要，重要的是谈恋爱，而且谈恋爱也不用害怕失败，因为自杀也自杀不了，未名湖就那么浅，跳下去还能爬起来；第四，就是为未来的工作做好打算。未来的工作跟 你有多少朋友、跟你的专业知识学的多少是相关的。好好掌握你的专业，再差的专业也一定有人用，只要你学的好。 \n\n\n  我有一个朋友学的是越南语，越南语的确很少用，但所有的中央领导去越南都要找他，因为他是一流的越南语同声翻译专家。我还有一个大学同学研究蒋介石，研究 了10年，穷困潦倒。但后来他去美国做了一个报告，美国方面帮他召开了一个中国现代史人物研讨会，他在报告上讲了自己的研究经过，结果下面一个老教授热泪 盈眶。下来后一问，这个老教授也在美国研究了30年蒋介石，孤苦伶仃，就是找不到另一个研究蒋介石的，没想到有个“傻瓜”也在研究蒋介石。于是5万美元一 年，让我同学跟着他在美国读研究生，然后读了四年的博士生。读完以后老头退休，他就变成了那个学校的教授。我去看他的时候，他已经在纽约买了套小房子，买 了辆车娶了个老婆养了条狗。当时他跟我说，俞敏洪你看现在这一切都是蒋介石“给”我的。 \n\n\n  我想用这个例子来说明什么呢？就是研究什么不重要，重要的是只要你真的喜欢就去做，然后就会有人用你。反过来，如果你觉得这个专业你不太喜欢，但很适合我 找工作，这要不要学？当然要学。我就是这样一个状态，我从来没喜欢过英语，当初考英语只是因为数学不行。不喜欢英语是因为我的模仿能力不强。像我的班长王 强，能够把任何话都模仿的惟妙惟肖。我普通话练了一年，才练成大家能听懂的样子。我老婆是天津人，跟我一吵架就用天津话骂我，但是我到现在为止只会说一句 天津话。就是当她拿起棍子打我的时候，我向她大吼一声，“干嘛”（天津话）。 \n\n\n  但是后来我发现英语成了我生命中的工具，因为英语，我在北大当了老师。其实当初留北大并不是成绩好，而是当时正好四六级考试，北大各个系的同学都要学两 年英语，结果北大急缺老师。而一些优秀的毕业生都去了外交部、经贸部，工资又高。后来我们系主任急了说，最后5名给我留下来。留下来的5个人现在都变成博 士生导师了，可见现在北大教育质量如何。当然这是句玩笑话，他们后来也经过自己的努力，经历了很多次考试成了很优秀的教师。 \n\n\n  在登山的时候，你会在乎登山杖你喜欢不喜欢吗？不会，你只会在乎能否帮你登上山顶。那么英语就是我的登山杖，尽管我不是特别的喜欢，但我知道我要想攀上更 高的人生的山峰就必须需要这个登山杖。我本来想把自己变成中国英语专家前100位的，后来发现一点戏都没有，因为中国留学生归来的越来越多了，有的在国外 待了10年、20年，回来了怎么看英语水平都比我高。那我只能缩小范围，想变成英语语法专家。后来发现背单词不用动脑筋，所以就开始拼命地背单词，结果变 成了中国还算不错的词汇专家。 \n\n\n  除了学专业外，同学们要在大学里多读书。新东方人读书都非常多。读书多，就意味着眼界更加的开阔，更加会思考问题，更具有创新精神。新东方流传一句话叫做 “底蕴的厚度决定事业的高度”。底蕴的厚度主要来自于两方面，第一多读书，读了大量的书你的知识结构自然就会完整，就会产生智慧；第二就是多人生经历。把 人生经历的智慧和读书的智慧结合起来就会变成真正的大智慧，就会变成你未来创造事业的无穷无尽的源泉和工具。 \n\n\n  比如，新东方招聘重要岗位的人才都是我面试。我只有几个问题，第一你大学读了多少本书，如果你说只读了几十本书，那肯定我不会要你。我心中的最低标准是 200本书，而我在大学里读了800本书。新东方还有更红火的王强老师，在大学里读了1200本书，平均每天一本。有的人会问我，读过了忘了跟没读过有什 么区别呢？其实完全不一样。就像你谈恋爱，一个谈过恋爱后又变成光棍汉的人和一个光棍汉相比是有自信的。因为当他看到别人在谈恋爱的时候，他会在旁边“嘿 嘿，想当初老子也是谈过恋爱的嘛”。实在不行来不及读，你可以到书店看着那些书，记着那些名字用手摸一下，这样也能增加一点人文气质。 \n\n\n  我有一个理念，人活着要过一种诗意的生活，我们有多少时候是停下来看看月亮的，在假期去内蒙看一下漫天的繁星的，有多少同学看着朝霞和晚霞时心中感受过生 命的涌动的。当然也要身体力行。大学时候，有一个非常著名的诗人叫海子，写了著名的诗句“面朝大海，春暖花开”，但非常可惜的是他没能抵抗现实社会的压 力，卧轨自杀了。所以我们说一个人不能只在语言上表达诗意，还要在现实中去表达诗意。所以你必须克服现实中的障碍和挫折。有首诗叫“大漠孤烟直，长河落日 圆”。我对“长河落日圆”有非常深刻的感觉，但对“大漠孤烟直”却没有什么概念。所以，进入北大校门之后第一件事情就是走向沙漠，走向戈壁滩，走向大草 原。而到今天为止，这些地方成了我的精神家园。如果生命中一有过不去的事情，我就去蒙古草原上跟牧民一起骑马。牧民曾经说过，在汉人当中从来没看到像你那 样不要命的。 \n\n\n  回过来讲诗意的生活，在大学里打游戏上MSN不叫诗意的生活，而在一张床上拿着书一边看书然后慢慢地睡着那就是一种诗意。要关注时事政治，要把握一些世界 大事。这种能力将在你日后创业的过程中起到很大的作用。另外就是要尽可能地多交朋友，交朋友首先你要做个好人，你要做一个让人放心的人。在中国企业界就是 这样的状态，如果你是个好心的人，在困难的时候一定会有人帮助。比如，蒙牛的牛根生大家都听说过，他为人处世很实在。所以蒙牛出事后，他需要资金，只需要 打个电话我们就会把钱汇过去。而为什么连合同都不签我们就给他，道理很简单，信任。 \n\n\n  我也碰到过这样的情况，03年的时候遇到SARS，我们马上给学生退学费，新东方的流动资金一下子退光了。而当时我算下来，账上还缺2000万。于是我分 别给两个朋友打了电话，一人一千万当天晚上就搞定了。所以，你变成一个让别人相信的人，比做一个让别人防着你的人，得到的好处要多得多。而建立这种信任， 要做到以下几个要素：要以别人为中心不要以自己为中心；要有服务精神。 \n\n\n  当时我那些大学同学觉得我没出息，但为什么会回来跟我创业呢？这跟我大学里的行为有关。我大学里是个学习不好但挺喜欢帮别人的人。我们宿舍当时从来不排值 日生，因为地全是我扫的。还有就是宿舍的水也基本都是我打，而他们之所以后来放弃国外优秀的条件来和我一起创业还是跟我当时宿舍打水有关系。若干年后，我 去找那些大学同学回来，他们说连你那么没出息的人在中国都赚钱了那我们回来还了得？第二个理由是，我们知道你是个特别好的人，你有饭吃不会给我们喝粥，你 有粥喝不会让我们饿死，所以就回来了。所以在大学毕业连一个朋友都没有的人，这辈子想成功几乎是不可能的。 \n\n\n  还有在大学里要交几个真正能帮助你的人，比如：心胸比你开阔，眼光比你敏锐。我在大学里交的就是这样的朋友，做人就要跟着牛人跑。比如，王强老师有天才的 一面，而这些是我学不到。他喜欢读书，他一进大学就会把生活费一分为二，一份用来买书，一份用来买饭票，饭票吃完了决不用买书的钱，他宁可偷别人的饭票， 我觉得这个习惯很好，我也一分为二，饭票吃完了我就偷他的。每到周末我们就去买书，我不知道买什么书，所以他买什么我跟着买什么，他被我弄烦了说你能不能 不跟着我，我说你是我的班长有责任帮助落后同学。其实我知道他想把我赶走，因为当时他是我们班女生追求的对象，如果我不跟着他他就会带女生出去买书，我当 时就看穿了他这个阴谋。到现在为止我的读书老师就是王强，他的藏书接近6万本，他每当看到有好的便宜的书就会帮我买，贵的会发个消息让我自己买。\n\n\n  到现在为止我都要不断的读书。因为每当聚会，他们谈起好书的时候，一旦我没读过就会被他们说“你大学时候不用功，怎么现在还是这样。”所以，我们的读书氛 围之所以非常的浓厚，最重要的原因就是王强，而你非常需要这样的朋友。还有就是徐小平老师。大学里我觉得这个老师很好，很想认识。一个礼拜后我买了支小钢 笔送给他，敲开他家的门，他问我，你是谁。我说，我是你的学生，听了你的课后很感动，所以想跟你交个朋友，这是我带给你的小礼物。徐小平一看我手中拿着礼 物就让我进去了，进了他家的门发现有一大群年轻老师在那。原来他有个习惯，一到周五晚上都会招一批老师来他家聊天。我当然很想听，问我能不能留下来听，他 说不行啊，我们聊的都是些男男女女的问题，像你这样的纯情少年会被污染的。幸亏我反应快说，徐老师我在这方面刚好需要启蒙教育。机会总是自己发现的。我发 现没有人给他们烧水，于是，我就帮他们烧水煮方便面。连续去了4个礼拜，到了第5个礼拜我不去了。为什么不去，不是因为我烦了，而是我觉得一个人在该显示 重要性的时候一定要显示出来。果然徐小平一个电话过来说，你这个兔崽子怎么还不过来。我知道，不是我离不开他们而是他们离不开我了。从此，在一年的时间 里，我不停听他们聊天，等到我办新东方的时候，我去的第一家就是徐小平家。我跟他说新东方不缺英语老师，但缺有思想的人物，所以希望你回去管理新东方的思 想。所以在大学里要做的另外一件事情就是一定要交朋友，让自己变成一个别人信赖的人。 \n\n\n  而如果能谈一场恋爱还是很不错的。但谈恋爱有一个非常重要的前提条件就是要一心一意地爱。所谓一心一意的爱不是说，大学里只能谈一次恋爱，而是说一次只能谈一个。要爱到一个什么程度呢？要有这样的一个感觉，“为什么我的眼睛充满泪水？是因为我爱你爱的深沉”。 \n\n\n  第二个要素就是当你真的爱上一个人后，要以恰当的方式告诉他你爱他而不能只放在心里。我在大学就吃亏在爱上不少女孩子，但只放在心里，怕被别人拒绝。但 其实人的追求最好还是表现出来，就算被一个女孩子拒绝了，她回家一定会在日记上写上，“今天又有一个男孩追我咯”。有一年去美国，跟一个以前班里很喜欢的 女孩一起吃饭，她和她老公跟我一起吃饭。吃饭的时候我跟她说，其实我在大学对你特别有好感。她当时一拍大腿说当时你为什么不告诉我呢？ \n\n\n  第三条就是谈的要大度，所谓的大度就是说当另一个人爱上其他人的时候一定要大度的对他说，你的幸福就是我的幸福，你的快乐就是我的快乐。我始终觉得人在世界上总是有缘分的，如果大学没有人爱你，在你以后的人生中总是会有人爱你，等你一起牵手走向今后的旅程。 \n\n\n  我是一个特别热爱生命的人我走路连蚂蚁都不敢踩，我想踩死那只公蚂蚁那只母蚂蚁怎么办。我吃鱼都不敢吃，我想吃了那条母鱼那公鱼该多痛苦啊，所以我一般不 吃鱼要吃吃两条。当然，大学的恋爱是一个过程，不管研究生还是本科生，毕业以后真结婚的比恋爱要少的多。比如我们班十几对谈恋爱，大学毕业后结婚了三对， 两年后离婚了两对。现在还剩下一对，这一对就是王强老师和他的夫人，我大学的同班同学。他们两人现在还过着幸福的生活。 \n\n\n  那么如果对大学的爱情有不满的也没有关系，看看我就行了。很多人都以为我不正常了，但是我还是照样地结婚了，照样找到心爱的人，照样生孩子，也有了比较 美好的家庭。总而言之，生活就是这样美好的往前走。有平凡，有激动，有慢慢长夜，也有美丽的日子，这就是我们的生活。 \n\n\n  还有就是工作问题。工作问题是一个比较简单的问题。我相信同济大学的同学在找工作的时候都不会有太大的困难，但是有同学问我要不要创业。人生一辈子不创一 次业一定是一件非常糟糕的事情。人一辈子总是要为自己干件事情，创业就是为自己干的事情。一份工作大家一起干，但是你并不一定大学毕业就要创业。为什么 呢？因为创业需要经验和许多前提条件。 \n\n\n  第一，你的专业知识能在你创业中的运用；第二，你有能和同学朋友相处并且有分配利益关系的能力；第三，你要有对付中国社会如此复杂局面的能力；第四，你要 有基本的商业操作原则或者商业运作知识；第五，自己要是个具有领导力的人；第六，你要有自己领域的运作知识和专业知识。 \n\n\n  比如，你想搞个培训学校，那你的运作知识从什么地方来呢？这个运作知识需要你通过观察别人怎么做得来的。如果当初我直接从北大出来就做新东方，那我是永 远做不成的。我做新东方有两个前提条件。第一个，我在北大做了六年老师，所以做老师做的不错。还有第二个前提条件，我做新东方以前，我在另外一家培训机构 干了近三年，我就在观察它是怎么做的。我碰到许多大学创业失败的人。我说你们怎么不创业了？他们说，同学之间只要一碰到利益关系，互相全是“狗屁”。是不 是这样？是的，但是你会处理了就不是“狗屁”了。我和新东方这帮朋友也有利益关系，但是我不就处理好了吗？所以说现在关键是考虑有没有这样的本领。要创业 但是我鼓励同学们先去某一个行业至少观察一到两年，最好是三到四年，慢慢积累自己的才能，自己也慢慢变得成熟，个性也慢慢变得稳定，最后再创业这样失败的 机会也少了很多。 \n\n\n  创业有两种状态，第一种就是从零做起，我自己就是从零做起，马云也是从零做起。第二种创业就像杨元庆，也算创业，杨元庆是接柳传志的班最后变成了联想老 总。美国著名的管理学家、企业家杰特威尔逊，他也是从一个普通工人做起，做了20年变成公司的老总；在公司老总的位置上干了20年把公司变成了全世界最大 的公司。这也是创业，不一定是自己干。 \n\n\n  有学生问，俞老师，我怎么把一个培训机构和你干得一样大？很简单先到新东方来打扫卫生，如果你把卫生打扫的非常干净，那么我把你提升为卫生部长，如果你 卫生部长干得好你就变成新东方后勤主任，等到你变成新东方后勤主任的时候，我就把你送到哈佛大学去学习了，学习完了回来我就把后勤行政全部交给你，你就变 成后勤行政总裁。第几位？第二位。我“一翘辫子”你就是总裁了对不对？所以我们的成熟是慢慢来的，就像一棵树长大也是慢慢长大，哪有一下子就能变成自己创 业成功的人？虽然这种人还是有的，但也是少数。我是32岁创业的，32岁才有了新东方。所以不要着急，人一辈子做多大的事都无所谓。 \n\n\n  还是我的老话：把生命活得精彩一点。我的比喻就是大树与小草的比喻，还有另外一个比喻：人的生活就像溪流一样，总有一个梦想——流进大海。有的人这一辈子 没有流向大海，这条河就是不完整的。长江流向大海，黄河流向大海，但长江、黄河以自己不同的方式流向大海。长江开山劈石穿过大山流向大海，黄河没有开山劈 石，结果绕过九曲十八弯。但是不管怎么样，生命再弯最后目标不变。我们惟一要记住的就是要像黄河、长江一样不断地向前流，但是不能变成黄河、长江里面的泥 沙，最后自己沉淀下去，把生命给沉淀没了。总而言之，生命的精彩只靠自己不靠别人。从来没有什么救世主，想要活得精彩、幸福，只能靠我们身边的每一个朋友 的共同努力！\n","slug":"俞敏洪在同济大学的的演讲","published":1,"updated":"2022-03-18T01:57:55.099Z","_id":"cl0vrkoqc000m10ln61inejxk","comments":1,"layout":"post","photos":[],"link":"","content":"<p>同济大学的同学们大家晚上好！ </p>\n<p>  其实人活着就挺好，至于生命有没有意义另当别论。活着每天都会有太阳升起来，每天都会看到太阳落下去。你就可以看到朝霞，看到晚霞，看到月亮升起和落下，看到满天的繁星，这就是活着的最美好的意义所在。 </p>\n<p>  没想到同济大学的同学们把我如此“高大”的形象放在大屏幕上，这就是理想与现实的差距。所以我相信同学们看到我的第一眼一定感到非常的失望。实际上，每一 个人都是非常普通的，我们很多时候会发现生命中非常重要的东西跟我们未来的幸福和成功其实没有太多的联系。比如，有人认为，相貌跟未来的成功会有很多的联 系；有人认为，自己的家庭背景会跟成功有必然的联；有人认为，上名牌大学的人会成功，在大学里成绩好的人比学习成绩差的人更加容易取得成功……所有这些因 素可能有部分是对的，但大部分基本无效，比如说相貌。 </p>\n<p>  如果说一个人的相貌和成功有关，那就不会有马云和阿里巴巴，因为如果在座的同学认为马云长得好看，那一定是审美出了问题。 </p>\n<p>  当然，这并不意味着相貌好看的人就做不成事情，比如说，另外一位大家比较熟悉的公司老总百度老总李彦宏。李彦宏非常英俊潇洒，他所有的照片看上去都像电 影明星一样，但是他也取得了成功。所以不管相貌如何，都能取得成功，只不过李彦宏和马云坐在一起吃饭的时候，他们通常不太愿意坐在相邻的椅子上，因为两个 人的对照到了惨不忍睹的地步，解决的方法就是把我放到他们两个中间，起到一个过渡的作用。像我这样，相貌没有什么特点的人也能取得成功。所以不管是男是 女，最重要的是自己内心世界的丰富，自己风度和气质的培养，自己胸怀的扩展以及对理想目标坚定不移的追求。随着年龄的增加，这些会慢慢变成你的智慧，所有 这一切才是构成你成功的真正的本质。 </p>\n<p>  那么成功和家庭背景有没有关系呢？我们常可以看到一些权贵富贾出身的人，他们一出生就含着金钥匙。比如，我们可能会看到，自己左边的一些同学穿着名牌服 装，右边的拎着名牌的皮包，前面坐着市委书记的女儿，后面坐着中央领导的儿子，而你可能就一个来自普通工人家庭的大学生。 </p>\n<p>  有的时候你会心存不满，但这个世界本来就充满着不公平，而很多不公平常常就在你的眼前闪现。你会说，这个世界怎么会对我这样，为什么他什么都有，而我什么 都没有？我在大学里也有过这种很正常的心理。比如，我的同学有部长的儿子、有大学教授的女儿，而我却是一个农民的儿子。3次高考后才走进了北京大学，穿着 布衣挑着扁担走进去的。你会发现你总赶不上他们的状态，倒不如说赶不上他们的脚步。你会发现即使他们停下来一辈子什么都不做，他们所拥有的东西都比你 多。 </p>\n<p>  比如，在大学一年级的时候，班上那个部长的孩子每周五都有开着奔驰280的司机把他接回去。你想我们那个时候连自行车都买不起，他居然坐着奔驰280，那 是一种什么样的感觉。你感到这辈子基本就完蛋了。但是同学们你们要记住一个真理，生命总是往前走的，我们要走一辈子。我们既不是只走过大学四年，或研究 生，我们要走一辈子。可能走到80、90岁，虽然走到80、90岁时，人生到底怎么样你是不知道的，你惟一能做的就是要坚持走下去。所以我非常骄傲地从一 个农民的儿子走到北大最后又走到了今天。我的心态很平衡，但其实我走了很远。当然，有的同学会说，你进了北大就已经很成功了。确实，北大增加了我很多成功 的因素。比如，因为北大读书气氛很浓厚，所以我读了很多的书，思维变得很敏锐。 </p>\n<p>  北大确实有人文的环境，蔡元培的铜像就树立在未名湖边上，但是每年进北大的有好几千人，出北大的也有几千人，能够成功的到底有多少呢？事实上，北大学生成功的比率并不比任何一个大学生成功比例高。 </p>\n<p>  所有的成功意味着你大学毕业后要进一步付出努力，如果大学就意味成功的话，那么也就没有马云了。我跟马云有很多相同的地方，他高考考了3年，我也考了3 年，他考的是英语专业，我也考的是英语专业，第三年我去了北大，他去了杭州师范学院。我相信很多同学都没听说过这个学院，那我觉得我这辈子应该比他更加成 功吧，但是非常不幸的是，从今天来看，阿里巴巴上市的市值就是新东方的3倍，而我除了做成一个新东方便什么都没了。不仅如此，他还有淘宝网、支付宝…… </p>\n<p>  所以，你未来的成功和你上什么大学没有什么联系，只不过以后出国就业更加的容易一点。一辈子能不能走出精彩，大学为你奠定了基础，但不能决定你的一生。到 大学毕业人生也只过了四分之一，接下来的时间我们该怎么过呢？首先是一定要坚持走下去，因为你不活了就什么都没有了。不管你相信不相信来世，我始终相信今 生今世就是我们最好的天堂。所以我最讨厌自杀或者以自杀为威胁，我觉得这是对生命不尊重。有种理念，叫做“好死不如赖活着”。因为从我40多年的人生经验 来体会，你在那坐久了，说不定天上真的会掉下馅饼来，当然也可能掉下块陨石。但不管怎样，不要自我了断，生命中会有很多奇迹发生。假如杨振宁教授不活到 82岁，他怎么知道还能结第二次婚呢？</p>\n<p>  但是同学们，人生总是要有份期待，哪怕是没有希望的期待。同学们可以想一下我们历史上有很多人物，比如说姜太公在河边钓鱼，到了80岁那一年，周文王在他 边上走过，发现这个老头用直的鱼竿钓鱼，跟他一聊便发现这个老头很有智慧，所以把他带回去，两人一起打下了周朝的天下。齐白石同志在50岁的时候还在做木 工，根本不是个伟大的画家，他的所有伟大的作品都是在80岁到90岁的时候完成的。所以生命总有这样的现象，有的人在年轻的时候有作为，有的人中年时候有 作为，有的人老年时候有作为。花儿总是在不同的季节开放，如果所有的鲜花都在春天开放完毕了，到了夏天、秋天、冬天没有任何的花儿开放你还会觉得这个自然 界是如此的美丽动人吗？ </p>\n<p>  所以大家想一想，如果人生所有的精彩都在大学里过完了，后面永远都是平淡，你觉得这人生会完美吗？换句话说，你大学里过的不那么精彩，毕业后却变得越来越 精彩是不是更加好呢？事实证明，我们很多同学在大学里的成绩总是名列前茅，可是大学毕业后却怎么也做不出什么事情来了。因为在社会上，并不是成绩在起作 用。成绩只能证明你智商比别人高，但并不能决定你一辈子就一定有出息。 </p>\n<p>  成功并不仅仅是你的成绩所决定的，最重要的是与社会打交道的能力，为人处世的能力。在各种混乱的人际关系中，寻找机会的能力，以及你最后领导一帮人跟你 一起创事业的能力。而所有的这一切都不是由你的成绩决定的。当然我并不是说，在大学不要好好学，拿到大学毕业证书这是必然的，因为在未来我们会发现这样一 个现象，假如，连大学本科文凭都拿不到的话，你的生命将充满艰难。</p>\n<p>   现在读过大学的人很多，有人说现在上大学没什么意思，因为找不到工作。确实到现在为止，今年应届毕业生找到工作的比例只有40%左右，但我相信这只是一 个临时现象，因为中国的产业结构还没有调整过来。从历史来看，中国大学生远远不多，因为中国从制造业正在转向咨询、信息、物流、服务等与世界沟通交流的行 业，也就意味着在座的所有大学生都具备这样的工作能力，必然能找到工作。 </p>\n<p>  一次有个大学生告诉我，俞老师我要创业，不上大学了。我说为什么，他说要向比尔·盖茨学习。我说世界上有几个比尔·盖茨，不就一个嘛，他说没关系，他可以 成为第二个。我说，那你为什么不上大学呢？他说，我考试不及格，上不下去了。这还是没法跟比尔·盖茨比的，人家是觉得自己的知识已经远远超过了老师，觉得 上大学已经是时间的浪费，要把自己的创造力及时的发挥出来，所以钻到自己的汽车库里研究微软去了。这是两种完全不一样的概念。 </p>\n<p>  当然我刚刚强调的是你学习成绩好并不一定今后就做的好。有一份统计数据，将大学成绩前10名和后10名的同学做过一个调研，以20年一个阶段来说，大学 最后10名的同学财富总量以及获得的社会地位，居然比前10名还要高。这就意味着，即便在大学里最落后的同学也不要放弃自己。比如，我在北大努力了5年， 在毕业的时候就是以全班倒数第五名毕业的，但现在我们班的第一名到第五名全在新东方。所以，我们永远都不要放弃自己。<br>  最精彩的人生是到老年的时候能够写出一部回忆录来，自己会因曾经经历过的生命而感动，会感动别人继续为生命的精彩而奋斗，这时候我才能说我的生命很充实。</p>\n<p>我10年前就碰到一个特别令人感动的故事：有一个大学生来找我，因为非常贫困，但想出国，想上新东方的班，但是他没钱所以跟我说他很想上新东方的课，但没 钱，能不能暑假在新东方兼职做教室管理员，并且安排他到班，查完学生的听课证扫完地后就在后面听课，我说当然可以。没想到这个学生又提了个要求，如果两个 月的兼职真的做的很好的话，能否给他500元工资让他买个录音机，我说没有问题。结果那孩子做了两个月，所有接触过他的人都说这孩子刻苦认真，所以到了两 个月后，我给他一千块钱的工资让他买录音机。他买好后，边听着录音机边流着泪。我知道他被自己的行为感动了，以后肯定有大出息，果不其然几年后他被耶鲁大 学以全额奖学金录取了，现在还在美国工作，年薪13万5千美元。所以说只有被自己感动的生命才会精彩。 </p>\n<p>   其实我也有一些让自己感动的故事，比如说我高考落榜。当时想着一定要考进大学，但没想过进北大，所以就拼命读书。有的时候你会发现你低着头一直往前走，目 标就会在你的后面。所以当我拿到北大录取通知书的时候，真的是仰天大笑然后嚎啕大哭，跟范进中举一模一样。但如果当时没有坚持的话，也许我现在仍然只是一 个农民的儿子。比如，当时我们村有个人跟我一样考了两年，他总分还比我高三分，当时我跟他说一起考第三年吧，但他的母亲说别考了，找个女人结婚算了，但当 时我跟我妈说你让我再考一年，结果第三年我真的考上了。所以我得出两个结论，1、人必须往前跑，不一定要跑的快，但是要跑的久；2、不能停下来，你不能三 天打渔两天晒网，要持之以恒。 </p>\n<p>  我走到今天没有一天懒惰过，我现在每天依然要工作近16个小时，从高考那天开始每天如此。但我发现，我还是比不过有些同事。从小学到高中，我学习也挺认真 的，成绩总是在前10到20名之间，而在大学我学习更加认真，但最后却以全班倒数第五名毕业。龟兔赛跑的故事我们从小学就知道了，而生活中也经常体现出 来。因为跑得快的人往往会停下来，而跑得慢的不能因为慢就不跑。只要跑，早晚会达到你所向往的终点。所以我们不要去计较大学时候谁的成绩高低，只要不停的 去追求就可以了。 </p>\n<p>  一个聪明的人一辈子所创造的成就不一定比一个笨的人所创造的多，因为笨的人每天都在创造，而聪明的人可能创造一段时间会停下，即便是爱迪生这种超级天才， 小时候也被认为是个白痴。爱因斯坦九岁才会说话，还好他有个好妈妈一直认为他是个天才，才使他成为一个伟大的科学家。所以当我的儿子到4岁时还不会说话， 我老婆着急地带他到处求医时，我说，别看，4岁不会说话很正常的。我老婆说，为什么正常，我说，不会说话是语言功能发育不完全，不代表头脑就不发达。所以 永远不要用你的现状去判断你的未来，只要你坚持就一定能获得你所意想不到的东西。 </p>\n<p>  后来我班级里很多同学都联系出国，我看了羡慕，想要追赶他们的步伐，所以也开始联系出国。整整4年，联系了无数的美国大学和专业，没有一个美国大学给我奖 学金。尽管拿到了几张录取通知书，但去美国大使馆签证，每次都拒签。当然，现在我的签证除了伊拉克的没有，其他国家几乎都有了。现在美国给我的签证是10 年多次往返商务签证。因为新东方是在美国上市的，他必须允许我任何一天随时随地都能进入美国。所以当我儿时的朋友到现在还在面向黄河，这辈子还没有走出过 我们镇的时候，我已经走遍了世界各地。大家想，在徐霞客、苏轼那个没有任何交通工具的时代，都能游遍山水，写下许多让我们感动和动人的文字，而在我们这个 科技兴盛的时代，如果没有在世界上留下一些的文字和足迹，你怎么对得起自己。 </p>\n<p>  有的同学说，俞老师因为你现在有钱了所以可以这么做。坦率的说，以前我没钱我也会这样做。因为小时候我最崇拜的人物就是徐霞客，因为他是我的老乡，住在 我家隔壁。只不过他是400年前住在我家隔壁，要知道地方上的名人对地方上少年的影响是非常巨大的。有次，我坐在长江边上看日出日落，我就在想徐霞客怎么 能走那么远呢？所以也会向往这辈子我是否能跟他走的一样远。 </p>\n<p>  正是因为有这样一个榜样在，我才会发现高考一次、两次我都不绝望，因为我知道走出农村边界的惟一办法就是考上大学。我想把农村户口变成城市户口，因为当时 城市户口是可以到处走的。尽管我平时很平和，但心中总是有一种愿望，叫做穿越地平线走向远方的渴望，就是看到眼前的地平线我总是不满足的，我总是希望翻开 地平线看看另一边到底是什么样的。 </p>\n<p>  大家都知道，只要你不断的超越地平线一定会有很多的风景在你眼前展示出来。这跟你有没有钱没关系。而我曾怀揣100元人民币，走到了泰山，走到了黄山，走 到了九华山，走到了庐山。我一边走一边帮人家干活，走到九华山发现没钱了，就睡到一个农民家里。那个农民在江边给我弄了个床，还找我要钱，而我口袋里只有 5块钱。于是，我就说帮他一起插秧来抵消住宿费。他左看右看说，大学生怎么会插秧呢？结果插了一天我插了四分之三，而他只插了四分之一，把他感动的半死不 活。他说，你怎么会插的那么快呢？我说，我14岁那年就获得过我们县的插秧冠军。然后，他晚上杀了一只鸡要我一起喝酒。他越聊越觉得我不像大学生更像农 民。第二天我走的时候，他居然掏了10块钱给我说，我知道你口袋里没钱了，明天还要去庐山，这点钱就给你当路费。 </p>\n<p>  生命是有各种活法的，但是哪怕你坐到书斋中间，一辈子也要让自己的生命变的伟大。陈景润一辈子没出过书斋，不也是世界上最伟大的数学家？所以不管在什么状 态下也要像一首诗写的那样“相信未来，热爱生命”。所以只有当我们的生命有了期待以后，才会有进步。有的时候，我们选择前进，不是因为我们有多么坚强。有 这么一句话让我很感动，也变成了我的座右铭：“坚持下去不是因为我很坚强，而是因为我别无选择。”新东方有一个运动，叫做徒步50公里。任何一个新东方新 入职的老师和员工都必须徒步50公里，而未来的每一年也都要徒步50公里。很多人从来没走过那么远的路，一般走到10公里就走不动了，尤其是要爬山涉水地 走。每次我都会带着新东方员工走，走到一半的时候会有人想退缩，我说不行，你可以不走，但是把辞职报告先递上来。当走到25公里的时候你只有3个选择，第 一，继续往前走；第二，往后退；但当你走到一半的时候，你往后退也是25公里，还不如坚持往前走呢；第三，站在原地不动。而在人生旅途中停止不前还有什么 希望呢？ </p>\n<p>  我们人生有很多迷茫和痛苦，而只要你坚持往前走，痛苦往往会解决掉。在走的过程中，我也痛苦得流过泪，也曾经痛苦得嚎啕大哭过，但我知道真的坚持下去不是 因为你坚强而是因为你别无选择。走到最后你会发现总会有成果。我没想到新东方能从培训13个学生，现在变成培训175万学生、其实所有这一切你都不一定要 去想，只要坚持往前走就行了。 </p>\n<p>  我们生命中总要去追寻一种经历，有的时候我们觉得人连条鱼都不如，因为我在加拿大的时候，我看过加拿大三文鱼回流，每次它回流产卵的时候，我总会发现生命 及其壮观，鱼卵产在沙子里会被其他动物吃掉很多。第二年春天的时候剩下的鱼卵会变成小鱼，小鱼会顺流而下，流到湖里，而在湖里又会被其他鱼类吃掉一些。一 年后，长大的鱼会顺着大河奔入海洋，然后绕太平洋一周，每四年一个循环。如果三文鱼就在海洋中待着不回到湖里产卵，它就不会死，但它是受到内心的召唤集中 在河口开始往前游，一旦游进河的时候就再也不吃任何东西拼命地往前游，然后游到目的地开始配对产卵，产好后就双双死亡。你会看到成千上万的红色死鱼漂在河 上，而老鹰和黑熊就在边上等着。 </p>\n<p>  我看了后特别感动，一条小小的三文鱼也知道，生的使命是不能放弃。那我们人生的使命呢，比如父母为我们献出了青春财富，把你养育成人。而我们未来变成父母 后也是一样。我们孩子的成长就是你的使命，而我们其他的使命感，如何让自己活得更加幸福，如何帮助别人，让这个社会变得更加有意义。为什么宗教人士会活得 相对简单，因为他们灌输了一种使命感。而连一条鱼都经历了小溪流、湖泊、大海，他尝到了淡水的清香和海水的苦涩，完成了生命的周期。如果我们这一辈子都没 有苦涩，没有幸福和甜美，那生命是很遗憾的。 </p>\n<p>  而你现在的状况并不决定于你的未来，我在北大的时候受到的打击比较多，首先是身份上的悬殊，确实我是穿着大补丁走进校园的，我们体育老师上课从来不叫我的 名字的，都是叫那个大补丁来做个动作。因为我在农村锻炼过，跳跃性动作做得蛮好看，所以我常常被叫出来做演示。 </p>\n<p>  开学第一天晚上，全班开班会，我起来讲了一句话。现在新东方的王强老师是我们班级的班长，站起来跟我说你能不能不讲日语。因为我一直在农村上学，所以我们 的语文老师从来没用普通话给我们上过课，我当时根本不知道普通话该怎么说。北大当时按照英语成绩分班，我当时因为高考英语考得蛮好所以被分到了A班，其实 我的听说水平并不好，所以到了A班一个月以后就被贬到了C班，而C班主要是针对那些语音语调及听力障碍的同学。等后来，我发现我和同学的智商真的有差距， 我的那些同学平时看他们学习也并不怎么认真怎么一到期末考试就能考出好成绩，我每天学习时间都要比他们多两三个小时，但每次期末考试都在全班倒数几名。这 让我的心情非常郁闷。 </p>\n<p>  当时，我们班50个同学，25个男生25个女生。一开始我听完这个数字就特别兴奋，但是没想到我们班的女生没一个正眼瞧我一眼的。到了2001年的时候我 们全班同学聚会，大家从世界各地赶回来。蓦然回首，大家突然发现班上那个挺没出息的，普通话也讲不好的，默默无闻的那个人怎么就成了全班最出色的了。这个 时候女同学们都热情的走上来握住我的手，后悔当初没下手。 </p>\n<p>  所以后来大学女生问我，俞老师我们现在找男朋友要什么标准，我说很简单，参考我的长相。当然如果长得像我，那是绝对不能放过的。凡是长得比我难看的也不要放过，因为这个世界上的规律就是，越难看的人内涵越丰富。 </p>\n<p>   大三的时候我最喜欢读的是《红楼梦》，而且刚好读到林黛玉咳嗽而死的那一章。结果发现自己也在吐血。到医院，医生一查说得了肺结核立刻关起来，一关就是 一年。我跟医生说像我这样的小伙子怎么会得肺结核呢？医生让我讲讲现状。我说，您看我学习特别刻苦，可成绩就是上不去，班里没有一个女孩子喜欢我。他说， 这种情况不得肺结核是完全不可能的。 </p>\n<p>  但这个病也给我带来了心态上的调整，因为我在大学一二年级，想要追赶我的同学就是我的精神支柱。但是到了三年级，病了一年后我完全改变了，我觉得活着就挺 好。然后我就给自己订了一个最低标准，至少保证大学毕业拿到毕业证书，最后国家给我分配一份工作就挺好。虽然我并没有放弃努力，结果反而获得一个更加开阔 的心胸。所以，到现在为止我学会了永远不要去比，因为总有比你更加优秀的，也总有比你更加落后的。 </p>\n<p>  这个世界上最正确的是跟自己比，想一想今天是不是比昨天进步了一点，想一想明年是不是比今年更加好一点。想一想，10年以后的你是不是比今年的你要更加出色。这样的心态一直保持到我大学毕业。 </p>\n<p>  大学毕业的时候，每个人都要上去讲一段话，比如后半辈子怎么过，我就上去讲了这么一段话：我说，同学们大家都很厉害，我追了大家5年没追上，但是请大家记 住了，以后扮演一个骆驼的同学肯定不会放弃自己，你们5年干成的事情我干10年，你们10年干成的事情我干20年，你们20年干成的事情我干40年，实在 不行我会保持心情愉快身体健康，到了80岁后把你们一个个送走了我再走。这是我个人保持到现在的人生态度，而我认为这种人生态度对我来说非常有效。 </p>\n<p>  有人问我，如果新东方没了怎么办？其实新东方早晚会没的，因为它已经是一个商业化运作的教育机构。大家想一想，前些天我们看到的一个消息，GE公司是美 国的标志，不照样濒临破产了吗？新东方可能以后也会这样，变成历史的痕迹。但是我想，即使新东方没有了我依然很成功，因为我的心态很成功。我追求生命的那 种向往和穿越地平线的渴望不会改变。我认为，新东方给我的是一种精神，一种力量，而不是新东方本身给我带来多少钱，当然如果新东方给我更多的钱，我也愿意 要，不要钱才是傻瓜呢。但更重要的是，有了钱能否做出一些更加有意义的事情来。比如说我现在一直都想做一个小小的私立大学，可能我无法做到像同济大学那么 大，但做到它的十分之一总是可以的吧？我在北京已经买了一块地，正在建大学校区，造完后它就跟新东方的上市公司脱钩了，变成一个非营利性的大学校园，那它 可能就变成了你做的另外一件事情。 </p>\n<p>  如何把自己的生命变的更充实是最重要的事情，所以说，哪天新东方不存在了是非常正常的。如果新东方没了，我照样会过来跟大家做讲座，而且心情会更加的开 朗。因为没有繁琐的事情了。我只要换个题目就行了今天叫“度过有意义的生命”，下次我改成“我是如何把新东方做没了的”。 </p>\n<p>  而在大学中，我们要做的几件事情就是：第一，把自己的知识结构打造完整；第二，就是要在大学里尽可能的多交朋友，因为你终身的朋友、合作者一定来自于你的 大学；第三，如果有可能的话，在大学里谈一场比较专一的恋爱，因为回顾我北大的生活一片灰色。我想为什么会是灰色呢？其实，不是因为成绩不好，而是因为在 大学5年我从来没有过花前月下的时光。所以一直成了我大学时代的遗憾。去年北京大学让我给所有北大新生做开学典礼的时候，我给他们强调一句，什么都不重 要，重要的是谈恋爱，而且谈恋爱也不用害怕失败，因为自杀也自杀不了，未名湖就那么浅，跳下去还能爬起来；第四，就是为未来的工作做好打算。未来的工作跟 你有多少朋友、跟你的专业知识学的多少是相关的。好好掌握你的专业，再差的专业也一定有人用，只要你学的好。 </p>\n<p>  我有一个朋友学的是越南语，越南语的确很少用，但所有的中央领导去越南都要找他，因为他是一流的越南语同声翻译专家。我还有一个大学同学研究蒋介石，研究 了10年，穷困潦倒。但后来他去美国做了一个报告，美国方面帮他召开了一个中国现代史人物研讨会，他在报告上讲了自己的研究经过，结果下面一个老教授热泪 盈眶。下来后一问，这个老教授也在美国研究了30年蒋介石，孤苦伶仃，就是找不到另一个研究蒋介石的，没想到有个“傻瓜”也在研究蒋介石。于是5万美元一 年，让我同学跟着他在美国读研究生，然后读了四年的博士生。读完以后老头退休，他就变成了那个学校的教授。我去看他的时候，他已经在纽约买了套小房子，买 了辆车娶了个老婆养了条狗。当时他跟我说，俞敏洪你看现在这一切都是蒋介石“给”我的。 </p>\n<p>  我想用这个例子来说明什么呢？就是研究什么不重要，重要的是只要你真的喜欢就去做，然后就会有人用你。反过来，如果你觉得这个专业你不太喜欢，但很适合我 找工作，这要不要学？当然要学。我就是这样一个状态，我从来没喜欢过英语，当初考英语只是因为数学不行。不喜欢英语是因为我的模仿能力不强。像我的班长王 强，能够把任何话都模仿的惟妙惟肖。我普通话练了一年，才练成大家能听懂的样子。我老婆是天津人，跟我一吵架就用天津话骂我，但是我到现在为止只会说一句 天津话。就是当她拿起棍子打我的时候，我向她大吼一声，“干嘛”（天津话）。 </p>\n<p>  但是后来我发现英语成了我生命中的工具，因为英语，我在北大当了老师。其实当初留北大并不是成绩好，而是当时正好四六级考试，北大各个系的同学都要学两 年英语，结果北大急缺老师。而一些优秀的毕业生都去了外交部、经贸部，工资又高。后来我们系主任急了说，最后5名给我留下来。留下来的5个人现在都变成博 士生导师了，可见现在北大教育质量如何。当然这是句玩笑话，他们后来也经过自己的努力，经历了很多次考试成了很优秀的教师。 </p>\n<p>  在登山的时候，你会在乎登山杖你喜欢不喜欢吗？不会，你只会在乎能否帮你登上山顶。那么英语就是我的登山杖，尽管我不是特别的喜欢，但我知道我要想攀上更 高的人生的山峰就必须需要这个登山杖。我本来想把自己变成中国英语专家前100位的，后来发现一点戏都没有，因为中国留学生归来的越来越多了，有的在国外 待了10年、20年，回来了怎么看英语水平都比我高。那我只能缩小范围，想变成英语语法专家。后来发现背单词不用动脑筋，所以就开始拼命地背单词，结果变 成了中国还算不错的词汇专家。 </p>\n<p>  除了学专业外，同学们要在大学里多读书。新东方人读书都非常多。读书多，就意味着眼界更加的开阔，更加会思考问题，更具有创新精神。新东方流传一句话叫做 “底蕴的厚度决定事业的高度”。底蕴的厚度主要来自于两方面，第一多读书，读了大量的书你的知识结构自然就会完整，就会产生智慧；第二就是多人生经历。把 人生经历的智慧和读书的智慧结合起来就会变成真正的大智慧，就会变成你未来创造事业的无穷无尽的源泉和工具。 </p>\n<p>  比如，新东方招聘重要岗位的人才都是我面试。我只有几个问题，第一你大学读了多少本书，如果你说只读了几十本书，那肯定我不会要你。我心中的最低标准是 200本书，而我在大学里读了800本书。新东方还有更红火的王强老师，在大学里读了1200本书，平均每天一本。有的人会问我，读过了忘了跟没读过有什 么区别呢？其实完全不一样。就像你谈恋爱，一个谈过恋爱后又变成光棍汉的人和一个光棍汉相比是有自信的。因为当他看到别人在谈恋爱的时候，他会在旁边“嘿 嘿，想当初老子也是谈过恋爱的嘛”。实在不行来不及读，你可以到书店看着那些书，记着那些名字用手摸一下，这样也能增加一点人文气质。 </p>\n<p>  我有一个理念，人活着要过一种诗意的生活，我们有多少时候是停下来看看月亮的，在假期去内蒙看一下漫天的繁星的，有多少同学看着朝霞和晚霞时心中感受过生 命的涌动的。当然也要身体力行。大学时候，有一个非常著名的诗人叫海子，写了著名的诗句“面朝大海，春暖花开”，但非常可惜的是他没能抵抗现实社会的压 力，卧轨自杀了。所以我们说一个人不能只在语言上表达诗意，还要在现实中去表达诗意。所以你必须克服现实中的障碍和挫折。有首诗叫“大漠孤烟直，长河落日 圆”。我对“长河落日圆”有非常深刻的感觉，但对“大漠孤烟直”却没有什么概念。所以，进入北大校门之后第一件事情就是走向沙漠，走向戈壁滩，走向大草 原。而到今天为止，这些地方成了我的精神家园。如果生命中一有过不去的事情，我就去蒙古草原上跟牧民一起骑马。牧民曾经说过，在汉人当中从来没看到像你那 样不要命的。 </p>\n<p>  回过来讲诗意的生活，在大学里打游戏上MSN不叫诗意的生活，而在一张床上拿着书一边看书然后慢慢地睡着那就是一种诗意。要关注时事政治，要把握一些世界 大事。这种能力将在你日后创业的过程中起到很大的作用。另外就是要尽可能地多交朋友，交朋友首先你要做个好人，你要做一个让人放心的人。在中国企业界就是 这样的状态，如果你是个好心的人，在困难的时候一定会有人帮助。比如，蒙牛的牛根生大家都听说过，他为人处世很实在。所以蒙牛出事后，他需要资金，只需要 打个电话我们就会把钱汇过去。而为什么连合同都不签我们就给他，道理很简单，信任。 </p>\n<p>  我也碰到过这样的情况，03年的时候遇到SARS，我们马上给学生退学费，新东方的流动资金一下子退光了。而当时我算下来，账上还缺2000万。于是我分 别给两个朋友打了电话，一人一千万当天晚上就搞定了。所以，你变成一个让别人相信的人，比做一个让别人防着你的人，得到的好处要多得多。而建立这种信任， 要做到以下几个要素：要以别人为中心不要以自己为中心；要有服务精神。 </p>\n<p>  当时我那些大学同学觉得我没出息，但为什么会回来跟我创业呢？这跟我大学里的行为有关。我大学里是个学习不好但挺喜欢帮别人的人。我们宿舍当时从来不排值 日生，因为地全是我扫的。还有就是宿舍的水也基本都是我打，而他们之所以后来放弃国外优秀的条件来和我一起创业还是跟我当时宿舍打水有关系。若干年后，我 去找那些大学同学回来，他们说连你那么没出息的人在中国都赚钱了那我们回来还了得？第二个理由是，我们知道你是个特别好的人，你有饭吃不会给我们喝粥，你 有粥喝不会让我们饿死，所以就回来了。所以在大学毕业连一个朋友都没有的人，这辈子想成功几乎是不可能的。 </p>\n<p>  还有在大学里要交几个真正能帮助你的人，比如：心胸比你开阔，眼光比你敏锐。我在大学里交的就是这样的朋友，做人就要跟着牛人跑。比如，王强老师有天才的 一面，而这些是我学不到。他喜欢读书，他一进大学就会把生活费一分为二，一份用来买书，一份用来买饭票，饭票吃完了决不用买书的钱，他宁可偷别人的饭票， 我觉得这个习惯很好，我也一分为二，饭票吃完了我就偷他的。每到周末我们就去买书，我不知道买什么书，所以他买什么我跟着买什么，他被我弄烦了说你能不能 不跟着我，我说你是我的班长有责任帮助落后同学。其实我知道他想把我赶走，因为当时他是我们班女生追求的对象，如果我不跟着他他就会带女生出去买书，我当 时就看穿了他这个阴谋。到现在为止我的读书老师就是王强，他的藏书接近6万本，他每当看到有好的便宜的书就会帮我买，贵的会发个消息让我自己买。</p>\n<p>  到现在为止我都要不断的读书。因为每当聚会，他们谈起好书的时候，一旦我没读过就会被他们说“你大学时候不用功，怎么现在还是这样。”所以，我们的读书氛 围之所以非常的浓厚，最重要的原因就是王强，而你非常需要这样的朋友。还有就是徐小平老师。大学里我觉得这个老师很好，很想认识。一个礼拜后我买了支小钢 笔送给他，敲开他家的门，他问我，你是谁。我说，我是你的学生，听了你的课后很感动，所以想跟你交个朋友，这是我带给你的小礼物。徐小平一看我手中拿着礼 物就让我进去了，进了他家的门发现有一大群年轻老师在那。原来他有个习惯，一到周五晚上都会招一批老师来他家聊天。我当然很想听，问我能不能留下来听，他 说不行啊，我们聊的都是些男男女女的问题，像你这样的纯情少年会被污染的。幸亏我反应快说，徐老师我在这方面刚好需要启蒙教育。机会总是自己发现的。我发 现没有人给他们烧水，于是，我就帮他们烧水煮方便面。连续去了4个礼拜，到了第5个礼拜我不去了。为什么不去，不是因为我烦了，而是我觉得一个人在该显示 重要性的时候一定要显示出来。果然徐小平一个电话过来说，你这个兔崽子怎么还不过来。我知道，不是我离不开他们而是他们离不开我了。从此，在一年的时间 里，我不停听他们聊天，等到我办新东方的时候，我去的第一家就是徐小平家。我跟他说新东方不缺英语老师，但缺有思想的人物，所以希望你回去管理新东方的思 想。所以在大学里要做的另外一件事情就是一定要交朋友，让自己变成一个别人信赖的人。 </p>\n<p>  而如果能谈一场恋爱还是很不错的。但谈恋爱有一个非常重要的前提条件就是要一心一意地爱。所谓一心一意的爱不是说，大学里只能谈一次恋爱，而是说一次只能谈一个。要爱到一个什么程度呢？要有这样的一个感觉，“为什么我的眼睛充满泪水？是因为我爱你爱的深沉”。 </p>\n<p>  第二个要素就是当你真的爱上一个人后，要以恰当的方式告诉他你爱他而不能只放在心里。我在大学就吃亏在爱上不少女孩子，但只放在心里，怕被别人拒绝。但 其实人的追求最好还是表现出来，就算被一个女孩子拒绝了，她回家一定会在日记上写上，“今天又有一个男孩追我咯”。有一年去美国，跟一个以前班里很喜欢的 女孩一起吃饭，她和她老公跟我一起吃饭。吃饭的时候我跟她说，其实我在大学对你特别有好感。她当时一拍大腿说当时你为什么不告诉我呢？ </p>\n<p>  第三条就是谈的要大度，所谓的大度就是说当另一个人爱上其他人的时候一定要大度的对他说，你的幸福就是我的幸福，你的快乐就是我的快乐。我始终觉得人在世界上总是有缘分的，如果大学没有人爱你，在你以后的人生中总是会有人爱你，等你一起牵手走向今后的旅程。 </p>\n<p>  我是一个特别热爱生命的人我走路连蚂蚁都不敢踩，我想踩死那只公蚂蚁那只母蚂蚁怎么办。我吃鱼都不敢吃，我想吃了那条母鱼那公鱼该多痛苦啊，所以我一般不 吃鱼要吃吃两条。当然，大学的恋爱是一个过程，不管研究生还是本科生，毕业以后真结婚的比恋爱要少的多。比如我们班十几对谈恋爱，大学毕业后结婚了三对， 两年后离婚了两对。现在还剩下一对，这一对就是王强老师和他的夫人，我大学的同班同学。他们两人现在还过着幸福的生活。 </p>\n<p>  那么如果对大学的爱情有不满的也没有关系，看看我就行了。很多人都以为我不正常了，但是我还是照样地结婚了，照样找到心爱的人，照样生孩子，也有了比较 美好的家庭。总而言之，生活就是这样美好的往前走。有平凡，有激动，有慢慢长夜，也有美丽的日子，这就是我们的生活。 </p>\n<p>  还有就是工作问题。工作问题是一个比较简单的问题。我相信同济大学的同学在找工作的时候都不会有太大的困难，但是有同学问我要不要创业。人生一辈子不创一 次业一定是一件非常糟糕的事情。人一辈子总是要为自己干件事情，创业就是为自己干的事情。一份工作大家一起干，但是你并不一定大学毕业就要创业。为什么 呢？因为创业需要经验和许多前提条件。 </p>\n<p>  第一，你的专业知识能在你创业中的运用；第二，你有能和同学朋友相处并且有分配利益关系的能力；第三，你要有对付中国社会如此复杂局面的能力；第四，你要 有基本的商业操作原则或者商业运作知识；第五，自己要是个具有领导力的人；第六，你要有自己领域的运作知识和专业知识。 </p>\n<p>  比如，你想搞个培训学校，那你的运作知识从什么地方来呢？这个运作知识需要你通过观察别人怎么做得来的。如果当初我直接从北大出来就做新东方，那我是永 远做不成的。我做新东方有两个前提条件。第一个，我在北大做了六年老师，所以做老师做的不错。还有第二个前提条件，我做新东方以前，我在另外一家培训机构 干了近三年，我就在观察它是怎么做的。我碰到许多大学创业失败的人。我说你们怎么不创业了？他们说，同学之间只要一碰到利益关系，互相全是“狗屁”。是不 是这样？是的，但是你会处理了就不是“狗屁”了。我和新东方这帮朋友也有利益关系，但是我不就处理好了吗？所以说现在关键是考虑有没有这样的本领。要创业 但是我鼓励同学们先去某一个行业至少观察一到两年，最好是三到四年，慢慢积累自己的才能，自己也慢慢变得成熟，个性也慢慢变得稳定，最后再创业这样失败的 机会也少了很多。 </p>\n<p>  创业有两种状态，第一种就是从零做起，我自己就是从零做起，马云也是从零做起。第二种创业就像杨元庆，也算创业，杨元庆是接柳传志的班最后变成了联想老 总。美国著名的管理学家、企业家杰特威尔逊，他也是从一个普通工人做起，做了20年变成公司的老总；在公司老总的位置上干了20年把公司变成了全世界最大 的公司。这也是创业，不一定是自己干。 </p>\n<p>  有学生问，俞老师，我怎么把一个培训机构和你干得一样大？很简单先到新东方来打扫卫生，如果你把卫生打扫的非常干净，那么我把你提升为卫生部长，如果你 卫生部长干得好你就变成新东方后勤主任，等到你变成新东方后勤主任的时候，我就把你送到哈佛大学去学习了，学习完了回来我就把后勤行政全部交给你，你就变 成后勤行政总裁。第几位？第二位。我“一翘辫子”你就是总裁了对不对？所以我们的成熟是慢慢来的，就像一棵树长大也是慢慢长大，哪有一下子就能变成自己创 业成功的人？虽然这种人还是有的，但也是少数。我是32岁创业的，32岁才有了新东方。所以不要着急，人一辈子做多大的事都无所谓。 </p>\n<p>  还是我的老话：把生命活得精彩一点。我的比喻就是大树与小草的比喻，还有另外一个比喻：人的生活就像溪流一样，总有一个梦想——流进大海。有的人这一辈子 没有流向大海，这条河就是不完整的。长江流向大海，黄河流向大海，但长江、黄河以自己不同的方式流向大海。长江开山劈石穿过大山流向大海，黄河没有开山劈 石，结果绕过九曲十八弯。但是不管怎么样，生命再弯最后目标不变。我们惟一要记住的就是要像黄河、长江一样不断地向前流，但是不能变成黄河、长江里面的泥 沙，最后自己沉淀下去，把生命给沉淀没了。总而言之，生命的精彩只靠自己不靠别人。从来没有什么救世主，想要活得精彩、幸福，只能靠我们身边的每一个朋友 的共同努力！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>同济大学的同学们大家晚上好！ </p>\n<p>  其实人活着就挺好，至于生命有没有意义另当别论。活着每天都会有太阳升起来，每天都会看到太阳落下去。你就可以看到朝霞，看到晚霞，看到月亮升起和落下，看到满天的繁星，这就是活着的最美好的意义所在。 </p>\n<p>  没想到同济大学的同学们把我如此“高大”的形象放在大屏幕上，这就是理想与现实的差距。所以我相信同学们看到我的第一眼一定感到非常的失望。实际上，每一 个人都是非常普通的，我们很多时候会发现生命中非常重要的东西跟我们未来的幸福和成功其实没有太多的联系。比如，有人认为，相貌跟未来的成功会有很多的联 系；有人认为，自己的家庭背景会跟成功有必然的联；有人认为，上名牌大学的人会成功，在大学里成绩好的人比学习成绩差的人更加容易取得成功……所有这些因 素可能有部分是对的，但大部分基本无效，比如说相貌。 </p>\n<p>  如果说一个人的相貌和成功有关，那就不会有马云和阿里巴巴，因为如果在座的同学认为马云长得好看，那一定是审美出了问题。 </p>\n<p>  当然，这并不意味着相貌好看的人就做不成事情，比如说，另外一位大家比较熟悉的公司老总百度老总李彦宏。李彦宏非常英俊潇洒，他所有的照片看上去都像电 影明星一样，但是他也取得了成功。所以不管相貌如何，都能取得成功，只不过李彦宏和马云坐在一起吃饭的时候，他们通常不太愿意坐在相邻的椅子上，因为两个 人的对照到了惨不忍睹的地步，解决的方法就是把我放到他们两个中间，起到一个过渡的作用。像我这样，相貌没有什么特点的人也能取得成功。所以不管是男是 女，最重要的是自己内心世界的丰富，自己风度和气质的培养，自己胸怀的扩展以及对理想目标坚定不移的追求。随着年龄的增加，这些会慢慢变成你的智慧，所有 这一切才是构成你成功的真正的本质。 </p>\n<p>  那么成功和家庭背景有没有关系呢？我们常可以看到一些权贵富贾出身的人，他们一出生就含着金钥匙。比如，我们可能会看到，自己左边的一些同学穿着名牌服 装，右边的拎着名牌的皮包，前面坐着市委书记的女儿，后面坐着中央领导的儿子，而你可能就一个来自普通工人家庭的大学生。 </p>\n<p>  有的时候你会心存不满，但这个世界本来就充满着不公平，而很多不公平常常就在你的眼前闪现。你会说，这个世界怎么会对我这样，为什么他什么都有，而我什么 都没有？我在大学里也有过这种很正常的心理。比如，我的同学有部长的儿子、有大学教授的女儿，而我却是一个农民的儿子。3次高考后才走进了北京大学，穿着 布衣挑着扁担走进去的。你会发现你总赶不上他们的状态，倒不如说赶不上他们的脚步。你会发现即使他们停下来一辈子什么都不做，他们所拥有的东西都比你 多。 </p>\n<p>  比如，在大学一年级的时候，班上那个部长的孩子每周五都有开着奔驰280的司机把他接回去。你想我们那个时候连自行车都买不起，他居然坐着奔驰280，那 是一种什么样的感觉。你感到这辈子基本就完蛋了。但是同学们你们要记住一个真理，生命总是往前走的，我们要走一辈子。我们既不是只走过大学四年，或研究 生，我们要走一辈子。可能走到80、90岁，虽然走到80、90岁时，人生到底怎么样你是不知道的，你惟一能做的就是要坚持走下去。所以我非常骄傲地从一 个农民的儿子走到北大最后又走到了今天。我的心态很平衡，但其实我走了很远。当然，有的同学会说，你进了北大就已经很成功了。确实，北大增加了我很多成功 的因素。比如，因为北大读书气氛很浓厚，所以我读了很多的书，思维变得很敏锐。 </p>\n<p>  北大确实有人文的环境，蔡元培的铜像就树立在未名湖边上，但是每年进北大的有好几千人，出北大的也有几千人，能够成功的到底有多少呢？事实上，北大学生成功的比率并不比任何一个大学生成功比例高。 </p>\n<p>  所有的成功意味着你大学毕业后要进一步付出努力，如果大学就意味成功的话，那么也就没有马云了。我跟马云有很多相同的地方，他高考考了3年，我也考了3 年，他考的是英语专业，我也考的是英语专业，第三年我去了北大，他去了杭州师范学院。我相信很多同学都没听说过这个学院，那我觉得我这辈子应该比他更加成 功吧，但是非常不幸的是，从今天来看，阿里巴巴上市的市值就是新东方的3倍，而我除了做成一个新东方便什么都没了。不仅如此，他还有淘宝网、支付宝…… </p>\n<p>  所以，你未来的成功和你上什么大学没有什么联系，只不过以后出国就业更加的容易一点。一辈子能不能走出精彩，大学为你奠定了基础，但不能决定你的一生。到 大学毕业人生也只过了四分之一，接下来的时间我们该怎么过呢？首先是一定要坚持走下去，因为你不活了就什么都没有了。不管你相信不相信来世，我始终相信今 生今世就是我们最好的天堂。所以我最讨厌自杀或者以自杀为威胁，我觉得这是对生命不尊重。有种理念，叫做“好死不如赖活着”。因为从我40多年的人生经验 来体会，你在那坐久了，说不定天上真的会掉下馅饼来，当然也可能掉下块陨石。但不管怎样，不要自我了断，生命中会有很多奇迹发生。假如杨振宁教授不活到 82岁，他怎么知道还能结第二次婚呢？</p>\n<p>  但是同学们，人生总是要有份期待，哪怕是没有希望的期待。同学们可以想一下我们历史上有很多人物，比如说姜太公在河边钓鱼，到了80岁那一年，周文王在他 边上走过，发现这个老头用直的鱼竿钓鱼，跟他一聊便发现这个老头很有智慧，所以把他带回去，两人一起打下了周朝的天下。齐白石同志在50岁的时候还在做木 工，根本不是个伟大的画家，他的所有伟大的作品都是在80岁到90岁的时候完成的。所以生命总有这样的现象，有的人在年轻的时候有作为，有的人中年时候有 作为，有的人老年时候有作为。花儿总是在不同的季节开放，如果所有的鲜花都在春天开放完毕了，到了夏天、秋天、冬天没有任何的花儿开放你还会觉得这个自然 界是如此的美丽动人吗？ </p>\n<p>  所以大家想一想，如果人生所有的精彩都在大学里过完了，后面永远都是平淡，你觉得这人生会完美吗？换句话说，你大学里过的不那么精彩，毕业后却变得越来越 精彩是不是更加好呢？事实证明，我们很多同学在大学里的成绩总是名列前茅，可是大学毕业后却怎么也做不出什么事情来了。因为在社会上，并不是成绩在起作 用。成绩只能证明你智商比别人高，但并不能决定你一辈子就一定有出息。 </p>\n<p>  成功并不仅仅是你的成绩所决定的，最重要的是与社会打交道的能力，为人处世的能力。在各种混乱的人际关系中，寻找机会的能力，以及你最后领导一帮人跟你 一起创事业的能力。而所有的这一切都不是由你的成绩决定的。当然我并不是说，在大学不要好好学，拿到大学毕业证书这是必然的，因为在未来我们会发现这样一 个现象，假如，连大学本科文凭都拿不到的话，你的生命将充满艰难。</p>\n<p>   现在读过大学的人很多，有人说现在上大学没什么意思，因为找不到工作。确实到现在为止，今年应届毕业生找到工作的比例只有40%左右，但我相信这只是一 个临时现象，因为中国的产业结构还没有调整过来。从历史来看，中国大学生远远不多，因为中国从制造业正在转向咨询、信息、物流、服务等与世界沟通交流的行 业，也就意味着在座的所有大学生都具备这样的工作能力，必然能找到工作。 </p>\n<p>  一次有个大学生告诉我，俞老师我要创业，不上大学了。我说为什么，他说要向比尔·盖茨学习。我说世界上有几个比尔·盖茨，不就一个嘛，他说没关系，他可以 成为第二个。我说，那你为什么不上大学呢？他说，我考试不及格，上不下去了。这还是没法跟比尔·盖茨比的，人家是觉得自己的知识已经远远超过了老师，觉得 上大学已经是时间的浪费，要把自己的创造力及时的发挥出来，所以钻到自己的汽车库里研究微软去了。这是两种完全不一样的概念。 </p>\n<p>  当然我刚刚强调的是你学习成绩好并不一定今后就做的好。有一份统计数据，将大学成绩前10名和后10名的同学做过一个调研，以20年一个阶段来说，大学 最后10名的同学财富总量以及获得的社会地位，居然比前10名还要高。这就意味着，即便在大学里最落后的同学也不要放弃自己。比如，我在北大努力了5年， 在毕业的时候就是以全班倒数第五名毕业的，但现在我们班的第一名到第五名全在新东方。所以，我们永远都不要放弃自己。<br>  最精彩的人生是到老年的时候能够写出一部回忆录来，自己会因曾经经历过的生命而感动，会感动别人继续为生命的精彩而奋斗，这时候我才能说我的生命很充实。</p>\n<p>我10年前就碰到一个特别令人感动的故事：有一个大学生来找我，因为非常贫困，但想出国，想上新东方的班，但是他没钱所以跟我说他很想上新东方的课，但没 钱，能不能暑假在新东方兼职做教室管理员，并且安排他到班，查完学生的听课证扫完地后就在后面听课，我说当然可以。没想到这个学生又提了个要求，如果两个 月的兼职真的做的很好的话，能否给他500元工资让他买个录音机，我说没有问题。结果那孩子做了两个月，所有接触过他的人都说这孩子刻苦认真，所以到了两 个月后，我给他一千块钱的工资让他买录音机。他买好后，边听着录音机边流着泪。我知道他被自己的行为感动了，以后肯定有大出息，果不其然几年后他被耶鲁大 学以全额奖学金录取了，现在还在美国工作，年薪13万5千美元。所以说只有被自己感动的生命才会精彩。 </p>\n<p>   其实我也有一些让自己感动的故事，比如说我高考落榜。当时想着一定要考进大学，但没想过进北大，所以就拼命读书。有的时候你会发现你低着头一直往前走，目 标就会在你的后面。所以当我拿到北大录取通知书的时候，真的是仰天大笑然后嚎啕大哭，跟范进中举一模一样。但如果当时没有坚持的话，也许我现在仍然只是一 个农民的儿子。比如，当时我们村有个人跟我一样考了两年，他总分还比我高三分，当时我跟他说一起考第三年吧，但他的母亲说别考了，找个女人结婚算了，但当 时我跟我妈说你让我再考一年，结果第三年我真的考上了。所以我得出两个结论，1、人必须往前跑，不一定要跑的快，但是要跑的久；2、不能停下来，你不能三 天打渔两天晒网，要持之以恒。 </p>\n<p>  我走到今天没有一天懒惰过，我现在每天依然要工作近16个小时，从高考那天开始每天如此。但我发现，我还是比不过有些同事。从小学到高中，我学习也挺认真 的，成绩总是在前10到20名之间，而在大学我学习更加认真，但最后却以全班倒数第五名毕业。龟兔赛跑的故事我们从小学就知道了，而生活中也经常体现出 来。因为跑得快的人往往会停下来，而跑得慢的不能因为慢就不跑。只要跑，早晚会达到你所向往的终点。所以我们不要去计较大学时候谁的成绩高低，只要不停的 去追求就可以了。 </p>\n<p>  一个聪明的人一辈子所创造的成就不一定比一个笨的人所创造的多，因为笨的人每天都在创造，而聪明的人可能创造一段时间会停下，即便是爱迪生这种超级天才， 小时候也被认为是个白痴。爱因斯坦九岁才会说话，还好他有个好妈妈一直认为他是个天才，才使他成为一个伟大的科学家。所以当我的儿子到4岁时还不会说话， 我老婆着急地带他到处求医时，我说，别看，4岁不会说话很正常的。我老婆说，为什么正常，我说，不会说话是语言功能发育不完全，不代表头脑就不发达。所以 永远不要用你的现状去判断你的未来，只要你坚持就一定能获得你所意想不到的东西。 </p>\n<p>  后来我班级里很多同学都联系出国，我看了羡慕，想要追赶他们的步伐，所以也开始联系出国。整整4年，联系了无数的美国大学和专业，没有一个美国大学给我奖 学金。尽管拿到了几张录取通知书，但去美国大使馆签证，每次都拒签。当然，现在我的签证除了伊拉克的没有，其他国家几乎都有了。现在美国给我的签证是10 年多次往返商务签证。因为新东方是在美国上市的，他必须允许我任何一天随时随地都能进入美国。所以当我儿时的朋友到现在还在面向黄河，这辈子还没有走出过 我们镇的时候，我已经走遍了世界各地。大家想，在徐霞客、苏轼那个没有任何交通工具的时代，都能游遍山水，写下许多让我们感动和动人的文字，而在我们这个 科技兴盛的时代，如果没有在世界上留下一些的文字和足迹，你怎么对得起自己。 </p>\n<p>  有的同学说，俞老师因为你现在有钱了所以可以这么做。坦率的说，以前我没钱我也会这样做。因为小时候我最崇拜的人物就是徐霞客，因为他是我的老乡，住在 我家隔壁。只不过他是400年前住在我家隔壁，要知道地方上的名人对地方上少年的影响是非常巨大的。有次，我坐在长江边上看日出日落，我就在想徐霞客怎么 能走那么远呢？所以也会向往这辈子我是否能跟他走的一样远。 </p>\n<p>  正是因为有这样一个榜样在，我才会发现高考一次、两次我都不绝望，因为我知道走出农村边界的惟一办法就是考上大学。我想把农村户口变成城市户口，因为当时 城市户口是可以到处走的。尽管我平时很平和，但心中总是有一种愿望，叫做穿越地平线走向远方的渴望，就是看到眼前的地平线我总是不满足的，我总是希望翻开 地平线看看另一边到底是什么样的。 </p>\n<p>  大家都知道，只要你不断的超越地平线一定会有很多的风景在你眼前展示出来。这跟你有没有钱没关系。而我曾怀揣100元人民币，走到了泰山，走到了黄山，走 到了九华山，走到了庐山。我一边走一边帮人家干活，走到九华山发现没钱了，就睡到一个农民家里。那个农民在江边给我弄了个床，还找我要钱，而我口袋里只有 5块钱。于是，我就说帮他一起插秧来抵消住宿费。他左看右看说，大学生怎么会插秧呢？结果插了一天我插了四分之三，而他只插了四分之一，把他感动的半死不 活。他说，你怎么会插的那么快呢？我说，我14岁那年就获得过我们县的插秧冠军。然后，他晚上杀了一只鸡要我一起喝酒。他越聊越觉得我不像大学生更像农 民。第二天我走的时候，他居然掏了10块钱给我说，我知道你口袋里没钱了，明天还要去庐山，这点钱就给你当路费。 </p>\n<p>  生命是有各种活法的，但是哪怕你坐到书斋中间，一辈子也要让自己的生命变的伟大。陈景润一辈子没出过书斋，不也是世界上最伟大的数学家？所以不管在什么状 态下也要像一首诗写的那样“相信未来，热爱生命”。所以只有当我们的生命有了期待以后，才会有进步。有的时候，我们选择前进，不是因为我们有多么坚强。有 这么一句话让我很感动，也变成了我的座右铭：“坚持下去不是因为我很坚强，而是因为我别无选择。”新东方有一个运动，叫做徒步50公里。任何一个新东方新 入职的老师和员工都必须徒步50公里，而未来的每一年也都要徒步50公里。很多人从来没走过那么远的路，一般走到10公里就走不动了，尤其是要爬山涉水地 走。每次我都会带着新东方员工走，走到一半的时候会有人想退缩，我说不行，你可以不走，但是把辞职报告先递上来。当走到25公里的时候你只有3个选择，第 一，继续往前走；第二，往后退；但当你走到一半的时候，你往后退也是25公里，还不如坚持往前走呢；第三，站在原地不动。而在人生旅途中停止不前还有什么 希望呢？ </p>\n<p>  我们人生有很多迷茫和痛苦，而只要你坚持往前走，痛苦往往会解决掉。在走的过程中，我也痛苦得流过泪，也曾经痛苦得嚎啕大哭过，但我知道真的坚持下去不是 因为你坚强而是因为你别无选择。走到最后你会发现总会有成果。我没想到新东方能从培训13个学生，现在变成培训175万学生、其实所有这一切你都不一定要 去想，只要坚持往前走就行了。 </p>\n<p>  我们生命中总要去追寻一种经历，有的时候我们觉得人连条鱼都不如，因为我在加拿大的时候，我看过加拿大三文鱼回流，每次它回流产卵的时候，我总会发现生命 及其壮观，鱼卵产在沙子里会被其他动物吃掉很多。第二年春天的时候剩下的鱼卵会变成小鱼，小鱼会顺流而下，流到湖里，而在湖里又会被其他鱼类吃掉一些。一 年后，长大的鱼会顺着大河奔入海洋，然后绕太平洋一周，每四年一个循环。如果三文鱼就在海洋中待着不回到湖里产卵，它就不会死，但它是受到内心的召唤集中 在河口开始往前游，一旦游进河的时候就再也不吃任何东西拼命地往前游，然后游到目的地开始配对产卵，产好后就双双死亡。你会看到成千上万的红色死鱼漂在河 上，而老鹰和黑熊就在边上等着。 </p>\n<p>  我看了后特别感动，一条小小的三文鱼也知道，生的使命是不能放弃。那我们人生的使命呢，比如父母为我们献出了青春财富，把你养育成人。而我们未来变成父母 后也是一样。我们孩子的成长就是你的使命，而我们其他的使命感，如何让自己活得更加幸福，如何帮助别人，让这个社会变得更加有意义。为什么宗教人士会活得 相对简单，因为他们灌输了一种使命感。而连一条鱼都经历了小溪流、湖泊、大海，他尝到了淡水的清香和海水的苦涩，完成了生命的周期。如果我们这一辈子都没 有苦涩，没有幸福和甜美，那生命是很遗憾的。 </p>\n<p>  而你现在的状况并不决定于你的未来，我在北大的时候受到的打击比较多，首先是身份上的悬殊，确实我是穿着大补丁走进校园的，我们体育老师上课从来不叫我的 名字的，都是叫那个大补丁来做个动作。因为我在农村锻炼过，跳跃性动作做得蛮好看，所以我常常被叫出来做演示。 </p>\n<p>  开学第一天晚上，全班开班会，我起来讲了一句话。现在新东方的王强老师是我们班级的班长，站起来跟我说你能不能不讲日语。因为我一直在农村上学，所以我们 的语文老师从来没用普通话给我们上过课，我当时根本不知道普通话该怎么说。北大当时按照英语成绩分班，我当时因为高考英语考得蛮好所以被分到了A班，其实 我的听说水平并不好，所以到了A班一个月以后就被贬到了C班，而C班主要是针对那些语音语调及听力障碍的同学。等后来，我发现我和同学的智商真的有差距， 我的那些同学平时看他们学习也并不怎么认真怎么一到期末考试就能考出好成绩，我每天学习时间都要比他们多两三个小时，但每次期末考试都在全班倒数几名。这 让我的心情非常郁闷。 </p>\n<p>  当时，我们班50个同学，25个男生25个女生。一开始我听完这个数字就特别兴奋，但是没想到我们班的女生没一个正眼瞧我一眼的。到了2001年的时候我 们全班同学聚会，大家从世界各地赶回来。蓦然回首，大家突然发现班上那个挺没出息的，普通话也讲不好的，默默无闻的那个人怎么就成了全班最出色的了。这个 时候女同学们都热情的走上来握住我的手，后悔当初没下手。 </p>\n<p>  所以后来大学女生问我，俞老师我们现在找男朋友要什么标准，我说很简单，参考我的长相。当然如果长得像我，那是绝对不能放过的。凡是长得比我难看的也不要放过，因为这个世界上的规律就是，越难看的人内涵越丰富。 </p>\n<p>   大三的时候我最喜欢读的是《红楼梦》，而且刚好读到林黛玉咳嗽而死的那一章。结果发现自己也在吐血。到医院，医生一查说得了肺结核立刻关起来，一关就是 一年。我跟医生说像我这样的小伙子怎么会得肺结核呢？医生让我讲讲现状。我说，您看我学习特别刻苦，可成绩就是上不去，班里没有一个女孩子喜欢我。他说， 这种情况不得肺结核是完全不可能的。 </p>\n<p>  但这个病也给我带来了心态上的调整，因为我在大学一二年级，想要追赶我的同学就是我的精神支柱。但是到了三年级，病了一年后我完全改变了，我觉得活着就挺 好。然后我就给自己订了一个最低标准，至少保证大学毕业拿到毕业证书，最后国家给我分配一份工作就挺好。虽然我并没有放弃努力，结果反而获得一个更加开阔 的心胸。所以，到现在为止我学会了永远不要去比，因为总有比你更加优秀的，也总有比你更加落后的。 </p>\n<p>  这个世界上最正确的是跟自己比，想一想今天是不是比昨天进步了一点，想一想明年是不是比今年更加好一点。想一想，10年以后的你是不是比今年的你要更加出色。这样的心态一直保持到我大学毕业。 </p>\n<p>  大学毕业的时候，每个人都要上去讲一段话，比如后半辈子怎么过，我就上去讲了这么一段话：我说，同学们大家都很厉害，我追了大家5年没追上，但是请大家记 住了，以后扮演一个骆驼的同学肯定不会放弃自己，你们5年干成的事情我干10年，你们10年干成的事情我干20年，你们20年干成的事情我干40年，实在 不行我会保持心情愉快身体健康，到了80岁后把你们一个个送走了我再走。这是我个人保持到现在的人生态度，而我认为这种人生态度对我来说非常有效。 </p>\n<p>  有人问我，如果新东方没了怎么办？其实新东方早晚会没的，因为它已经是一个商业化运作的教育机构。大家想一想，前些天我们看到的一个消息，GE公司是美 国的标志，不照样濒临破产了吗？新东方可能以后也会这样，变成历史的痕迹。但是我想，即使新东方没有了我依然很成功，因为我的心态很成功。我追求生命的那 种向往和穿越地平线的渴望不会改变。我认为，新东方给我的是一种精神，一种力量，而不是新东方本身给我带来多少钱，当然如果新东方给我更多的钱，我也愿意 要，不要钱才是傻瓜呢。但更重要的是，有了钱能否做出一些更加有意义的事情来。比如说我现在一直都想做一个小小的私立大学，可能我无法做到像同济大学那么 大，但做到它的十分之一总是可以的吧？我在北京已经买了一块地，正在建大学校区，造完后它就跟新东方的上市公司脱钩了，变成一个非营利性的大学校园，那它 可能就变成了你做的另外一件事情。 </p>\n<p>  如何把自己的生命变的更充实是最重要的事情，所以说，哪天新东方不存在了是非常正常的。如果新东方没了，我照样会过来跟大家做讲座，而且心情会更加的开 朗。因为没有繁琐的事情了。我只要换个题目就行了今天叫“度过有意义的生命”，下次我改成“我是如何把新东方做没了的”。 </p>\n<p>  而在大学中，我们要做的几件事情就是：第一，把自己的知识结构打造完整；第二，就是要在大学里尽可能的多交朋友，因为你终身的朋友、合作者一定来自于你的 大学；第三，如果有可能的话，在大学里谈一场比较专一的恋爱，因为回顾我北大的生活一片灰色。我想为什么会是灰色呢？其实，不是因为成绩不好，而是因为在 大学5年我从来没有过花前月下的时光。所以一直成了我大学时代的遗憾。去年北京大学让我给所有北大新生做开学典礼的时候，我给他们强调一句，什么都不重 要，重要的是谈恋爱，而且谈恋爱也不用害怕失败，因为自杀也自杀不了，未名湖就那么浅，跳下去还能爬起来；第四，就是为未来的工作做好打算。未来的工作跟 你有多少朋友、跟你的专业知识学的多少是相关的。好好掌握你的专业，再差的专业也一定有人用，只要你学的好。 </p>\n<p>  我有一个朋友学的是越南语，越南语的确很少用，但所有的中央领导去越南都要找他，因为他是一流的越南语同声翻译专家。我还有一个大学同学研究蒋介石，研究 了10年，穷困潦倒。但后来他去美国做了一个报告，美国方面帮他召开了一个中国现代史人物研讨会，他在报告上讲了自己的研究经过，结果下面一个老教授热泪 盈眶。下来后一问，这个老教授也在美国研究了30年蒋介石，孤苦伶仃，就是找不到另一个研究蒋介石的，没想到有个“傻瓜”也在研究蒋介石。于是5万美元一 年，让我同学跟着他在美国读研究生，然后读了四年的博士生。读完以后老头退休，他就变成了那个学校的教授。我去看他的时候，他已经在纽约买了套小房子，买 了辆车娶了个老婆养了条狗。当时他跟我说，俞敏洪你看现在这一切都是蒋介石“给”我的。 </p>\n<p>  我想用这个例子来说明什么呢？就是研究什么不重要，重要的是只要你真的喜欢就去做，然后就会有人用你。反过来，如果你觉得这个专业你不太喜欢，但很适合我 找工作，这要不要学？当然要学。我就是这样一个状态，我从来没喜欢过英语，当初考英语只是因为数学不行。不喜欢英语是因为我的模仿能力不强。像我的班长王 强，能够把任何话都模仿的惟妙惟肖。我普通话练了一年，才练成大家能听懂的样子。我老婆是天津人，跟我一吵架就用天津话骂我，但是我到现在为止只会说一句 天津话。就是当她拿起棍子打我的时候，我向她大吼一声，“干嘛”（天津话）。 </p>\n<p>  但是后来我发现英语成了我生命中的工具，因为英语，我在北大当了老师。其实当初留北大并不是成绩好，而是当时正好四六级考试，北大各个系的同学都要学两 年英语，结果北大急缺老师。而一些优秀的毕业生都去了外交部、经贸部，工资又高。后来我们系主任急了说，最后5名给我留下来。留下来的5个人现在都变成博 士生导师了，可见现在北大教育质量如何。当然这是句玩笑话，他们后来也经过自己的努力，经历了很多次考试成了很优秀的教师。 </p>\n<p>  在登山的时候，你会在乎登山杖你喜欢不喜欢吗？不会，你只会在乎能否帮你登上山顶。那么英语就是我的登山杖，尽管我不是特别的喜欢，但我知道我要想攀上更 高的人生的山峰就必须需要这个登山杖。我本来想把自己变成中国英语专家前100位的，后来发现一点戏都没有，因为中国留学生归来的越来越多了，有的在国外 待了10年、20年，回来了怎么看英语水平都比我高。那我只能缩小范围，想变成英语语法专家。后来发现背单词不用动脑筋，所以就开始拼命地背单词，结果变 成了中国还算不错的词汇专家。 </p>\n<p>  除了学专业外，同学们要在大学里多读书。新东方人读书都非常多。读书多，就意味着眼界更加的开阔，更加会思考问题，更具有创新精神。新东方流传一句话叫做 “底蕴的厚度决定事业的高度”。底蕴的厚度主要来自于两方面，第一多读书，读了大量的书你的知识结构自然就会完整，就会产生智慧；第二就是多人生经历。把 人生经历的智慧和读书的智慧结合起来就会变成真正的大智慧，就会变成你未来创造事业的无穷无尽的源泉和工具。 </p>\n<p>  比如，新东方招聘重要岗位的人才都是我面试。我只有几个问题，第一你大学读了多少本书，如果你说只读了几十本书，那肯定我不会要你。我心中的最低标准是 200本书，而我在大学里读了800本书。新东方还有更红火的王强老师，在大学里读了1200本书，平均每天一本。有的人会问我，读过了忘了跟没读过有什 么区别呢？其实完全不一样。就像你谈恋爱，一个谈过恋爱后又变成光棍汉的人和一个光棍汉相比是有自信的。因为当他看到别人在谈恋爱的时候，他会在旁边“嘿 嘿，想当初老子也是谈过恋爱的嘛”。实在不行来不及读，你可以到书店看着那些书，记着那些名字用手摸一下，这样也能增加一点人文气质。 </p>\n<p>  我有一个理念，人活着要过一种诗意的生活，我们有多少时候是停下来看看月亮的，在假期去内蒙看一下漫天的繁星的，有多少同学看着朝霞和晚霞时心中感受过生 命的涌动的。当然也要身体力行。大学时候，有一个非常著名的诗人叫海子，写了著名的诗句“面朝大海，春暖花开”，但非常可惜的是他没能抵抗现实社会的压 力，卧轨自杀了。所以我们说一个人不能只在语言上表达诗意，还要在现实中去表达诗意。所以你必须克服现实中的障碍和挫折。有首诗叫“大漠孤烟直，长河落日 圆”。我对“长河落日圆”有非常深刻的感觉，但对“大漠孤烟直”却没有什么概念。所以，进入北大校门之后第一件事情就是走向沙漠，走向戈壁滩，走向大草 原。而到今天为止，这些地方成了我的精神家园。如果生命中一有过不去的事情，我就去蒙古草原上跟牧民一起骑马。牧民曾经说过，在汉人当中从来没看到像你那 样不要命的。 </p>\n<p>  回过来讲诗意的生活，在大学里打游戏上MSN不叫诗意的生活，而在一张床上拿着书一边看书然后慢慢地睡着那就是一种诗意。要关注时事政治，要把握一些世界 大事。这种能力将在你日后创业的过程中起到很大的作用。另外就是要尽可能地多交朋友，交朋友首先你要做个好人，你要做一个让人放心的人。在中国企业界就是 这样的状态，如果你是个好心的人，在困难的时候一定会有人帮助。比如，蒙牛的牛根生大家都听说过，他为人处世很实在。所以蒙牛出事后，他需要资金，只需要 打个电话我们就会把钱汇过去。而为什么连合同都不签我们就给他，道理很简单，信任。 </p>\n<p>  我也碰到过这样的情况，03年的时候遇到SARS，我们马上给学生退学费，新东方的流动资金一下子退光了。而当时我算下来，账上还缺2000万。于是我分 别给两个朋友打了电话，一人一千万当天晚上就搞定了。所以，你变成一个让别人相信的人，比做一个让别人防着你的人，得到的好处要多得多。而建立这种信任， 要做到以下几个要素：要以别人为中心不要以自己为中心；要有服务精神。 </p>\n<p>  当时我那些大学同学觉得我没出息，但为什么会回来跟我创业呢？这跟我大学里的行为有关。我大学里是个学习不好但挺喜欢帮别人的人。我们宿舍当时从来不排值 日生，因为地全是我扫的。还有就是宿舍的水也基本都是我打，而他们之所以后来放弃国外优秀的条件来和我一起创业还是跟我当时宿舍打水有关系。若干年后，我 去找那些大学同学回来，他们说连你那么没出息的人在中国都赚钱了那我们回来还了得？第二个理由是，我们知道你是个特别好的人，你有饭吃不会给我们喝粥，你 有粥喝不会让我们饿死，所以就回来了。所以在大学毕业连一个朋友都没有的人，这辈子想成功几乎是不可能的。 </p>\n<p>  还有在大学里要交几个真正能帮助你的人，比如：心胸比你开阔，眼光比你敏锐。我在大学里交的就是这样的朋友，做人就要跟着牛人跑。比如，王强老师有天才的 一面，而这些是我学不到。他喜欢读书，他一进大学就会把生活费一分为二，一份用来买书，一份用来买饭票，饭票吃完了决不用买书的钱，他宁可偷别人的饭票， 我觉得这个习惯很好，我也一分为二，饭票吃完了我就偷他的。每到周末我们就去买书，我不知道买什么书，所以他买什么我跟着买什么，他被我弄烦了说你能不能 不跟着我，我说你是我的班长有责任帮助落后同学。其实我知道他想把我赶走，因为当时他是我们班女生追求的对象，如果我不跟着他他就会带女生出去买书，我当 时就看穿了他这个阴谋。到现在为止我的读书老师就是王强，他的藏书接近6万本，他每当看到有好的便宜的书就会帮我买，贵的会发个消息让我自己买。</p>\n<p>  到现在为止我都要不断的读书。因为每当聚会，他们谈起好书的时候，一旦我没读过就会被他们说“你大学时候不用功，怎么现在还是这样。”所以，我们的读书氛 围之所以非常的浓厚，最重要的原因就是王强，而你非常需要这样的朋友。还有就是徐小平老师。大学里我觉得这个老师很好，很想认识。一个礼拜后我买了支小钢 笔送给他，敲开他家的门，他问我，你是谁。我说，我是你的学生，听了你的课后很感动，所以想跟你交个朋友，这是我带给你的小礼物。徐小平一看我手中拿着礼 物就让我进去了，进了他家的门发现有一大群年轻老师在那。原来他有个习惯，一到周五晚上都会招一批老师来他家聊天。我当然很想听，问我能不能留下来听，他 说不行啊，我们聊的都是些男男女女的问题，像你这样的纯情少年会被污染的。幸亏我反应快说，徐老师我在这方面刚好需要启蒙教育。机会总是自己发现的。我发 现没有人给他们烧水，于是，我就帮他们烧水煮方便面。连续去了4个礼拜，到了第5个礼拜我不去了。为什么不去，不是因为我烦了，而是我觉得一个人在该显示 重要性的时候一定要显示出来。果然徐小平一个电话过来说，你这个兔崽子怎么还不过来。我知道，不是我离不开他们而是他们离不开我了。从此，在一年的时间 里，我不停听他们聊天，等到我办新东方的时候，我去的第一家就是徐小平家。我跟他说新东方不缺英语老师，但缺有思想的人物，所以希望你回去管理新东方的思 想。所以在大学里要做的另外一件事情就是一定要交朋友，让自己变成一个别人信赖的人。 </p>\n<p>  而如果能谈一场恋爱还是很不错的。但谈恋爱有一个非常重要的前提条件就是要一心一意地爱。所谓一心一意的爱不是说，大学里只能谈一次恋爱，而是说一次只能谈一个。要爱到一个什么程度呢？要有这样的一个感觉，“为什么我的眼睛充满泪水？是因为我爱你爱的深沉”。 </p>\n<p>  第二个要素就是当你真的爱上一个人后，要以恰当的方式告诉他你爱他而不能只放在心里。我在大学就吃亏在爱上不少女孩子，但只放在心里，怕被别人拒绝。但 其实人的追求最好还是表现出来，就算被一个女孩子拒绝了，她回家一定会在日记上写上，“今天又有一个男孩追我咯”。有一年去美国，跟一个以前班里很喜欢的 女孩一起吃饭，她和她老公跟我一起吃饭。吃饭的时候我跟她说，其实我在大学对你特别有好感。她当时一拍大腿说当时你为什么不告诉我呢？ </p>\n<p>  第三条就是谈的要大度，所谓的大度就是说当另一个人爱上其他人的时候一定要大度的对他说，你的幸福就是我的幸福，你的快乐就是我的快乐。我始终觉得人在世界上总是有缘分的，如果大学没有人爱你，在你以后的人生中总是会有人爱你，等你一起牵手走向今后的旅程。 </p>\n<p>  我是一个特别热爱生命的人我走路连蚂蚁都不敢踩，我想踩死那只公蚂蚁那只母蚂蚁怎么办。我吃鱼都不敢吃，我想吃了那条母鱼那公鱼该多痛苦啊，所以我一般不 吃鱼要吃吃两条。当然，大学的恋爱是一个过程，不管研究生还是本科生，毕业以后真结婚的比恋爱要少的多。比如我们班十几对谈恋爱，大学毕业后结婚了三对， 两年后离婚了两对。现在还剩下一对，这一对就是王强老师和他的夫人，我大学的同班同学。他们两人现在还过着幸福的生活。 </p>\n<p>  那么如果对大学的爱情有不满的也没有关系，看看我就行了。很多人都以为我不正常了，但是我还是照样地结婚了，照样找到心爱的人，照样生孩子，也有了比较 美好的家庭。总而言之，生活就是这样美好的往前走。有平凡，有激动，有慢慢长夜，也有美丽的日子，这就是我们的生活。 </p>\n<p>  还有就是工作问题。工作问题是一个比较简单的问题。我相信同济大学的同学在找工作的时候都不会有太大的困难，但是有同学问我要不要创业。人生一辈子不创一 次业一定是一件非常糟糕的事情。人一辈子总是要为自己干件事情，创业就是为自己干的事情。一份工作大家一起干，但是你并不一定大学毕业就要创业。为什么 呢？因为创业需要经验和许多前提条件。 </p>\n<p>  第一，你的专业知识能在你创业中的运用；第二，你有能和同学朋友相处并且有分配利益关系的能力；第三，你要有对付中国社会如此复杂局面的能力；第四，你要 有基本的商业操作原则或者商业运作知识；第五，自己要是个具有领导力的人；第六，你要有自己领域的运作知识和专业知识。 </p>\n<p>  比如，你想搞个培训学校，那你的运作知识从什么地方来呢？这个运作知识需要你通过观察别人怎么做得来的。如果当初我直接从北大出来就做新东方，那我是永 远做不成的。我做新东方有两个前提条件。第一个，我在北大做了六年老师，所以做老师做的不错。还有第二个前提条件，我做新东方以前，我在另外一家培训机构 干了近三年，我就在观察它是怎么做的。我碰到许多大学创业失败的人。我说你们怎么不创业了？他们说，同学之间只要一碰到利益关系，互相全是“狗屁”。是不 是这样？是的，但是你会处理了就不是“狗屁”了。我和新东方这帮朋友也有利益关系，但是我不就处理好了吗？所以说现在关键是考虑有没有这样的本领。要创业 但是我鼓励同学们先去某一个行业至少观察一到两年，最好是三到四年，慢慢积累自己的才能，自己也慢慢变得成熟，个性也慢慢变得稳定，最后再创业这样失败的 机会也少了很多。 </p>\n<p>  创业有两种状态，第一种就是从零做起，我自己就是从零做起，马云也是从零做起。第二种创业就像杨元庆，也算创业，杨元庆是接柳传志的班最后变成了联想老 总。美国著名的管理学家、企业家杰特威尔逊，他也是从一个普通工人做起，做了20年变成公司的老总；在公司老总的位置上干了20年把公司变成了全世界最大 的公司。这也是创业，不一定是自己干。 </p>\n<p>  有学生问，俞老师，我怎么把一个培训机构和你干得一样大？很简单先到新东方来打扫卫生，如果你把卫生打扫的非常干净，那么我把你提升为卫生部长，如果你 卫生部长干得好你就变成新东方后勤主任，等到你变成新东方后勤主任的时候，我就把你送到哈佛大学去学习了，学习完了回来我就把后勤行政全部交给你，你就变 成后勤行政总裁。第几位？第二位。我“一翘辫子”你就是总裁了对不对？所以我们的成熟是慢慢来的，就像一棵树长大也是慢慢长大，哪有一下子就能变成自己创 业成功的人？虽然这种人还是有的，但也是少数。我是32岁创业的，32岁才有了新东方。所以不要着急，人一辈子做多大的事都无所谓。 </p>\n<p>  还是我的老话：把生命活得精彩一点。我的比喻就是大树与小草的比喻，还有另外一个比喻：人的生活就像溪流一样，总有一个梦想——流进大海。有的人这一辈子 没有流向大海，这条河就是不完整的。长江流向大海，黄河流向大海，但长江、黄河以自己不同的方式流向大海。长江开山劈石穿过大山流向大海，黄河没有开山劈 石，结果绕过九曲十八弯。但是不管怎么样，生命再弯最后目标不变。我们惟一要记住的就是要像黄河、长江一样不断地向前流，但是不能变成黄河、长江里面的泥 沙，最后自己沉淀下去，把生命给沉淀没了。总而言之，生命的精彩只靠自己不靠别人。从来没有什么救世主，想要活得精彩、幸福，只能靠我们身边的每一个朋友 的共同努力！</p>\n"},{"title":"WordCounter","date":"2022-03-18T02:45:31.000Z","_content":"\n```\nimport java.util.Spliterator;\nimport java.util.function.Consumer;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\n/**\n * 计算单词个数\n * <U> U reduce(U identity,\n * BiFunction<U, ? super T, U> accumulator,\n * BinaryOperator<U> combiner);\n */\npublic class WordCounter {\n    private final boolean lastSpace;\n    private final int count;\n\n    public WordCounter(boolean lastSpace, int count) {\n        this.lastSpace = lastSpace;\n        this.count = count;\n    }\n\n    /**\n     * 和迭代算法一样 ，\n     * accumulate 方法一\n     * 个个遍历Character\n     *\n     * @param character\n     * @return\n     */\n    public WordCounter accumulator(Character character) {\n        if (Character.isWhitespace(character)) {\n            return lastSpace ? this : new WordCounter(true, count);\n        } else {\n            return lastSpace ? new WordCounter(false, count + 1) : this;\n        }\n    }\n\n    /**\n     * 合并两个Word Counter，把其\n     * 计数器加起来\n     *\n     * @param wordCounter\n     * @return\n     */\n    public WordCounter combiner(WordCounter wordCounter) {\n        return new WordCounter(lastSpace, count + wordCounter.count);\n    }\n\n    public int getCount() {\n        return count;\n    }\n\n    public static void main(String[] args) {\n        String str = \" Nel mezzo del cammin di nostra vita \" +\n                \"mi ritrovai in una selva oscura\" +\n                \" ché la dritta via era smarrita \";\n        Stream<Character> characterStream = IntStream.range(0, str.length()).mapToObj(str::charAt);\n        System.out.println(countWordsIteratively(characterStream));\n        Spliterator<Character> spliterator = new WordCounterSpliterator(str);\n        Stream<Character> characterSpliteratorStream = StreamSupport.stream(spliterator, true);\n        System.out.println(countWordsIteratively(characterSpliteratorStream.parallel()));\n        System.out.println(countWordsIteratively(str));\n\n\n    }\n\n    public static int countWordsIteratively(Stream<Character> characterStream) {\n        WordCounter wordCounter =\n                characterStream.reduce(\n                        new WordCounter(true, 0), WordCounter::accumulator, WordCounter::combiner);\n        return wordCounter.getCount();\n    }\n\n    public static int countWordsIteratively(String str) {\n        boolean lastSpace = true;\n        int count = 0;\n        char[] chars = str.toCharArray();\n        for (int i = 0; i < chars.length; i++) {\n            if (Character.isWhitespace(chars[i])) {\n                lastSpace = true;\n            } else {\n                if (lastSpace) count++;\n                lastSpace = false;\n            }\n        }\n        return count;\n    }\n\n    public static class WordCounterSpliterator implements Spliterator<Character> {\n\n        private final String string;\n        private int currentChar = 0;\n\n        public WordCounterSpliterator(String string) {\n            this.string = string;\n        }\n\n        /**\n         * tryAdvance方法的行为类似于普通的\n         * Iterator，因为它会按顺序一个一个使用Spliterator中的元素，并且如果还有其他元素要遍\n         * 历就返回true。\n         *\n         * @param action\n         * @return\n         */\n        @Override\n        public boolean tryAdvance(Consumer<? super Character> action) {\n            action.accept(string.charAt(currentChar++));\n            return currentChar < string.length();\n        }\n\n        /**\n         * 但trySplit是专为Spliterator接口设计的，因为它可以把一些元素划出去分\n         * 给第二个Spliterator（由该方法返回），让它们两个并行处理。\n         * 如果你需要执行拆分，就把试探的拆分位置设在要解析的String块的中间。但我\n         * 们没有直接使用这个拆分位置，因为要避免把词在中间断开，于是就往前找，直到找到\n         * 一个空格。一旦找到了适当的拆分位置，就可以创建一个新的Spliterator来遍历从\n         * 当前位置到拆分位置的子串；\n         *\n         * @return\n         */\n        @Override\n        public Spliterator<Character> trySplit() {\n            int currentSize = string.length() - currentChar;\n            if (currentSize < 10) {\n                return null;\n            }\n            for (int splitPos = currentSize / 2 + currentChar; splitPos < string.length(); splitPos++) {\n                if (Character.isWhitespace(string.charAt(splitPos))) {\n                    Spliterator<Character> spliterator =\n                            new WordCounterSpliterator(string.substring(currentChar, splitPos));\n                    currentChar = splitPos;\n                    return spliterator;\n                }\n            }\n            return null;\n        }\n\n        /**\n         * Spliterator还可通过\n         * estimateSize方法估计还剩下多少元素要遍历，因为即使不那么确切，能快速算出来是一个值\n         * 也有助于让拆分均匀一点。\n         * 还需要遍历的元素的estimatedSize就是这个Spliterator解析的String的总长度和\n         * 当前遍历的位置的差。\n         *\n         * @return\n         */\n        @Override\n        public long estimateSize() {\n            return string.length() - currentChar;\n        }\n\n        /**\n         * Spliterator是ORDERED（顺序就是String\n         * 中各个Character的次序）、SIZED（estimatedSize方法的返回值是精确的）、\n         * SUBSIZED（trySplit方法创建的其他Spliterator也有确切大小）、NONNULL（String\n         * 中不能有为 null 的 Character ） 和 IMMUTABLE （在解析 String 时不能再添加\n         * Character，因为String本身是一个不可变类）的\n         *\n         * @return\n         */\n        @Override\n        public int characteristics() {\n            return ORDERED + SIZED + SUBSIZED + NONNULL + IMMUTABLE;\n        }\n    }\n}\n```\n\n","source":"_posts/WordCounter.md","raw":"---\ntitle: WordCounter\ndate: 2022-03-18 10:45:31\ntags: Design\n---\n\n```\nimport java.util.Spliterator;\nimport java.util.function.Consumer;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\n/**\n * 计算单词个数\n * <U> U reduce(U identity,\n * BiFunction<U, ? super T, U> accumulator,\n * BinaryOperator<U> combiner);\n */\npublic class WordCounter {\n    private final boolean lastSpace;\n    private final int count;\n\n    public WordCounter(boolean lastSpace, int count) {\n        this.lastSpace = lastSpace;\n        this.count = count;\n    }\n\n    /**\n     * 和迭代算法一样 ，\n     * accumulate 方法一\n     * 个个遍历Character\n     *\n     * @param character\n     * @return\n     */\n    public WordCounter accumulator(Character character) {\n        if (Character.isWhitespace(character)) {\n            return lastSpace ? this : new WordCounter(true, count);\n        } else {\n            return lastSpace ? new WordCounter(false, count + 1) : this;\n        }\n    }\n\n    /**\n     * 合并两个Word Counter，把其\n     * 计数器加起来\n     *\n     * @param wordCounter\n     * @return\n     */\n    public WordCounter combiner(WordCounter wordCounter) {\n        return new WordCounter(lastSpace, count + wordCounter.count);\n    }\n\n    public int getCount() {\n        return count;\n    }\n\n    public static void main(String[] args) {\n        String str = \" Nel mezzo del cammin di nostra vita \" +\n                \"mi ritrovai in una selva oscura\" +\n                \" ché la dritta via era smarrita \";\n        Stream<Character> characterStream = IntStream.range(0, str.length()).mapToObj(str::charAt);\n        System.out.println(countWordsIteratively(characterStream));\n        Spliterator<Character> spliterator = new WordCounterSpliterator(str);\n        Stream<Character> characterSpliteratorStream = StreamSupport.stream(spliterator, true);\n        System.out.println(countWordsIteratively(characterSpliteratorStream.parallel()));\n        System.out.println(countWordsIteratively(str));\n\n\n    }\n\n    public static int countWordsIteratively(Stream<Character> characterStream) {\n        WordCounter wordCounter =\n                characterStream.reduce(\n                        new WordCounter(true, 0), WordCounter::accumulator, WordCounter::combiner);\n        return wordCounter.getCount();\n    }\n\n    public static int countWordsIteratively(String str) {\n        boolean lastSpace = true;\n        int count = 0;\n        char[] chars = str.toCharArray();\n        for (int i = 0; i < chars.length; i++) {\n            if (Character.isWhitespace(chars[i])) {\n                lastSpace = true;\n            } else {\n                if (lastSpace) count++;\n                lastSpace = false;\n            }\n        }\n        return count;\n    }\n\n    public static class WordCounterSpliterator implements Spliterator<Character> {\n\n        private final String string;\n        private int currentChar = 0;\n\n        public WordCounterSpliterator(String string) {\n            this.string = string;\n        }\n\n        /**\n         * tryAdvance方法的行为类似于普通的\n         * Iterator，因为它会按顺序一个一个使用Spliterator中的元素，并且如果还有其他元素要遍\n         * 历就返回true。\n         *\n         * @param action\n         * @return\n         */\n        @Override\n        public boolean tryAdvance(Consumer<? super Character> action) {\n            action.accept(string.charAt(currentChar++));\n            return currentChar < string.length();\n        }\n\n        /**\n         * 但trySplit是专为Spliterator接口设计的，因为它可以把一些元素划出去分\n         * 给第二个Spliterator（由该方法返回），让它们两个并行处理。\n         * 如果你需要执行拆分，就把试探的拆分位置设在要解析的String块的中间。但我\n         * 们没有直接使用这个拆分位置，因为要避免把词在中间断开，于是就往前找，直到找到\n         * 一个空格。一旦找到了适当的拆分位置，就可以创建一个新的Spliterator来遍历从\n         * 当前位置到拆分位置的子串；\n         *\n         * @return\n         */\n        @Override\n        public Spliterator<Character> trySplit() {\n            int currentSize = string.length() - currentChar;\n            if (currentSize < 10) {\n                return null;\n            }\n            for (int splitPos = currentSize / 2 + currentChar; splitPos < string.length(); splitPos++) {\n                if (Character.isWhitespace(string.charAt(splitPos))) {\n                    Spliterator<Character> spliterator =\n                            new WordCounterSpliterator(string.substring(currentChar, splitPos));\n                    currentChar = splitPos;\n                    return spliterator;\n                }\n            }\n            return null;\n        }\n\n        /**\n         * Spliterator还可通过\n         * estimateSize方法估计还剩下多少元素要遍历，因为即使不那么确切，能快速算出来是一个值\n         * 也有助于让拆分均匀一点。\n         * 还需要遍历的元素的estimatedSize就是这个Spliterator解析的String的总长度和\n         * 当前遍历的位置的差。\n         *\n         * @return\n         */\n        @Override\n        public long estimateSize() {\n            return string.length() - currentChar;\n        }\n\n        /**\n         * Spliterator是ORDERED（顺序就是String\n         * 中各个Character的次序）、SIZED（estimatedSize方法的返回值是精确的）、\n         * SUBSIZED（trySplit方法创建的其他Spliterator也有确切大小）、NONNULL（String\n         * 中不能有为 null 的 Character ） 和 IMMUTABLE （在解析 String 时不能再添加\n         * Character，因为String本身是一个不可变类）的\n         *\n         * @return\n         */\n        @Override\n        public int characteristics() {\n            return ORDERED + SIZED + SUBSIZED + NONNULL + IMMUTABLE;\n        }\n    }\n}\n```\n\n","slug":"WordCounter","published":1,"updated":"2022-03-18T08:23:41.497Z","_id":"cl0vtoqfl0000h8ln0qv70u4x","comments":1,"layout":"post","photos":[],"link":"","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.Spliterator;</span><br><span class=\"line\">import java.util.function.Consumer;</span><br><span class=\"line\">import java.util.stream.IntStream;</span><br><span class=\"line\">import java.util.stream.Stream;</span><br><span class=\"line\">import java.util.stream.StreamSupport;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 计算单词个数</span><br><span class=\"line\"> * &lt;U&gt; U reduce(U identity,</span><br><span class=\"line\"> * BiFunction&lt;U, ? super T, U&gt; accumulator,</span><br><span class=\"line\"> * BinaryOperator&lt;U&gt; combiner);</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class WordCounter &#123;</span><br><span class=\"line\">    private final boolean lastSpace;</span><br><span class=\"line\">    private final int count;</span><br><span class=\"line\"></span><br><span class=\"line\">    public WordCounter(boolean lastSpace, int count) &#123;</span><br><span class=\"line\">        this.lastSpace = lastSpace;</span><br><span class=\"line\">        this.count = count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 和迭代算法一样 ，</span><br><span class=\"line\">     * accumulate 方法一</span><br><span class=\"line\">     * 个个遍历Character</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param character</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public WordCounter accumulator(Character character) &#123;</span><br><span class=\"line\">        if (Character.isWhitespace(character)) &#123;</span><br><span class=\"line\">            return lastSpace ? this : new WordCounter(true, count);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return lastSpace ? new WordCounter(false, count + 1) : this;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 合并两个Word Counter，把其</span><br><span class=\"line\">     * 计数器加起来</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param wordCounter</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public WordCounter combiner(WordCounter wordCounter) &#123;</span><br><span class=\"line\">        return new WordCounter(lastSpace, count + wordCounter.count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getCount() &#123;</span><br><span class=\"line\">        return count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        String str = &quot; Nel mezzo del cammin di nostra vita &quot; +</span><br><span class=\"line\">                &quot;mi ritrovai in una selva oscura&quot; +</span><br><span class=\"line\">                &quot; ché la dritta via era smarrita &quot;;</span><br><span class=\"line\">        Stream&lt;Character&gt; characterStream = IntStream.range(0, str.length()).mapToObj(str::charAt);</span><br><span class=\"line\">        System.out.println(countWordsIteratively(characterStream));</span><br><span class=\"line\">        Spliterator&lt;Character&gt; spliterator = new WordCounterSpliterator(str);</span><br><span class=\"line\">        Stream&lt;Character&gt; characterSpliteratorStream = StreamSupport.stream(spliterator, true);</span><br><span class=\"line\">        System.out.println(countWordsIteratively(characterSpliteratorStream.parallel()));</span><br><span class=\"line\">        System.out.println(countWordsIteratively(str));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static int countWordsIteratively(Stream&lt;Character&gt; characterStream) &#123;</span><br><span class=\"line\">        WordCounter wordCounter =</span><br><span class=\"line\">                characterStream.reduce(</span><br><span class=\"line\">                        new WordCounter(true, 0), WordCounter::accumulator, WordCounter::combiner);</span><br><span class=\"line\">        return wordCounter.getCount();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static int countWordsIteratively(String str) &#123;</span><br><span class=\"line\">        boolean lastSpace = true;</span><br><span class=\"line\">        int count = 0;</span><br><span class=\"line\">        char[] chars = str.toCharArray();</span><br><span class=\"line\">        for (int i = 0; i &lt; chars.length; i++) &#123;</span><br><span class=\"line\">            if (Character.isWhitespace(chars[i])) &#123;</span><br><span class=\"line\">                lastSpace = true;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                if (lastSpace) count++;</span><br><span class=\"line\">                lastSpace = false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static class WordCounterSpliterator implements Spliterator&lt;Character&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        private final String string;</span><br><span class=\"line\">        private int currentChar = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">        public WordCounterSpliterator(String string) &#123;</span><br><span class=\"line\">            this.string = string;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * tryAdvance方法的行为类似于普通的</span><br><span class=\"line\">         * Iterator，因为它会按顺序一个一个使用Spliterator中的元素，并且如果还有其他元素要遍</span><br><span class=\"line\">         * 历就返回true。</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * @param action</span><br><span class=\"line\">         * @return</span><br><span class=\"line\">         */</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public boolean tryAdvance(Consumer&lt;? super Character&gt; action) &#123;</span><br><span class=\"line\">            action.accept(string.charAt(currentChar++));</span><br><span class=\"line\">            return currentChar &lt; string.length();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 但trySplit是专为Spliterator接口设计的，因为它可以把一些元素划出去分</span><br><span class=\"line\">         * 给第二个Spliterator（由该方法返回），让它们两个并行处理。</span><br><span class=\"line\">         * 如果你需要执行拆分，就把试探的拆分位置设在要解析的String块的中间。但我</span><br><span class=\"line\">         * 们没有直接使用这个拆分位置，因为要避免把词在中间断开，于是就往前找，直到找到</span><br><span class=\"line\">         * 一个空格。一旦找到了适当的拆分位置，就可以创建一个新的Spliterator来遍历从</span><br><span class=\"line\">         * 当前位置到拆分位置的子串；</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * @return</span><br><span class=\"line\">         */</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public Spliterator&lt;Character&gt; trySplit() &#123;</span><br><span class=\"line\">            int currentSize = string.length() - currentChar;</span><br><span class=\"line\">            if (currentSize &lt; 10) &#123;</span><br><span class=\"line\">                return null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            for (int splitPos = currentSize / 2 + currentChar; splitPos &lt; string.length(); splitPos++) &#123;</span><br><span class=\"line\">                if (Character.isWhitespace(string.charAt(splitPos))) &#123;</span><br><span class=\"line\">                    Spliterator&lt;Character&gt; spliterator =</span><br><span class=\"line\">                            new WordCounterSpliterator(string.substring(currentChar, splitPos));</span><br><span class=\"line\">                    currentChar = splitPos;</span><br><span class=\"line\">                    return spliterator;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * Spliterator还可通过</span><br><span class=\"line\">         * estimateSize方法估计还剩下多少元素要遍历，因为即使不那么确切，能快速算出来是一个值</span><br><span class=\"line\">         * 也有助于让拆分均匀一点。</span><br><span class=\"line\">         * 还需要遍历的元素的estimatedSize就是这个Spliterator解析的String的总长度和</span><br><span class=\"line\">         * 当前遍历的位置的差。</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * @return</span><br><span class=\"line\">         */</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public long estimateSize() &#123;</span><br><span class=\"line\">            return string.length() - currentChar;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * Spliterator是ORDERED（顺序就是String</span><br><span class=\"line\">         * 中各个Character的次序）、SIZED（estimatedSize方法的返回值是精确的）、</span><br><span class=\"line\">         * SUBSIZED（trySplit方法创建的其他Spliterator也有确切大小）、NONNULL（String</span><br><span class=\"line\">         * 中不能有为 null 的 Character ） 和 IMMUTABLE （在解析 String 时不能再添加</span><br><span class=\"line\">         * Character，因为String本身是一个不可变类）的</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * @return</span><br><span class=\"line\">         */</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public int characteristics() &#123;</span><br><span class=\"line\">            return ORDERED + SIZED + SUBSIZED + NONNULL + IMMUTABLE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.Spliterator;</span><br><span class=\"line\">import java.util.function.Consumer;</span><br><span class=\"line\">import java.util.stream.IntStream;</span><br><span class=\"line\">import java.util.stream.Stream;</span><br><span class=\"line\">import java.util.stream.StreamSupport;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 计算单词个数</span><br><span class=\"line\"> * &lt;U&gt; U reduce(U identity,</span><br><span class=\"line\"> * BiFunction&lt;U, ? super T, U&gt; accumulator,</span><br><span class=\"line\"> * BinaryOperator&lt;U&gt; combiner);</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class WordCounter &#123;</span><br><span class=\"line\">    private final boolean lastSpace;</span><br><span class=\"line\">    private final int count;</span><br><span class=\"line\"></span><br><span class=\"line\">    public WordCounter(boolean lastSpace, int count) &#123;</span><br><span class=\"line\">        this.lastSpace = lastSpace;</span><br><span class=\"line\">        this.count = count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 和迭代算法一样 ，</span><br><span class=\"line\">     * accumulate 方法一</span><br><span class=\"line\">     * 个个遍历Character</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param character</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public WordCounter accumulator(Character character) &#123;</span><br><span class=\"line\">        if (Character.isWhitespace(character)) &#123;</span><br><span class=\"line\">            return lastSpace ? this : new WordCounter(true, count);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return lastSpace ? new WordCounter(false, count + 1) : this;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 合并两个Word Counter，把其</span><br><span class=\"line\">     * 计数器加起来</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param wordCounter</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public WordCounter combiner(WordCounter wordCounter) &#123;</span><br><span class=\"line\">        return new WordCounter(lastSpace, count + wordCounter.count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getCount() &#123;</span><br><span class=\"line\">        return count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        String str = &quot; Nel mezzo del cammin di nostra vita &quot; +</span><br><span class=\"line\">                &quot;mi ritrovai in una selva oscura&quot; +</span><br><span class=\"line\">                &quot; ché la dritta via era smarrita &quot;;</span><br><span class=\"line\">        Stream&lt;Character&gt; characterStream = IntStream.range(0, str.length()).mapToObj(str::charAt);</span><br><span class=\"line\">        System.out.println(countWordsIteratively(characterStream));</span><br><span class=\"line\">        Spliterator&lt;Character&gt; spliterator = new WordCounterSpliterator(str);</span><br><span class=\"line\">        Stream&lt;Character&gt; characterSpliteratorStream = StreamSupport.stream(spliterator, true);</span><br><span class=\"line\">        System.out.println(countWordsIteratively(characterSpliteratorStream.parallel()));</span><br><span class=\"line\">        System.out.println(countWordsIteratively(str));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static int countWordsIteratively(Stream&lt;Character&gt; characterStream) &#123;</span><br><span class=\"line\">        WordCounter wordCounter =</span><br><span class=\"line\">                characterStream.reduce(</span><br><span class=\"line\">                        new WordCounter(true, 0), WordCounter::accumulator, WordCounter::combiner);</span><br><span class=\"line\">        return wordCounter.getCount();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static int countWordsIteratively(String str) &#123;</span><br><span class=\"line\">        boolean lastSpace = true;</span><br><span class=\"line\">        int count = 0;</span><br><span class=\"line\">        char[] chars = str.toCharArray();</span><br><span class=\"line\">        for (int i = 0; i &lt; chars.length; i++) &#123;</span><br><span class=\"line\">            if (Character.isWhitespace(chars[i])) &#123;</span><br><span class=\"line\">                lastSpace = true;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                if (lastSpace) count++;</span><br><span class=\"line\">                lastSpace = false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static class WordCounterSpliterator implements Spliterator&lt;Character&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        private final String string;</span><br><span class=\"line\">        private int currentChar = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">        public WordCounterSpliterator(String string) &#123;</span><br><span class=\"line\">            this.string = string;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * tryAdvance方法的行为类似于普通的</span><br><span class=\"line\">         * Iterator，因为它会按顺序一个一个使用Spliterator中的元素，并且如果还有其他元素要遍</span><br><span class=\"line\">         * 历就返回true。</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * @param action</span><br><span class=\"line\">         * @return</span><br><span class=\"line\">         */</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public boolean tryAdvance(Consumer&lt;? super Character&gt; action) &#123;</span><br><span class=\"line\">            action.accept(string.charAt(currentChar++));</span><br><span class=\"line\">            return currentChar &lt; string.length();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 但trySplit是专为Spliterator接口设计的，因为它可以把一些元素划出去分</span><br><span class=\"line\">         * 给第二个Spliterator（由该方法返回），让它们两个并行处理。</span><br><span class=\"line\">         * 如果你需要执行拆分，就把试探的拆分位置设在要解析的String块的中间。但我</span><br><span class=\"line\">         * 们没有直接使用这个拆分位置，因为要避免把词在中间断开，于是就往前找，直到找到</span><br><span class=\"line\">         * 一个空格。一旦找到了适当的拆分位置，就可以创建一个新的Spliterator来遍历从</span><br><span class=\"line\">         * 当前位置到拆分位置的子串；</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * @return</span><br><span class=\"line\">         */</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public Spliterator&lt;Character&gt; trySplit() &#123;</span><br><span class=\"line\">            int currentSize = string.length() - currentChar;</span><br><span class=\"line\">            if (currentSize &lt; 10) &#123;</span><br><span class=\"line\">                return null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            for (int splitPos = currentSize / 2 + currentChar; splitPos &lt; string.length(); splitPos++) &#123;</span><br><span class=\"line\">                if (Character.isWhitespace(string.charAt(splitPos))) &#123;</span><br><span class=\"line\">                    Spliterator&lt;Character&gt; spliterator =</span><br><span class=\"line\">                            new WordCounterSpliterator(string.substring(currentChar, splitPos));</span><br><span class=\"line\">                    currentChar = splitPos;</span><br><span class=\"line\">                    return spliterator;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * Spliterator还可通过</span><br><span class=\"line\">         * estimateSize方法估计还剩下多少元素要遍历，因为即使不那么确切，能快速算出来是一个值</span><br><span class=\"line\">         * 也有助于让拆分均匀一点。</span><br><span class=\"line\">         * 还需要遍历的元素的estimatedSize就是这个Spliterator解析的String的总长度和</span><br><span class=\"line\">         * 当前遍历的位置的差。</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * @return</span><br><span class=\"line\">         */</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public long estimateSize() &#123;</span><br><span class=\"line\">            return string.length() - currentChar;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * Spliterator是ORDERED（顺序就是String</span><br><span class=\"line\">         * 中各个Character的次序）、SIZED（estimatedSize方法的返回值是精确的）、</span><br><span class=\"line\">         * SUBSIZED（trySplit方法创建的其他Spliterator也有确切大小）、NONNULL（String</span><br><span class=\"line\">         * 中不能有为 null 的 Character ） 和 IMMUTABLE （在解析 String 时不能再添加</span><br><span class=\"line\">         * Character，因为String本身是一个不可变类）的</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * @return</span><br><span class=\"line\">         */</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public int characteristics() &#123;</span><br><span class=\"line\">            return ORDERED + SIZED + SUBSIZED + NONNULL + IMMUTABLE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"java线程池 阿里为什么不允许使用Executors?","date":"2022-03-18T09:17:46.000Z","_content":"\n# 带着问题\n\n1. 阿里Java代码规范为什么不允许使用Executors快速创建线程池？\n2. 下面的代码输出是什么？\n\n```\nThreadPoolExecutor executor = new ThreadPoolExecutor(\n        1, //corePoolSize\n        100, //maximumPoolSize\n        100, //keepAliveTime\n        TimeUnit.SECONDS, //unit\n        new LinkedBlockingDeque<>(100));//workQueue\n\nfor (int i = 0; i < 5; i++) {\n    final int taskIndex = i;\n    executor.execute(() -> {\n        System.out.println(taskIndex);\n        try {\n            Thread.sleep(Long.MAX_VALUE);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    });\n}\n```\n\n> A) 0 1 2 3 4 5\n> B) 0~5 顺序不一致输出5行\n> C) 0\n\n# 基础\n\n## 什么是线程池？\n\n线程池可以通过池看出来是一个资源集，任何池的作用都大同小异，主要是用来减少资源创建、初始化的系统开销。\n\n### 创建线程很“贵”吗？\n\n是的。创建线程的代价是昂贵的。\n\n我们都知道系统中的每个进程有自己独立的内存空间，而被称为轻量级进程的线程也是需要的。\n\n在JVM中默认一个线程需要使用256k~1M（取决于32位还是64位操作系统）的内存。（具体的数组我们不深究，因为随着JVM版本的变化这个默认值随时可能发生变更，我们只需要知道线程是需要占用内存的）\n\n**除了内存还有更多吗？**\n许多文章会将上下文切换、CPU调度列入其中，这边不将线程调度列入是因为睡眠中的线程不会被调度（OS控制），如果不是睡眠中的线程那么是一定需要被调度的。\n但在JVM中除了创建时的内存消耗，还会给GC带来压力，如果频繁创建线程那么相对的GC的时候也需要回收对应的线程。\n\n### 线程池的机制？\n\n可以看到线程池是一种重复利用线程的技术，线程池的主要机制就是保留一定的线程数在没有事情做的时候使之睡眠，当有活干的时候拿一个线程去运行。\n这些牵扯到线程池实现的具体策略。\n\n### 还有哪些常见的池？\n\n- 线程池\n- 连接池（数据库连接、TCP连接等）\n- BufferPool\n- ......\n\n# Java中的线程池\n\n## UML图（Java 8）\n可以看到真正的实现类有\n\n1. ThreadPoolExecutor (1.5)\n2. ForkJoinPool (1.7)\n3. ScheduledThreadPoolExecutor (1.5)\n\n今天我们主要谈谈 ThreadPoolExecutor 也是使用率较高的一个实现。\n\n## Executors提供的工厂方法\n\n1. newCachedThreadPool (ThreadPoolExecutor)\n\n> 创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程,那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。\n\n1. newFixedThreadPool (ThreadPoolExecutor)\n\n> 创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。\n\n1. newSingleThreadExecutor (ThreadPoolExecutor)\n\n> 创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。\n\n1. newScheduledThreadPool (ScheduledThreadPoolExecutor)\n\n> 创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。\n\n1. newSingleThreadScheduledExecutor (ScheduledThreadPoolExecutor)\n\n> 创建一个单线程用于定时以及周期性执行任务的需求。\n\n1. newWorkStealingPool (1.8 ForkJoinPool)\n\n> 创建一个工作窃取\n\n可以看到各种不同的工厂方法中使用的线程池实现类最终只有3个，对应关系如下：\n\n| 工厂方法                         | 实现类                      |\n| :------------------------------- | :-------------------------- |\n| newCachedThreadPool              | ThreadPoolExecutor          |\n| newFixedThreadPool               | ThreadPoolExecutor          |\n| newSingleThreadExecutor          | ThreadPoolExecutor          |\n| newScheduledThreadPool           | ScheduledThreadPoolExecutor |\n| newSingleThreadScheduledExecutor | ScheduledThreadPoolExecutor |\n| newWorkStealingPool              | ForkJoinPool                |\n\n## ThreadPoolExecutor\n\n首先我们看下 ThreadPoolExecutor 的完全构造函数\n\n```\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler)\n```\n\n1. corePoolSize\n\n> 核心池大小，除非设置了 allowCoreThreadTimeOut 否则哪怕线程超过空闲时间，池中也要最少要保留这个数目的线程。\n>\n> 需要注意的是，corePoolSize所需的线程并不是立即创建的，需要在提交任务之后进行创建，所以如果有大量的缓存线程数可以先提交一个空任务让线程池将线程先创建出来，从而提升后续的执行效率。\n\n1. maximumPoolSize\n\n> 允许的最大线程数。\n\n1. keepAliveTime\n\n> 空闲线程空闲存活时间，核心线程需要 allowCoreThreadTimeOut 为true才会退出。\n\n1. unit\n\n> 与 keepAliveTime配合，设置 keepAliveTime的单位，如：毫秒、秒。\n\n1. workQueue\n\n> 线程池中的任务队列。上面提到线程池的主要作用是复用线程来处理任务，所以我们需要一个队列来存放需要执行的任务，在使用池中的线程来处理这些任务，所以我们需要一个任务队列。\n\n1. threadFactory\n\n> 当线程池判断需要新的线程时通过线程工程创建线程。\n\n1. handler\n\n> 执行被阻止时的处理程序，线程池无法处理。这个与任务队列相关，比如队列中可以指定队列大小，如果超过了这个大小该怎么办呢？JDK已经为我们考虑到了，并提供了4个默认实现。\n\n下列是JDK中默认携带的策略:\n\n1. AbortPolicy (默认)\n\n> 抛出 RejectedExecutionException 异常。\n\n1. CallerRunsPolicy\n\n> 调用当前线程池所在的线程去执行。\n\n1. DiscardPolicy\n\n> 直接丢弃当前任务。\n\n1. DiscardOldestPolicy\n\n> 将最旧的任务丢弃，将当前任务添加到队列。\n\n容易混淆的参数：corePoolSize maximumPoolSize workQueue\n\n### 任务队列、核心线程数、最大线程数的逻辑关系\n\n1. 当线程数小于核心线程数时，创建线程。\n2. 当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列。\n3. 当线程数大于等于核心线程数，且任务队列已满\n   1. 若线程数小于最大线程数，创建线程\n   2. 若线程数等于最大线程数，调用拒绝执行处理程序（默认效果为：抛出异常，拒绝任务）\n\n### 那么这三个参数推荐如何设置，有最优值吗？\n\n由于java对于协程的支持不友好，所以会大量依赖于线程池和线程。\n从而这个值没有最优推荐，需要根据业务需求情况来进行设置。\n不同的需求类型可以创建多个不同的线程池来执行。\n\n## 问题1：阿里开发规范为什么不允许Executors快速创建线程池？\n\n> 参考地址：https://github.com/alibaba/p3c\n\n可以看到原因很简单\n\n1. newSingleThreadExecutor\n2. newFixedThreadPool\n\n在 workQueue 参数直接 使用了 new LinkedBlockingQueue<Runnable>() 理论上可以无限添加任务到线程池。\n\n```\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>();\n}\n\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1,\n    1,\n    0L,\n    TimeUnit.MILLISECONDS,\n    new LinkedBlockingQueue<Runnable>()));\n}\n```\n\n如果提交到线程池的任务由问题，比如 sleep 永久，会造成内存泄漏，最终导致OOM。\n\n同时 阿里还推荐自定义 threadFactory 设置线程名称便于以后排查问题。\n\n## 问题2：下面的代码输出是什么？\n\n应该选C。\n虽然最大线程数有100但核心线程数为1，任务队列由100。\n满足了 当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列，这个条件。\n所以后续添加的任务都会被堵塞。\n\n# 最后\n\n关于 ThreadPoolExecutor 的逻辑在实际使用的时候会有点奇怪，因为线程池中的线程并没有超过最大线程数，有没有一种可能当任务被堵塞很久的时候创建新的线程池来处理呢？\n\n这边推荐大家使用 newWorkStealingPool，也就是ForkJoinPool。采取了工作窃取的模式。\n","source":"_posts/java线程池-阿里为什么不允许使用Executors.md","raw":"---\ntitle: java线程池 阿里为什么不允许使用Executors?\ndate: 2022-03-18 17:17:46\ntags: Java\n---\n\n# 带着问题\n\n1. 阿里Java代码规范为什么不允许使用Executors快速创建线程池？\n2. 下面的代码输出是什么？\n\n```\nThreadPoolExecutor executor = new ThreadPoolExecutor(\n        1, //corePoolSize\n        100, //maximumPoolSize\n        100, //keepAliveTime\n        TimeUnit.SECONDS, //unit\n        new LinkedBlockingDeque<>(100));//workQueue\n\nfor (int i = 0; i < 5; i++) {\n    final int taskIndex = i;\n    executor.execute(() -> {\n        System.out.println(taskIndex);\n        try {\n            Thread.sleep(Long.MAX_VALUE);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    });\n}\n```\n\n> A) 0 1 2 3 4 5\n> B) 0~5 顺序不一致输出5行\n> C) 0\n\n# 基础\n\n## 什么是线程池？\n\n线程池可以通过池看出来是一个资源集，任何池的作用都大同小异，主要是用来减少资源创建、初始化的系统开销。\n\n### 创建线程很“贵”吗？\n\n是的。创建线程的代价是昂贵的。\n\n我们都知道系统中的每个进程有自己独立的内存空间，而被称为轻量级进程的线程也是需要的。\n\n在JVM中默认一个线程需要使用256k~1M（取决于32位还是64位操作系统）的内存。（具体的数组我们不深究，因为随着JVM版本的变化这个默认值随时可能发生变更，我们只需要知道线程是需要占用内存的）\n\n**除了内存还有更多吗？**\n许多文章会将上下文切换、CPU调度列入其中，这边不将线程调度列入是因为睡眠中的线程不会被调度（OS控制），如果不是睡眠中的线程那么是一定需要被调度的。\n但在JVM中除了创建时的内存消耗，还会给GC带来压力，如果频繁创建线程那么相对的GC的时候也需要回收对应的线程。\n\n### 线程池的机制？\n\n可以看到线程池是一种重复利用线程的技术，线程池的主要机制就是保留一定的线程数在没有事情做的时候使之睡眠，当有活干的时候拿一个线程去运行。\n这些牵扯到线程池实现的具体策略。\n\n### 还有哪些常见的池？\n\n- 线程池\n- 连接池（数据库连接、TCP连接等）\n- BufferPool\n- ......\n\n# Java中的线程池\n\n## UML图（Java 8）\n可以看到真正的实现类有\n\n1. ThreadPoolExecutor (1.5)\n2. ForkJoinPool (1.7)\n3. ScheduledThreadPoolExecutor (1.5)\n\n今天我们主要谈谈 ThreadPoolExecutor 也是使用率较高的一个实现。\n\n## Executors提供的工厂方法\n\n1. newCachedThreadPool (ThreadPoolExecutor)\n\n> 创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程,那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。\n\n1. newFixedThreadPool (ThreadPoolExecutor)\n\n> 创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。\n\n1. newSingleThreadExecutor (ThreadPoolExecutor)\n\n> 创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。\n\n1. newScheduledThreadPool (ScheduledThreadPoolExecutor)\n\n> 创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。\n\n1. newSingleThreadScheduledExecutor (ScheduledThreadPoolExecutor)\n\n> 创建一个单线程用于定时以及周期性执行任务的需求。\n\n1. newWorkStealingPool (1.8 ForkJoinPool)\n\n> 创建一个工作窃取\n\n可以看到各种不同的工厂方法中使用的线程池实现类最终只有3个，对应关系如下：\n\n| 工厂方法                         | 实现类                      |\n| :------------------------------- | :-------------------------- |\n| newCachedThreadPool              | ThreadPoolExecutor          |\n| newFixedThreadPool               | ThreadPoolExecutor          |\n| newSingleThreadExecutor          | ThreadPoolExecutor          |\n| newScheduledThreadPool           | ScheduledThreadPoolExecutor |\n| newSingleThreadScheduledExecutor | ScheduledThreadPoolExecutor |\n| newWorkStealingPool              | ForkJoinPool                |\n\n## ThreadPoolExecutor\n\n首先我们看下 ThreadPoolExecutor 的完全构造函数\n\n```\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler)\n```\n\n1. corePoolSize\n\n> 核心池大小，除非设置了 allowCoreThreadTimeOut 否则哪怕线程超过空闲时间，池中也要最少要保留这个数目的线程。\n>\n> 需要注意的是，corePoolSize所需的线程并不是立即创建的，需要在提交任务之后进行创建，所以如果有大量的缓存线程数可以先提交一个空任务让线程池将线程先创建出来，从而提升后续的执行效率。\n\n1. maximumPoolSize\n\n> 允许的最大线程数。\n\n1. keepAliveTime\n\n> 空闲线程空闲存活时间，核心线程需要 allowCoreThreadTimeOut 为true才会退出。\n\n1. unit\n\n> 与 keepAliveTime配合，设置 keepAliveTime的单位，如：毫秒、秒。\n\n1. workQueue\n\n> 线程池中的任务队列。上面提到线程池的主要作用是复用线程来处理任务，所以我们需要一个队列来存放需要执行的任务，在使用池中的线程来处理这些任务，所以我们需要一个任务队列。\n\n1. threadFactory\n\n> 当线程池判断需要新的线程时通过线程工程创建线程。\n\n1. handler\n\n> 执行被阻止时的处理程序，线程池无法处理。这个与任务队列相关，比如队列中可以指定队列大小，如果超过了这个大小该怎么办呢？JDK已经为我们考虑到了，并提供了4个默认实现。\n\n下列是JDK中默认携带的策略:\n\n1. AbortPolicy (默认)\n\n> 抛出 RejectedExecutionException 异常。\n\n1. CallerRunsPolicy\n\n> 调用当前线程池所在的线程去执行。\n\n1. DiscardPolicy\n\n> 直接丢弃当前任务。\n\n1. DiscardOldestPolicy\n\n> 将最旧的任务丢弃，将当前任务添加到队列。\n\n容易混淆的参数：corePoolSize maximumPoolSize workQueue\n\n### 任务队列、核心线程数、最大线程数的逻辑关系\n\n1. 当线程数小于核心线程数时，创建线程。\n2. 当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列。\n3. 当线程数大于等于核心线程数，且任务队列已满\n   1. 若线程数小于最大线程数，创建线程\n   2. 若线程数等于最大线程数，调用拒绝执行处理程序（默认效果为：抛出异常，拒绝任务）\n\n### 那么这三个参数推荐如何设置，有最优值吗？\n\n由于java对于协程的支持不友好，所以会大量依赖于线程池和线程。\n从而这个值没有最优推荐，需要根据业务需求情况来进行设置。\n不同的需求类型可以创建多个不同的线程池来执行。\n\n## 问题1：阿里开发规范为什么不允许Executors快速创建线程池？\n\n> 参考地址：https://github.com/alibaba/p3c\n\n可以看到原因很简单\n\n1. newSingleThreadExecutor\n2. newFixedThreadPool\n\n在 workQueue 参数直接 使用了 new LinkedBlockingQueue<Runnable>() 理论上可以无限添加任务到线程池。\n\n```\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>();\n}\n\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1,\n    1,\n    0L,\n    TimeUnit.MILLISECONDS,\n    new LinkedBlockingQueue<Runnable>()));\n}\n```\n\n如果提交到线程池的任务由问题，比如 sleep 永久，会造成内存泄漏，最终导致OOM。\n\n同时 阿里还推荐自定义 threadFactory 设置线程名称便于以后排查问题。\n\n## 问题2：下面的代码输出是什么？\n\n应该选C。\n虽然最大线程数有100但核心线程数为1，任务队列由100。\n满足了 当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列，这个条件。\n所以后续添加的任务都会被堵塞。\n\n# 最后\n\n关于 ThreadPoolExecutor 的逻辑在实际使用的时候会有点奇怪，因为线程池中的线程并没有超过最大线程数，有没有一种可能当任务被堵塞很久的时候创建新的线程池来处理呢？\n\n这边推荐大家使用 newWorkStealingPool，也就是ForkJoinPool。采取了工作窃取的模式。\n","slug":"java线程池-阿里为什么不允许使用Executors","published":1,"updated":"2022-03-18T09:24:38.121Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0w7tahj0000bslnajaw8g8q","content":"<h1 id=\"带着问题\"><a href=\"#带着问题\" class=\"headerlink\" title=\"带着问题\"></a>带着问题</h1><ol>\n<li>阿里Java代码规范为什么不允许使用Executors快速创建线程池？</li>\n<li>下面的代码输出是什么？</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadPoolExecutor executor = new ThreadPoolExecutor(</span><br><span class=\"line\">        1, //corePoolSize</span><br><span class=\"line\">        100, //maximumPoolSize</span><br><span class=\"line\">        100, //keepAliveTime</span><br><span class=\"line\">        TimeUnit.SECONDS, //unit</span><br><span class=\"line\">        new LinkedBlockingDeque&lt;&gt;(100));//workQueue</span><br><span class=\"line\"></span><br><span class=\"line\">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class=\"line\">    final int taskIndex = i;</span><br><span class=\"line\">    executor.execute(() -&gt; &#123;</span><br><span class=\"line\">        System.out.println(taskIndex);</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(Long.MAX_VALUE);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>A) 0 1 2 3 4 5<br>B) 0~5 顺序不一致输出5行<br>C) 0</p>\n</blockquote>\n<h1 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h1><h2 id=\"什么是线程池？\"><a href=\"#什么是线程池？\" class=\"headerlink\" title=\"什么是线程池？\"></a>什么是线程池？</h2><p>线程池可以通过池看出来是一个资源集，任何池的作用都大同小异，主要是用来减少资源创建、初始化的系统开销。</p>\n<h3 id=\"创建线程很“贵”吗？\"><a href=\"#创建线程很“贵”吗？\" class=\"headerlink\" title=\"创建线程很“贵”吗？\"></a>创建线程很“贵”吗？</h3><p>是的。创建线程的代价是昂贵的。</p>\n<p>我们都知道系统中的每个进程有自己独立的内存空间，而被称为轻量级进程的线程也是需要的。</p>\n<p>在JVM中默认一个线程需要使用256k~1M（取决于32位还是64位操作系统）的内存。（具体的数组我们不深究，因为随着JVM版本的变化这个默认值随时可能发生变更，我们只需要知道线程是需要占用内存的）</p>\n<p><strong>除了内存还有更多吗？</strong><br>许多文章会将上下文切换、CPU调度列入其中，这边不将线程调度列入是因为睡眠中的线程不会被调度（OS控制），如果不是睡眠中的线程那么是一定需要被调度的。<br>但在JVM中除了创建时的内存消耗，还会给GC带来压力，如果频繁创建线程那么相对的GC的时候也需要回收对应的线程。</p>\n<h3 id=\"线程池的机制？\"><a href=\"#线程池的机制？\" class=\"headerlink\" title=\"线程池的机制？\"></a>线程池的机制？</h3><p>可以看到线程池是一种重复利用线程的技术，线程池的主要机制就是保留一定的线程数在没有事情做的时候使之睡眠，当有活干的时候拿一个线程去运行。<br>这些牵扯到线程池实现的具体策略。</p>\n<h3 id=\"还有哪些常见的池？\"><a href=\"#还有哪些常见的池？\" class=\"headerlink\" title=\"还有哪些常见的池？\"></a>还有哪些常见的池？</h3><ul>\n<li>线程池</li>\n<li>连接池（数据库连接、TCP连接等）</li>\n<li>BufferPool</li>\n<li>……</li>\n</ul>\n<h1 id=\"Java中的线程池\"><a href=\"#Java中的线程池\" class=\"headerlink\" title=\"Java中的线程池\"></a>Java中的线程池</h1><h2 id=\"UML图（Java-8）\"><a href=\"#UML图（Java-8）\" class=\"headerlink\" title=\"UML图（Java 8）\"></a>UML图（Java 8）</h2><p>可以看到真正的实现类有</p>\n<ol>\n<li>ThreadPoolExecutor (1.5)</li>\n<li>ForkJoinPool (1.7)</li>\n<li>ScheduledThreadPoolExecutor (1.5)</li>\n</ol>\n<p>今天我们主要谈谈 ThreadPoolExecutor 也是使用率较高的一个实现。</p>\n<h2 id=\"Executors提供的工厂方法\"><a href=\"#Executors提供的工厂方法\" class=\"headerlink\" title=\"Executors提供的工厂方法\"></a>Executors提供的工厂方法</h2><ol>\n<li>newCachedThreadPool (ThreadPoolExecutor)</li>\n</ol>\n<blockquote>\n<p>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程,那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p>\n</blockquote>\n<ol>\n<li>newFixedThreadPool (ThreadPoolExecutor)</li>\n</ol>\n<blockquote>\n<p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p>\n</blockquote>\n<ol>\n<li>newSingleThreadExecutor (ThreadPoolExecutor)</li>\n</ol>\n<blockquote>\n<p>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>\n</blockquote>\n<ol>\n<li>newScheduledThreadPool (ScheduledThreadPoolExecutor)</li>\n</ol>\n<blockquote>\n<p>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>\n</blockquote>\n<ol>\n<li>newSingleThreadScheduledExecutor (ScheduledThreadPoolExecutor)</li>\n</ol>\n<blockquote>\n<p>创建一个单线程用于定时以及周期性执行任务的需求。</p>\n</blockquote>\n<ol>\n<li>newWorkStealingPool (1.8 ForkJoinPool)</li>\n</ol>\n<blockquote>\n<p>创建一个工作窃取</p>\n</blockquote>\n<p>可以看到各种不同的工厂方法中使用的线程池实现类最终只有3个，对应关系如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">工厂方法</th>\n<th align=\"left\">实现类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">newCachedThreadPool</td>\n<td align=\"left\">ThreadPoolExecutor</td>\n</tr>\n<tr>\n<td align=\"left\">newFixedThreadPool</td>\n<td align=\"left\">ThreadPoolExecutor</td>\n</tr>\n<tr>\n<td align=\"left\">newSingleThreadExecutor</td>\n<td align=\"left\">ThreadPoolExecutor</td>\n</tr>\n<tr>\n<td align=\"left\">newScheduledThreadPool</td>\n<td align=\"left\">ScheduledThreadPoolExecutor</td>\n</tr>\n<tr>\n<td align=\"left\">newSingleThreadScheduledExecutor</td>\n<td align=\"left\">ScheduledThreadPoolExecutor</td>\n</tr>\n<tr>\n<td align=\"left\">newWorkStealingPool</td>\n<td align=\"left\">ForkJoinPool</td>\n</tr>\n</tbody></table>\n<h2 id=\"ThreadPoolExecutor\"><a href=\"#ThreadPoolExecutor\" class=\"headerlink\" title=\"ThreadPoolExecutor\"></a>ThreadPoolExecutor</h2><p>首先我们看下 ThreadPoolExecutor 的完全构造函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public ThreadPoolExecutor(int corePoolSize,</span><br><span class=\"line\">                              int maximumPoolSize,</span><br><span class=\"line\">                              long keepAliveTime,</span><br><span class=\"line\">                              TimeUnit unit,</span><br><span class=\"line\">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class=\"line\">                              ThreadFactory threadFactory,</span><br><span class=\"line\">                              RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>corePoolSize</li>\n</ol>\n<blockquote>\n<p>核心池大小，除非设置了 allowCoreThreadTimeOut 否则哪怕线程超过空闲时间，池中也要最少要保留这个数目的线程。</p>\n<p>需要注意的是，corePoolSize所需的线程并不是立即创建的，需要在提交任务之后进行创建，所以如果有大量的缓存线程数可以先提交一个空任务让线程池将线程先创建出来，从而提升后续的执行效率。</p>\n</blockquote>\n<ol>\n<li>maximumPoolSize</li>\n</ol>\n<blockquote>\n<p>允许的最大线程数。</p>\n</blockquote>\n<ol>\n<li>keepAliveTime</li>\n</ol>\n<blockquote>\n<p>空闲线程空闲存活时间，核心线程需要 allowCoreThreadTimeOut 为true才会退出。</p>\n</blockquote>\n<ol>\n<li>unit</li>\n</ol>\n<blockquote>\n<p>与 keepAliveTime配合，设置 keepAliveTime的单位，如：毫秒、秒。</p>\n</blockquote>\n<ol>\n<li>workQueue</li>\n</ol>\n<blockquote>\n<p>线程池中的任务队列。上面提到线程池的主要作用是复用线程来处理任务，所以我们需要一个队列来存放需要执行的任务，在使用池中的线程来处理这些任务，所以我们需要一个任务队列。</p>\n</blockquote>\n<ol>\n<li>threadFactory</li>\n</ol>\n<blockquote>\n<p>当线程池判断需要新的线程时通过线程工程创建线程。</p>\n</blockquote>\n<ol>\n<li>handler</li>\n</ol>\n<blockquote>\n<p>执行被阻止时的处理程序，线程池无法处理。这个与任务队列相关，比如队列中可以指定队列大小，如果超过了这个大小该怎么办呢？JDK已经为我们考虑到了，并提供了4个默认实现。</p>\n</blockquote>\n<p>下列是JDK中默认携带的策略:</p>\n<ol>\n<li>AbortPolicy (默认)</li>\n</ol>\n<blockquote>\n<p>抛出 RejectedExecutionException 异常。</p>\n</blockquote>\n<ol>\n<li>CallerRunsPolicy</li>\n</ol>\n<blockquote>\n<p>调用当前线程池所在的线程去执行。</p>\n</blockquote>\n<ol>\n<li>DiscardPolicy</li>\n</ol>\n<blockquote>\n<p>直接丢弃当前任务。</p>\n</blockquote>\n<ol>\n<li>DiscardOldestPolicy</li>\n</ol>\n<blockquote>\n<p>将最旧的任务丢弃，将当前任务添加到队列。</p>\n</blockquote>\n<p>容易混淆的参数：corePoolSize maximumPoolSize workQueue</p>\n<h3 id=\"任务队列、核心线程数、最大线程数的逻辑关系\"><a href=\"#任务队列、核心线程数、最大线程数的逻辑关系\" class=\"headerlink\" title=\"任务队列、核心线程数、最大线程数的逻辑关系\"></a>任务队列、核心线程数、最大线程数的逻辑关系</h3><ol>\n<li>当线程数小于核心线程数时，创建线程。</li>\n<li>当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列。</li>\n<li>当线程数大于等于核心线程数，且任务队列已满<ol>\n<li>若线程数小于最大线程数，创建线程</li>\n<li>若线程数等于最大线程数，调用拒绝执行处理程序（默认效果为：抛出异常，拒绝任务）</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"那么这三个参数推荐如何设置，有最优值吗？\"><a href=\"#那么这三个参数推荐如何设置，有最优值吗？\" class=\"headerlink\" title=\"那么这三个参数推荐如何设置，有最优值吗？\"></a>那么这三个参数推荐如何设置，有最优值吗？</h3><p>由于java对于协程的支持不友好，所以会大量依赖于线程池和线程。<br>从而这个值没有最优推荐，需要根据业务需求情况来进行设置。<br>不同的需求类型可以创建多个不同的线程池来执行。</p>\n<h2 id=\"问题1：阿里开发规范为什么不允许Executors快速创建线程池？\"><a href=\"#问题1：阿里开发规范为什么不允许Executors快速创建线程池？\" class=\"headerlink\" title=\"问题1：阿里开发规范为什么不允许Executors快速创建线程池？\"></a>问题1：阿里开发规范为什么不允许Executors快速创建线程池？</h2><blockquote>\n<p>参考地址：<a href=\"https://github.com/alibaba/p3c\">https://github.com/alibaba/p3c</a></p>\n</blockquote>\n<p>可以看到原因很简单</p>\n<ol>\n<li>newSingleThreadExecutor</li>\n<li>newFixedThreadPool</li>\n</ol>\n<p>在 workQueue 参数直接 使用了 new LinkedBlockingQueue<Runnable>() 理论上可以无限添加任务到线程池。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class=\"line\">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class=\"line\">                                    0L, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                    new LinkedBlockingQueue&lt;Runnable&gt;();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class=\"line\">    return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1,</span><br><span class=\"line\">    1,</span><br><span class=\"line\">    0L,</span><br><span class=\"line\">    TimeUnit.MILLISECONDS,</span><br><span class=\"line\">    new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果提交到线程池的任务由问题，比如 sleep 永久，会造成内存泄漏，最终导致OOM。</p>\n<p>同时 阿里还推荐自定义 threadFactory 设置线程名称便于以后排查问题。</p>\n<h2 id=\"问题2：下面的代码输出是什么？\"><a href=\"#问题2：下面的代码输出是什么？\" class=\"headerlink\" title=\"问题2：下面的代码输出是什么？\"></a>问题2：下面的代码输出是什么？</h2><p>应该选C。<br>虽然最大线程数有100但核心线程数为1，任务队列由100。<br>满足了 当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列，这个条件。<br>所以后续添加的任务都会被堵塞。</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>关于 ThreadPoolExecutor 的逻辑在实际使用的时候会有点奇怪，因为线程池中的线程并没有超过最大线程数，有没有一种可能当任务被堵塞很久的时候创建新的线程池来处理呢？</p>\n<p>这边推荐大家使用 newWorkStealingPool，也就是ForkJoinPool。采取了工作窃取的模式。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"带着问题\"><a href=\"#带着问题\" class=\"headerlink\" title=\"带着问题\"></a>带着问题</h1><ol>\n<li>阿里Java代码规范为什么不允许使用Executors快速创建线程池？</li>\n<li>下面的代码输出是什么？</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadPoolExecutor executor = new ThreadPoolExecutor(</span><br><span class=\"line\">        1, //corePoolSize</span><br><span class=\"line\">        100, //maximumPoolSize</span><br><span class=\"line\">        100, //keepAliveTime</span><br><span class=\"line\">        TimeUnit.SECONDS, //unit</span><br><span class=\"line\">        new LinkedBlockingDeque&lt;&gt;(100));//workQueue</span><br><span class=\"line\"></span><br><span class=\"line\">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class=\"line\">    final int taskIndex = i;</span><br><span class=\"line\">    executor.execute(() -&gt; &#123;</span><br><span class=\"line\">        System.out.println(taskIndex);</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(Long.MAX_VALUE);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>A) 0 1 2 3 4 5<br>B) 0~5 顺序不一致输出5行<br>C) 0</p>\n</blockquote>\n<h1 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h1><h2 id=\"什么是线程池？\"><a href=\"#什么是线程池？\" class=\"headerlink\" title=\"什么是线程池？\"></a>什么是线程池？</h2><p>线程池可以通过池看出来是一个资源集，任何池的作用都大同小异，主要是用来减少资源创建、初始化的系统开销。</p>\n<h3 id=\"创建线程很“贵”吗？\"><a href=\"#创建线程很“贵”吗？\" class=\"headerlink\" title=\"创建线程很“贵”吗？\"></a>创建线程很“贵”吗？</h3><p>是的。创建线程的代价是昂贵的。</p>\n<p>我们都知道系统中的每个进程有自己独立的内存空间，而被称为轻量级进程的线程也是需要的。</p>\n<p>在JVM中默认一个线程需要使用256k~1M（取决于32位还是64位操作系统）的内存。（具体的数组我们不深究，因为随着JVM版本的变化这个默认值随时可能发生变更，我们只需要知道线程是需要占用内存的）</p>\n<p><strong>除了内存还有更多吗？</strong><br>许多文章会将上下文切换、CPU调度列入其中，这边不将线程调度列入是因为睡眠中的线程不会被调度（OS控制），如果不是睡眠中的线程那么是一定需要被调度的。<br>但在JVM中除了创建时的内存消耗，还会给GC带来压力，如果频繁创建线程那么相对的GC的时候也需要回收对应的线程。</p>\n<h3 id=\"线程池的机制？\"><a href=\"#线程池的机制？\" class=\"headerlink\" title=\"线程池的机制？\"></a>线程池的机制？</h3><p>可以看到线程池是一种重复利用线程的技术，线程池的主要机制就是保留一定的线程数在没有事情做的时候使之睡眠，当有活干的时候拿一个线程去运行。<br>这些牵扯到线程池实现的具体策略。</p>\n<h3 id=\"还有哪些常见的池？\"><a href=\"#还有哪些常见的池？\" class=\"headerlink\" title=\"还有哪些常见的池？\"></a>还有哪些常见的池？</h3><ul>\n<li>线程池</li>\n<li>连接池（数据库连接、TCP连接等）</li>\n<li>BufferPool</li>\n<li>……</li>\n</ul>\n<h1 id=\"Java中的线程池\"><a href=\"#Java中的线程池\" class=\"headerlink\" title=\"Java中的线程池\"></a>Java中的线程池</h1><h2 id=\"UML图（Java-8）\"><a href=\"#UML图（Java-8）\" class=\"headerlink\" title=\"UML图（Java 8）\"></a>UML图（Java 8）</h2><p>可以看到真正的实现类有</p>\n<ol>\n<li>ThreadPoolExecutor (1.5)</li>\n<li>ForkJoinPool (1.7)</li>\n<li>ScheduledThreadPoolExecutor (1.5)</li>\n</ol>\n<p>今天我们主要谈谈 ThreadPoolExecutor 也是使用率较高的一个实现。</p>\n<h2 id=\"Executors提供的工厂方法\"><a href=\"#Executors提供的工厂方法\" class=\"headerlink\" title=\"Executors提供的工厂方法\"></a>Executors提供的工厂方法</h2><ol>\n<li>newCachedThreadPool (ThreadPoolExecutor)</li>\n</ol>\n<blockquote>\n<p>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程,那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p>\n</blockquote>\n<ol>\n<li>newFixedThreadPool (ThreadPoolExecutor)</li>\n</ol>\n<blockquote>\n<p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p>\n</blockquote>\n<ol>\n<li>newSingleThreadExecutor (ThreadPoolExecutor)</li>\n</ol>\n<blockquote>\n<p>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>\n</blockquote>\n<ol>\n<li>newScheduledThreadPool (ScheduledThreadPoolExecutor)</li>\n</ol>\n<blockquote>\n<p>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>\n</blockquote>\n<ol>\n<li>newSingleThreadScheduledExecutor (ScheduledThreadPoolExecutor)</li>\n</ol>\n<blockquote>\n<p>创建一个单线程用于定时以及周期性执行任务的需求。</p>\n</blockquote>\n<ol>\n<li>newWorkStealingPool (1.8 ForkJoinPool)</li>\n</ol>\n<blockquote>\n<p>创建一个工作窃取</p>\n</blockquote>\n<p>可以看到各种不同的工厂方法中使用的线程池实现类最终只有3个，对应关系如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">工厂方法</th>\n<th align=\"left\">实现类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">newCachedThreadPool</td>\n<td align=\"left\">ThreadPoolExecutor</td>\n</tr>\n<tr>\n<td align=\"left\">newFixedThreadPool</td>\n<td align=\"left\">ThreadPoolExecutor</td>\n</tr>\n<tr>\n<td align=\"left\">newSingleThreadExecutor</td>\n<td align=\"left\">ThreadPoolExecutor</td>\n</tr>\n<tr>\n<td align=\"left\">newScheduledThreadPool</td>\n<td align=\"left\">ScheduledThreadPoolExecutor</td>\n</tr>\n<tr>\n<td align=\"left\">newSingleThreadScheduledExecutor</td>\n<td align=\"left\">ScheduledThreadPoolExecutor</td>\n</tr>\n<tr>\n<td align=\"left\">newWorkStealingPool</td>\n<td align=\"left\">ForkJoinPool</td>\n</tr>\n</tbody></table>\n<h2 id=\"ThreadPoolExecutor\"><a href=\"#ThreadPoolExecutor\" class=\"headerlink\" title=\"ThreadPoolExecutor\"></a>ThreadPoolExecutor</h2><p>首先我们看下 ThreadPoolExecutor 的完全构造函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public ThreadPoolExecutor(int corePoolSize,</span><br><span class=\"line\">                              int maximumPoolSize,</span><br><span class=\"line\">                              long keepAliveTime,</span><br><span class=\"line\">                              TimeUnit unit,</span><br><span class=\"line\">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class=\"line\">                              ThreadFactory threadFactory,</span><br><span class=\"line\">                              RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>corePoolSize</li>\n</ol>\n<blockquote>\n<p>核心池大小，除非设置了 allowCoreThreadTimeOut 否则哪怕线程超过空闲时间，池中也要最少要保留这个数目的线程。</p>\n<p>需要注意的是，corePoolSize所需的线程并不是立即创建的，需要在提交任务之后进行创建，所以如果有大量的缓存线程数可以先提交一个空任务让线程池将线程先创建出来，从而提升后续的执行效率。</p>\n</blockquote>\n<ol>\n<li>maximumPoolSize</li>\n</ol>\n<blockquote>\n<p>允许的最大线程数。</p>\n</blockquote>\n<ol>\n<li>keepAliveTime</li>\n</ol>\n<blockquote>\n<p>空闲线程空闲存活时间，核心线程需要 allowCoreThreadTimeOut 为true才会退出。</p>\n</blockquote>\n<ol>\n<li>unit</li>\n</ol>\n<blockquote>\n<p>与 keepAliveTime配合，设置 keepAliveTime的单位，如：毫秒、秒。</p>\n</blockquote>\n<ol>\n<li>workQueue</li>\n</ol>\n<blockquote>\n<p>线程池中的任务队列。上面提到线程池的主要作用是复用线程来处理任务，所以我们需要一个队列来存放需要执行的任务，在使用池中的线程来处理这些任务，所以我们需要一个任务队列。</p>\n</blockquote>\n<ol>\n<li>threadFactory</li>\n</ol>\n<blockquote>\n<p>当线程池判断需要新的线程时通过线程工程创建线程。</p>\n</blockquote>\n<ol>\n<li>handler</li>\n</ol>\n<blockquote>\n<p>执行被阻止时的处理程序，线程池无法处理。这个与任务队列相关，比如队列中可以指定队列大小，如果超过了这个大小该怎么办呢？JDK已经为我们考虑到了，并提供了4个默认实现。</p>\n</blockquote>\n<p>下列是JDK中默认携带的策略:</p>\n<ol>\n<li>AbortPolicy (默认)</li>\n</ol>\n<blockquote>\n<p>抛出 RejectedExecutionException 异常。</p>\n</blockquote>\n<ol>\n<li>CallerRunsPolicy</li>\n</ol>\n<blockquote>\n<p>调用当前线程池所在的线程去执行。</p>\n</blockquote>\n<ol>\n<li>DiscardPolicy</li>\n</ol>\n<blockquote>\n<p>直接丢弃当前任务。</p>\n</blockquote>\n<ol>\n<li>DiscardOldestPolicy</li>\n</ol>\n<blockquote>\n<p>将最旧的任务丢弃，将当前任务添加到队列。</p>\n</blockquote>\n<p>容易混淆的参数：corePoolSize maximumPoolSize workQueue</p>\n<h3 id=\"任务队列、核心线程数、最大线程数的逻辑关系\"><a href=\"#任务队列、核心线程数、最大线程数的逻辑关系\" class=\"headerlink\" title=\"任务队列、核心线程数、最大线程数的逻辑关系\"></a>任务队列、核心线程数、最大线程数的逻辑关系</h3><ol>\n<li>当线程数小于核心线程数时，创建线程。</li>\n<li>当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列。</li>\n<li>当线程数大于等于核心线程数，且任务队列已满<ol>\n<li>若线程数小于最大线程数，创建线程</li>\n<li>若线程数等于最大线程数，调用拒绝执行处理程序（默认效果为：抛出异常，拒绝任务）</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"那么这三个参数推荐如何设置，有最优值吗？\"><a href=\"#那么这三个参数推荐如何设置，有最优值吗？\" class=\"headerlink\" title=\"那么这三个参数推荐如何设置，有最优值吗？\"></a>那么这三个参数推荐如何设置，有最优值吗？</h3><p>由于java对于协程的支持不友好，所以会大量依赖于线程池和线程。<br>从而这个值没有最优推荐，需要根据业务需求情况来进行设置。<br>不同的需求类型可以创建多个不同的线程池来执行。</p>\n<h2 id=\"问题1：阿里开发规范为什么不允许Executors快速创建线程池？\"><a href=\"#问题1：阿里开发规范为什么不允许Executors快速创建线程池？\" class=\"headerlink\" title=\"问题1：阿里开发规范为什么不允许Executors快速创建线程池？\"></a>问题1：阿里开发规范为什么不允许Executors快速创建线程池？</h2><blockquote>\n<p>参考地址：<a href=\"https://github.com/alibaba/p3c\">https://github.com/alibaba/p3c</a></p>\n</blockquote>\n<p>可以看到原因很简单</p>\n<ol>\n<li>newSingleThreadExecutor</li>\n<li>newFixedThreadPool</li>\n</ol>\n<p>在 workQueue 参数直接 使用了 new LinkedBlockingQueue<Runnable>() 理论上可以无限添加任务到线程池。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class=\"line\">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class=\"line\">                                    0L, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                    new LinkedBlockingQueue&lt;Runnable&gt;();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class=\"line\">    return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1,</span><br><span class=\"line\">    1,</span><br><span class=\"line\">    0L,</span><br><span class=\"line\">    TimeUnit.MILLISECONDS,</span><br><span class=\"line\">    new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果提交到线程池的任务由问题，比如 sleep 永久，会造成内存泄漏，最终导致OOM。</p>\n<p>同时 阿里还推荐自定义 threadFactory 设置线程名称便于以后排查问题。</p>\n<h2 id=\"问题2：下面的代码输出是什么？\"><a href=\"#问题2：下面的代码输出是什么？\" class=\"headerlink\" title=\"问题2：下面的代码输出是什么？\"></a>问题2：下面的代码输出是什么？</h2><p>应该选C。<br>虽然最大线程数有100但核心线程数为1，任务队列由100。<br>满足了 当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列，这个条件。<br>所以后续添加的任务都会被堵塞。</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>关于 ThreadPoolExecutor 的逻辑在实际使用的时候会有点奇怪，因为线程池中的线程并没有超过最大线程数，有没有一种可能当任务被堵塞很久的时候创建新的线程池来处理呢？</p>\n<p>这边推荐大家使用 newWorkStealingPool，也就是ForkJoinPool。采取了工作窃取的模式。</p>\n"},{"title":"Java线程池 工作窃取算法","date":"2022-03-18T09:29:26.000Z","_content":"\n# 前言\n\n在上一篇《java线程池,阿里为什么不允许使用Executors?》中我们谈及了线程池，同时又发现一个现象，当最大线程数还没有满的时候耗时的任务全部堆积给了单个线程, 代码如下:\n\n```\nThreadPoolExecutor executor = new ThreadPoolExecutor(\n        1, //corePoolSize\n        100, //maximumPoolSize\n        100, //keepAliveTime\n        TimeUnit.SECONDS, //unit\n        new LinkedBlockingDeque<>(100));//workQueue\n\nfor (int i = 0; i < 5; i++) {\n    final int taskIndex = i;\n    executor.execute(() -> {\n        System.out.println(taskIndex);\n        try {\n            Thread.sleep(Long.MAX_VALUE);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    });\n}\n// 输出: 0\n```\n\n那么有没有一种机制，在线程池中还有线程可以提供服务的时候帮忙分担一些已经被分配给某一个线程的耗时任务呢？\n答案当然是有的：**工作窃取算法**\n\n# 工作窃取 (Work stealing)\n\n**工作窃取核心思想是，自己的活干完了去看看别人有没有没干完的活，如果有就拿过来帮他干。**\n大多数实现机制是：**为每个工作者程分配一个双端队列(本地队列)用于存放需要执行的任务，当自己的队列没有数据的时候从其它工作者队列中获得一个任务继续执行。**\n\n比如工作者B的本地队列中没有了需要执行的规则，它正尝试从工作者A的任务队列中偷取一个任务。\n\n> 为什么说尝试？因为涉及到并行编程肯定涉及到并发安全的问题，有可能在偷取过程中工作者A提前抢占了这个任务，那么B的偷取就会失败。大多数实现会尽量避免发生这个问题，所以大多数情况下不会发生。\n\n## 并发安全的问题是怎么避免的呢？\n\n一般是自己的本地队列采取LIFO(后进先出)，偷取时采用FIFO(先进先出)，一个从头开始执行，一个从尾部开始执行，由于偷取的动作十分快速，会大量降低这种冲突，也是一种优化方式。\n\n# Java中的工作窃取算法线程池\n\n在Java 1.7新增了一个ForkJoinPool类，主要是实现了工作窃取算法的线程池，该类在1.8中被优化了，同时1.8在Executors类中还新增了两个newWorkStealingPool工厂方法。\n\n> java7中的fork/join task 和 java8中的并行stream都是基于ForkJoinPool。\n\n```\n// 使用当前处理器数, 相当于调用 newWorkStealingPool(Runtime.getRuntime().availableProcessors());\npublic static ExecutorService newWorkStealingPool();\npublic static ExecutorService newWorkStealingPool(int parallelism);\n```\n\n同时 ForkJoinPool 还在全局建立了一个公共的线程池\n\n```\nForkJoinPool.commonPool();\n```\n\n默认的并行度是当前JVM识别到的处理器数。这个值也是可以通过参数进行变更的，下面是可以通过JVM熟悉进行commonPool设置的参数。\n\n> 前缀统一为: java.util.concurrent.ForkJoinPool.common.\n> 比如 parallelism 就要写为 java.util.concurrent.ForkJoinPool.common.parallelism\n\n| 参数             | 描述               | 默认值                                          |\n| :--------------- | :----------------- | :---------------------------------------------- |\n| parallelism      | 并行级别           | JVM识别到的处理器数                             |\n| threadFactory    | 线程工厂类名       | ForkJoinPool.DefaultForkJoinWorkerThreadFactory |\n| exceptionHandler | 错误处理程序       | null                                            |\n| maximumSpares    | 最大允许额外线程数 | 256                                             |\n\n使用工作窃取算法的线程池来优化之前的代码\n\n```\nExecutorService executor = Executors.newWorkStealingPool(8);\n\nfor (int i = 0; i < 5; i++) {\n    final int taskIndex = i;\n    executor.execute(() -> {\n        System.out.println(taskIndex);\n        try {\n            Thread.sleep(Long.MAX_VALUE);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    });\n}\n\n// 无序输出 0~4\n```\n\n### 如果将Executors.newWorkStealingPool(8)改成ForkJoinPool.commonPool()会输出什么？\n\n如果你能知道输出什么那么你对这个机制就算掌握了，会输出当前运行环境中处理器（cpu）数量的次数（如果核算大于5就只会输出5个结果）。\n\n## newWorkStealingPool 和 ForkJoinPool.commonPool 该优先选择哪个？\n\n这个没有最优解，推荐执行的小任务（零散的）使用commonPool，而有特定目的的则使用newWorkStealingPool或 new ForkJoinPool。\n\n## 使用ForkJoinPool.commonPool 需要注意的问题\n\ncommonPool默认使用当前环境的处理器格式来当做并行程度，如果遇上堵塞形任务一样会遇到浪费算力的问题。\n这点在容器化时需要特别注意，因为容器化的cpu个数限制往往不会太大。\n这种时候可以通过设置默认的并行度或者使用newWorkStealingPool来手动指定并行度。\n\n# 最后\n\n## 为什么ForkJoinPool极少出现线程关键字？\n\n现在许多语言淡化了线程这个概念，而golang中更是直接去掉了线程能力改为提供协程goroutine。\n目的还是线程是OS的资源，OS对程序内部运行其实并没有太了解，为了避免线程资源的浪费许多语言会自己管理线程。\n对于程序来说我们关心的主要还是任务的并行运行，并不关心是线程还是协程。\n下面是一些对应关系：\n\n- CPU : 线程 (1:N)\n- 线程 : 协程 (1:N)\n\n> CPU由OS管理，OS提供线程给程序使用，程序利用线程提供协程能力给应用使用。\n\n## ForkJoinPool一定更快吗？\n\n不，大家都知道做的事情越多逻辑越复杂效率会越低。\nForkJoinPool中的工作队列，工作窃取都是需要额外管理的，同时也对线程调度和GC带来了压力。\n所以ForkJoinPool并不是万能药大家根据具体需要去使用。\n\n","source":"_posts/Java线程池-工作窃取算法.md","raw":"---\ntitle: Java线程池 工作窃取算法\ndate: 2022-03-18 17:29:26\ntags: Java\n---\n\n# 前言\n\n在上一篇《java线程池,阿里为什么不允许使用Executors?》中我们谈及了线程池，同时又发现一个现象，当最大线程数还没有满的时候耗时的任务全部堆积给了单个线程, 代码如下:\n\n```\nThreadPoolExecutor executor = new ThreadPoolExecutor(\n        1, //corePoolSize\n        100, //maximumPoolSize\n        100, //keepAliveTime\n        TimeUnit.SECONDS, //unit\n        new LinkedBlockingDeque<>(100));//workQueue\n\nfor (int i = 0; i < 5; i++) {\n    final int taskIndex = i;\n    executor.execute(() -> {\n        System.out.println(taskIndex);\n        try {\n            Thread.sleep(Long.MAX_VALUE);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    });\n}\n// 输出: 0\n```\n\n那么有没有一种机制，在线程池中还有线程可以提供服务的时候帮忙分担一些已经被分配给某一个线程的耗时任务呢？\n答案当然是有的：**工作窃取算法**\n\n# 工作窃取 (Work stealing)\n\n**工作窃取核心思想是，自己的活干完了去看看别人有没有没干完的活，如果有就拿过来帮他干。**\n大多数实现机制是：**为每个工作者程分配一个双端队列(本地队列)用于存放需要执行的任务，当自己的队列没有数据的时候从其它工作者队列中获得一个任务继续执行。**\n\n比如工作者B的本地队列中没有了需要执行的规则，它正尝试从工作者A的任务队列中偷取一个任务。\n\n> 为什么说尝试？因为涉及到并行编程肯定涉及到并发安全的问题，有可能在偷取过程中工作者A提前抢占了这个任务，那么B的偷取就会失败。大多数实现会尽量避免发生这个问题，所以大多数情况下不会发生。\n\n## 并发安全的问题是怎么避免的呢？\n\n一般是自己的本地队列采取LIFO(后进先出)，偷取时采用FIFO(先进先出)，一个从头开始执行，一个从尾部开始执行，由于偷取的动作十分快速，会大量降低这种冲突，也是一种优化方式。\n\n# Java中的工作窃取算法线程池\n\n在Java 1.7新增了一个ForkJoinPool类，主要是实现了工作窃取算法的线程池，该类在1.8中被优化了，同时1.8在Executors类中还新增了两个newWorkStealingPool工厂方法。\n\n> java7中的fork/join task 和 java8中的并行stream都是基于ForkJoinPool。\n\n```\n// 使用当前处理器数, 相当于调用 newWorkStealingPool(Runtime.getRuntime().availableProcessors());\npublic static ExecutorService newWorkStealingPool();\npublic static ExecutorService newWorkStealingPool(int parallelism);\n```\n\n同时 ForkJoinPool 还在全局建立了一个公共的线程池\n\n```\nForkJoinPool.commonPool();\n```\n\n默认的并行度是当前JVM识别到的处理器数。这个值也是可以通过参数进行变更的，下面是可以通过JVM熟悉进行commonPool设置的参数。\n\n> 前缀统一为: java.util.concurrent.ForkJoinPool.common.\n> 比如 parallelism 就要写为 java.util.concurrent.ForkJoinPool.common.parallelism\n\n| 参数             | 描述               | 默认值                                          |\n| :--------------- | :----------------- | :---------------------------------------------- |\n| parallelism      | 并行级别           | JVM识别到的处理器数                             |\n| threadFactory    | 线程工厂类名       | ForkJoinPool.DefaultForkJoinWorkerThreadFactory |\n| exceptionHandler | 错误处理程序       | null                                            |\n| maximumSpares    | 最大允许额外线程数 | 256                                             |\n\n使用工作窃取算法的线程池来优化之前的代码\n\n```\nExecutorService executor = Executors.newWorkStealingPool(8);\n\nfor (int i = 0; i < 5; i++) {\n    final int taskIndex = i;\n    executor.execute(() -> {\n        System.out.println(taskIndex);\n        try {\n            Thread.sleep(Long.MAX_VALUE);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    });\n}\n\n// 无序输出 0~4\n```\n\n### 如果将Executors.newWorkStealingPool(8)改成ForkJoinPool.commonPool()会输出什么？\n\n如果你能知道输出什么那么你对这个机制就算掌握了，会输出当前运行环境中处理器（cpu）数量的次数（如果核算大于5就只会输出5个结果）。\n\n## newWorkStealingPool 和 ForkJoinPool.commonPool 该优先选择哪个？\n\n这个没有最优解，推荐执行的小任务（零散的）使用commonPool，而有特定目的的则使用newWorkStealingPool或 new ForkJoinPool。\n\n## 使用ForkJoinPool.commonPool 需要注意的问题\n\ncommonPool默认使用当前环境的处理器格式来当做并行程度，如果遇上堵塞形任务一样会遇到浪费算力的问题。\n这点在容器化时需要特别注意，因为容器化的cpu个数限制往往不会太大。\n这种时候可以通过设置默认的并行度或者使用newWorkStealingPool来手动指定并行度。\n\n# 最后\n\n## 为什么ForkJoinPool极少出现线程关键字？\n\n现在许多语言淡化了线程这个概念，而golang中更是直接去掉了线程能力改为提供协程goroutine。\n目的还是线程是OS的资源，OS对程序内部运行其实并没有太了解，为了避免线程资源的浪费许多语言会自己管理线程。\n对于程序来说我们关心的主要还是任务的并行运行，并不关心是线程还是协程。\n下面是一些对应关系：\n\n- CPU : 线程 (1:N)\n- 线程 : 协程 (1:N)\n\n> CPU由OS管理，OS提供线程给程序使用，程序利用线程提供协程能力给应用使用。\n\n## ForkJoinPool一定更快吗？\n\n不，大家都知道做的事情越多逻辑越复杂效率会越低。\nForkJoinPool中的工作队列，工作窃取都是需要额外管理的，同时也对线程调度和GC带来了压力。\n所以ForkJoinPool并不是万能药大家根据具体需要去使用。\n\n","slug":"Java线程池-工作窃取算法","published":1,"updated":"2022-03-18T09:34:20.639Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0w85rpm0000kwln248m0180","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在上一篇《java线程池,阿里为什么不允许使用Executors?》中我们谈及了线程池，同时又发现一个现象，当最大线程数还没有满的时候耗时的任务全部堆积给了单个线程, 代码如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadPoolExecutor executor = new ThreadPoolExecutor(</span><br><span class=\"line\">        1, //corePoolSize</span><br><span class=\"line\">        100, //maximumPoolSize</span><br><span class=\"line\">        100, //keepAliveTime</span><br><span class=\"line\">        TimeUnit.SECONDS, //unit</span><br><span class=\"line\">        new LinkedBlockingDeque&lt;&gt;(100));//workQueue</span><br><span class=\"line\"></span><br><span class=\"line\">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class=\"line\">    final int taskIndex = i;</span><br><span class=\"line\">    executor.execute(() -&gt; &#123;</span><br><span class=\"line\">        System.out.println(taskIndex);</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(Long.MAX_VALUE);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 输出: 0</span><br></pre></td></tr></table></figure>\n\n<p>那么有没有一种机制，在线程池中还有线程可以提供服务的时候帮忙分担一些已经被分配给某一个线程的耗时任务呢？<br>答案当然是有的：<strong>工作窃取算法</strong></p>\n<h1 id=\"工作窃取-Work-stealing\"><a href=\"#工作窃取-Work-stealing\" class=\"headerlink\" title=\"工作窃取 (Work stealing)\"></a>工作窃取 (Work stealing)</h1><p><strong>工作窃取核心思想是，自己的活干完了去看看别人有没有没干完的活，如果有就拿过来帮他干。</strong><br>大多数实现机制是：<strong>为每个工作者程分配一个双端队列(本地队列)用于存放需要执行的任务，当自己的队列没有数据的时候从其它工作者队列中获得一个任务继续执行。</strong></p>\n<p>比如工作者B的本地队列中没有了需要执行的规则，它正尝试从工作者A的任务队列中偷取一个任务。</p>\n<blockquote>\n<p>为什么说尝试？因为涉及到并行编程肯定涉及到并发安全的问题，有可能在偷取过程中工作者A提前抢占了这个任务，那么B的偷取就会失败。大多数实现会尽量避免发生这个问题，所以大多数情况下不会发生。</p>\n</blockquote>\n<h2 id=\"并发安全的问题是怎么避免的呢？\"><a href=\"#并发安全的问题是怎么避免的呢？\" class=\"headerlink\" title=\"并发安全的问题是怎么避免的呢？\"></a>并发安全的问题是怎么避免的呢？</h2><p>一般是自己的本地队列采取LIFO(后进先出)，偷取时采用FIFO(先进先出)，一个从头开始执行，一个从尾部开始执行，由于偷取的动作十分快速，会大量降低这种冲突，也是一种优化方式。</p>\n<h1 id=\"Java中的工作窃取算法线程池\"><a href=\"#Java中的工作窃取算法线程池\" class=\"headerlink\" title=\"Java中的工作窃取算法线程池\"></a>Java中的工作窃取算法线程池</h1><p>在Java 1.7新增了一个ForkJoinPool类，主要是实现了工作窃取算法的线程池，该类在1.8中被优化了，同时1.8在Executors类中还新增了两个newWorkStealingPool工厂方法。</p>\n<blockquote>\n<p>java7中的fork/join task 和 java8中的并行stream都是基于ForkJoinPool。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用当前处理器数, 相当于调用 newWorkStealingPool(Runtime.getRuntime().availableProcessors());</span><br><span class=\"line\">public static ExecutorService newWorkStealingPool();</span><br><span class=\"line\">public static ExecutorService newWorkStealingPool(int parallelism);</span><br></pre></td></tr></table></figure>\n\n<p>同时 ForkJoinPool 还在全局建立了一个公共的线程池</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ForkJoinPool.commonPool();</span><br></pre></td></tr></table></figure>\n\n<p>默认的并行度是当前JVM识别到的处理器数。这个值也是可以通过参数进行变更的，下面是可以通过JVM熟悉进行commonPool设置的参数。</p>\n<blockquote>\n<p>前缀统一为: java.util.concurrent.ForkJoinPool.common.<br>比如 parallelism 就要写为 java.util.concurrent.ForkJoinPool.common.parallelism</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">parallelism</td>\n<td align=\"left\">并行级别</td>\n<td align=\"left\">JVM识别到的处理器数</td>\n</tr>\n<tr>\n<td align=\"left\">threadFactory</td>\n<td align=\"left\">线程工厂类名</td>\n<td align=\"left\">ForkJoinPool.DefaultForkJoinWorkerThreadFactory</td>\n</tr>\n<tr>\n<td align=\"left\">exceptionHandler</td>\n<td align=\"left\">错误处理程序</td>\n<td align=\"left\">null</td>\n</tr>\n<tr>\n<td align=\"left\">maximumSpares</td>\n<td align=\"left\">最大允许额外线程数</td>\n<td align=\"left\">256</td>\n</tr>\n</tbody></table>\n<p>使用工作窃取算法的线程池来优化之前的代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService executor = Executors.newWorkStealingPool(8);</span><br><span class=\"line\"></span><br><span class=\"line\">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class=\"line\">    final int taskIndex = i;</span><br><span class=\"line\">    executor.execute(() -&gt; &#123;</span><br><span class=\"line\">        System.out.println(taskIndex);</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(Long.MAX_VALUE);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 无序输出 0~4</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"如果将Executors-newWorkStealingPool-8-改成ForkJoinPool-commonPool-会输出什么？\"><a href=\"#如果将Executors-newWorkStealingPool-8-改成ForkJoinPool-commonPool-会输出什么？\" class=\"headerlink\" title=\"如果将Executors.newWorkStealingPool(8)改成ForkJoinPool.commonPool()会输出什么？\"></a>如果将Executors.newWorkStealingPool(8)改成ForkJoinPool.commonPool()会输出什么？</h3><p>如果你能知道输出什么那么你对这个机制就算掌握了，会输出当前运行环境中处理器（cpu）数量的次数（如果核算大于5就只会输出5个结果）。</p>\n<h2 id=\"newWorkStealingPool-和-ForkJoinPool-commonPool-该优先选择哪个？\"><a href=\"#newWorkStealingPool-和-ForkJoinPool-commonPool-该优先选择哪个？\" class=\"headerlink\" title=\"newWorkStealingPool 和 ForkJoinPool.commonPool 该优先选择哪个？\"></a>newWorkStealingPool 和 ForkJoinPool.commonPool 该优先选择哪个？</h2><p>这个没有最优解，推荐执行的小任务（零散的）使用commonPool，而有特定目的的则使用newWorkStealingPool或 new ForkJoinPool。</p>\n<h2 id=\"使用ForkJoinPool-commonPool-需要注意的问题\"><a href=\"#使用ForkJoinPool-commonPool-需要注意的问题\" class=\"headerlink\" title=\"使用ForkJoinPool.commonPool 需要注意的问题\"></a>使用ForkJoinPool.commonPool 需要注意的问题</h2><p>commonPool默认使用当前环境的处理器格式来当做并行程度，如果遇上堵塞形任务一样会遇到浪费算力的问题。<br>这点在容器化时需要特别注意，因为容器化的cpu个数限制往往不会太大。<br>这种时候可以通过设置默认的并行度或者使用newWorkStealingPool来手动指定并行度。</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><h2 id=\"为什么ForkJoinPool极少出现线程关键字？\"><a href=\"#为什么ForkJoinPool极少出现线程关键字？\" class=\"headerlink\" title=\"为什么ForkJoinPool极少出现线程关键字？\"></a>为什么ForkJoinPool极少出现线程关键字？</h2><p>现在许多语言淡化了线程这个概念，而golang中更是直接去掉了线程能力改为提供协程goroutine。<br>目的还是线程是OS的资源，OS对程序内部运行其实并没有太了解，为了避免线程资源的浪费许多语言会自己管理线程。<br>对于程序来说我们关心的主要还是任务的并行运行，并不关心是线程还是协程。<br>下面是一些对应关系：</p>\n<ul>\n<li>CPU : 线程 (1:N)</li>\n<li>线程 : 协程 (1:N)</li>\n</ul>\n<blockquote>\n<p>CPU由OS管理，OS提供线程给程序使用，程序利用线程提供协程能力给应用使用。</p>\n</blockquote>\n<h2 id=\"ForkJoinPool一定更快吗？\"><a href=\"#ForkJoinPool一定更快吗？\" class=\"headerlink\" title=\"ForkJoinPool一定更快吗？\"></a>ForkJoinPool一定更快吗？</h2><p>不，大家都知道做的事情越多逻辑越复杂效率会越低。<br>ForkJoinPool中的工作队列，工作窃取都是需要额外管理的，同时也对线程调度和GC带来了压力。<br>所以ForkJoinPool并不是万能药大家根据具体需要去使用。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在上一篇《java线程池,阿里为什么不允许使用Executors?》中我们谈及了线程池，同时又发现一个现象，当最大线程数还没有满的时候耗时的任务全部堆积给了单个线程, 代码如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadPoolExecutor executor = new ThreadPoolExecutor(</span><br><span class=\"line\">        1, //corePoolSize</span><br><span class=\"line\">        100, //maximumPoolSize</span><br><span class=\"line\">        100, //keepAliveTime</span><br><span class=\"line\">        TimeUnit.SECONDS, //unit</span><br><span class=\"line\">        new LinkedBlockingDeque&lt;&gt;(100));//workQueue</span><br><span class=\"line\"></span><br><span class=\"line\">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class=\"line\">    final int taskIndex = i;</span><br><span class=\"line\">    executor.execute(() -&gt; &#123;</span><br><span class=\"line\">        System.out.println(taskIndex);</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(Long.MAX_VALUE);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 输出: 0</span><br></pre></td></tr></table></figure>\n\n<p>那么有没有一种机制，在线程池中还有线程可以提供服务的时候帮忙分担一些已经被分配给某一个线程的耗时任务呢？<br>答案当然是有的：<strong>工作窃取算法</strong></p>\n<h1 id=\"工作窃取-Work-stealing\"><a href=\"#工作窃取-Work-stealing\" class=\"headerlink\" title=\"工作窃取 (Work stealing)\"></a>工作窃取 (Work stealing)</h1><p><strong>工作窃取核心思想是，自己的活干完了去看看别人有没有没干完的活，如果有就拿过来帮他干。</strong><br>大多数实现机制是：<strong>为每个工作者程分配一个双端队列(本地队列)用于存放需要执行的任务，当自己的队列没有数据的时候从其它工作者队列中获得一个任务继续执行。</strong></p>\n<p>比如工作者B的本地队列中没有了需要执行的规则，它正尝试从工作者A的任务队列中偷取一个任务。</p>\n<blockquote>\n<p>为什么说尝试？因为涉及到并行编程肯定涉及到并发安全的问题，有可能在偷取过程中工作者A提前抢占了这个任务，那么B的偷取就会失败。大多数实现会尽量避免发生这个问题，所以大多数情况下不会发生。</p>\n</blockquote>\n<h2 id=\"并发安全的问题是怎么避免的呢？\"><a href=\"#并发安全的问题是怎么避免的呢？\" class=\"headerlink\" title=\"并发安全的问题是怎么避免的呢？\"></a>并发安全的问题是怎么避免的呢？</h2><p>一般是自己的本地队列采取LIFO(后进先出)，偷取时采用FIFO(先进先出)，一个从头开始执行，一个从尾部开始执行，由于偷取的动作十分快速，会大量降低这种冲突，也是一种优化方式。</p>\n<h1 id=\"Java中的工作窃取算法线程池\"><a href=\"#Java中的工作窃取算法线程池\" class=\"headerlink\" title=\"Java中的工作窃取算法线程池\"></a>Java中的工作窃取算法线程池</h1><p>在Java 1.7新增了一个ForkJoinPool类，主要是实现了工作窃取算法的线程池，该类在1.8中被优化了，同时1.8在Executors类中还新增了两个newWorkStealingPool工厂方法。</p>\n<blockquote>\n<p>java7中的fork/join task 和 java8中的并行stream都是基于ForkJoinPool。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用当前处理器数, 相当于调用 newWorkStealingPool(Runtime.getRuntime().availableProcessors());</span><br><span class=\"line\">public static ExecutorService newWorkStealingPool();</span><br><span class=\"line\">public static ExecutorService newWorkStealingPool(int parallelism);</span><br></pre></td></tr></table></figure>\n\n<p>同时 ForkJoinPool 还在全局建立了一个公共的线程池</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ForkJoinPool.commonPool();</span><br></pre></td></tr></table></figure>\n\n<p>默认的并行度是当前JVM识别到的处理器数。这个值也是可以通过参数进行变更的，下面是可以通过JVM熟悉进行commonPool设置的参数。</p>\n<blockquote>\n<p>前缀统一为: java.util.concurrent.ForkJoinPool.common.<br>比如 parallelism 就要写为 java.util.concurrent.ForkJoinPool.common.parallelism</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">parallelism</td>\n<td align=\"left\">并行级别</td>\n<td align=\"left\">JVM识别到的处理器数</td>\n</tr>\n<tr>\n<td align=\"left\">threadFactory</td>\n<td align=\"left\">线程工厂类名</td>\n<td align=\"left\">ForkJoinPool.DefaultForkJoinWorkerThreadFactory</td>\n</tr>\n<tr>\n<td align=\"left\">exceptionHandler</td>\n<td align=\"left\">错误处理程序</td>\n<td align=\"left\">null</td>\n</tr>\n<tr>\n<td align=\"left\">maximumSpares</td>\n<td align=\"left\">最大允许额外线程数</td>\n<td align=\"left\">256</td>\n</tr>\n</tbody></table>\n<p>使用工作窃取算法的线程池来优化之前的代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService executor = Executors.newWorkStealingPool(8);</span><br><span class=\"line\"></span><br><span class=\"line\">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class=\"line\">    final int taskIndex = i;</span><br><span class=\"line\">    executor.execute(() -&gt; &#123;</span><br><span class=\"line\">        System.out.println(taskIndex);</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(Long.MAX_VALUE);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 无序输出 0~4</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"如果将Executors-newWorkStealingPool-8-改成ForkJoinPool-commonPool-会输出什么？\"><a href=\"#如果将Executors-newWorkStealingPool-8-改成ForkJoinPool-commonPool-会输出什么？\" class=\"headerlink\" title=\"如果将Executors.newWorkStealingPool(8)改成ForkJoinPool.commonPool()会输出什么？\"></a>如果将Executors.newWorkStealingPool(8)改成ForkJoinPool.commonPool()会输出什么？</h3><p>如果你能知道输出什么那么你对这个机制就算掌握了，会输出当前运行环境中处理器（cpu）数量的次数（如果核算大于5就只会输出5个结果）。</p>\n<h2 id=\"newWorkStealingPool-和-ForkJoinPool-commonPool-该优先选择哪个？\"><a href=\"#newWorkStealingPool-和-ForkJoinPool-commonPool-该优先选择哪个？\" class=\"headerlink\" title=\"newWorkStealingPool 和 ForkJoinPool.commonPool 该优先选择哪个？\"></a>newWorkStealingPool 和 ForkJoinPool.commonPool 该优先选择哪个？</h2><p>这个没有最优解，推荐执行的小任务（零散的）使用commonPool，而有特定目的的则使用newWorkStealingPool或 new ForkJoinPool。</p>\n<h2 id=\"使用ForkJoinPool-commonPool-需要注意的问题\"><a href=\"#使用ForkJoinPool-commonPool-需要注意的问题\" class=\"headerlink\" title=\"使用ForkJoinPool.commonPool 需要注意的问题\"></a>使用ForkJoinPool.commonPool 需要注意的问题</h2><p>commonPool默认使用当前环境的处理器格式来当做并行程度，如果遇上堵塞形任务一样会遇到浪费算力的问题。<br>这点在容器化时需要特别注意，因为容器化的cpu个数限制往往不会太大。<br>这种时候可以通过设置默认的并行度或者使用newWorkStealingPool来手动指定并行度。</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><h2 id=\"为什么ForkJoinPool极少出现线程关键字？\"><a href=\"#为什么ForkJoinPool极少出现线程关键字？\" class=\"headerlink\" title=\"为什么ForkJoinPool极少出现线程关键字？\"></a>为什么ForkJoinPool极少出现线程关键字？</h2><p>现在许多语言淡化了线程这个概念，而golang中更是直接去掉了线程能力改为提供协程goroutine。<br>目的还是线程是OS的资源，OS对程序内部运行其实并没有太了解，为了避免线程资源的浪费许多语言会自己管理线程。<br>对于程序来说我们关心的主要还是任务的并行运行，并不关心是线程还是协程。<br>下面是一些对应关系：</p>\n<ul>\n<li>CPU : 线程 (1:N)</li>\n<li>线程 : 协程 (1:N)</li>\n</ul>\n<blockquote>\n<p>CPU由OS管理，OS提供线程给程序使用，程序利用线程提供协程能力给应用使用。</p>\n</blockquote>\n<h2 id=\"ForkJoinPool一定更快吗？\"><a href=\"#ForkJoinPool一定更快吗？\" class=\"headerlink\" title=\"ForkJoinPool一定更快吗？\"></a>ForkJoinPool一定更快吗？</h2><p>不，大家都知道做的事情越多逻辑越复杂效率会越低。<br>ForkJoinPool中的工作队列，工作窃取都是需要额外管理的，同时也对线程调度和GC带来了压力。<br>所以ForkJoinPool并不是万能药大家根据具体需要去使用。</p>\n"},{"title":"MyBatis数据源结构解析之连接池","date":"2022-03-19T13:30:44.000Z","_content":"\n### 概述\n\n连接池的作用就是为了提高性能，将已经创建好的连接保存在池中，当有请求来时，直接使用已经创建好的连接对Server端进行访问。这样省略了创建连接和销毁连接的过程，从而在性能上得到了提高。\n\n连接池设计的基本原理是这样的：\n（1）建立连接池对象（服务启动）。\n（2）按照事先指定的参数创建初始数量的连接（即：空闲连接数）。\n（3）对于一个访问请求，直接从连接池中得到一个连接。如果连接池对象中没有空闲的连接，且连接数没有达到最大（即：最大活跃连接数），创建一个新的连接；如果达到最大，则设定一定的超时时间，来获取连接。\n（4）运用连接访问服务。\n（5）访问服务完成，释放连接（此时的释放连接，并非真正关闭，而是将其放入空闲队列中。如实际空闲连接数大于初始空闲连接数则释放连接）。\n\n（6）释放连接池对象（服务停止、维护期间，释放连接池对象，并释放所有连接）。\n\n### 数据源的分类\n\n打开Mybatis源码找到datasource包，可以看到3个子package\n\n- UNPOOLED 不使用连接池的数据源\n- POOLED 使用连接池的数据源\n- JNDI 使用JNDI实现的数据源\n\nMyBatis内部分别定义了实现了java.sql.DataSource接口的UnpooledDataSource，PooledDataSource类来表示UNPOOLED、POOLED类型的数据源。 如下图所示：\n\n- PooledDataSource和UnpooledDataSrouce都实现了java.sql.DataSource接口。\n- PooledDataSource持有一个UnPooledDataSource的引用，当PooledDataSource要创建Connection实例时，实际还是通过UnPooledDataSource来创建的。PooledDataSource只是提供一种缓存连接池机制。\n\nJNDI类型的数据源DataSource，则是通过JNDI上下文中取值。\n\n\n\n### 数据源DataSource的创建过程\n\n在mybatis的XML配置文件中，使用<dataSource>元素来配置数据源：\n\n```xml\n<!-- 配置数据源（连接池） -->\n<dataSource type=\"POOLED\"> //这里 type 属性的取值就是为POOLED、UNPOOLED、JNDI\n  <property name=\"driver\" value=\"${jdbc.driver}\"/>\n  <property name=\"url\" value=\"${jdbc.url}\"/>\n  <property name=\"username\" value=\"${jdbc.username}\"/>\n  <property name=\"password\" value=\"${jdbc.password}\"/>\n</dataSource>\n```\n\nMyBatis在初始化时，解析此文件，根据<dataSource>的type属性来创建相应类型的的数据源DataSource，即：\n\n- type=”POOLED” ：创建PooledDataSource实例。\n- type=”UNPOOLED” ：创建UnpooledDataSource实例。\n- type=”JNDI” ：从JNDI服务上查找DataSource实例。\n\n\n\nMybatis是通过工厂模式来创建数据源对象的 我们来看看源码:\n\n```java\npublic interface DataSourceFactory {\n\nvoid setProperties(Properties props);\n\nDataSource getDataSource();//生产DataSource\n\n}\n```\n\n上述3种类型的数据源，对应有自己的工厂模式,都实现了这个DataSourceFactory。\n\nMyBatis创建了DataSource实例后，会将其放到Configuration对象内的Environment对象中， 供以后使用。\n\n注意dataSource 此时只会保存好配置信息，连接池此时并没有创建好连接。只有当程序在调用操作数据库的方法时，才会初始化连接。\n\n### DataSource什么时候创建Connection对象\n我们需要创建SqlSession对象并需要执行SQL语句时，这时候MyBatis才会去调用dataSource对象来创建java.sql.Connection对象。也就是说，java.sql.Connection对象的创建一直延迟到执行SQL语句的时候。\n\n```\n  @Test\n  public void testMyBatisBuild() throws IOException {\n      Reader reader = Resources.getResourceAsReader(\"mybatis-config.xml\");\n      SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader);\n      SqlSession sqlSession = factory.openSession();\n      TestMapper mapper = sqlSession.getMapper(TestMapper.class);\n      Ttest one = mapper.getOne(1L);// 直到这一行，才会去创建一个数据库连接\n      System.out.println(one);\n      sqlSession.close();\n  }\n```\n\n### 验证Connection创建时机\n\n首先我们先查出现在数据库的所有连接数，在数据库中执行\n\n```sql\nmysql> SELECT * FROM performance_schema.hosts;\n+-----------+---------------------+-------------------+\n| HOST      | CURRENT_CONNECTIONS | TOTAL_CONNECTIONS |\n+-----------+---------------------+-------------------+\n| NULL      |                  36 |                50 |\n| localhost |                   2 |                 5 |\n+-----------+---------------------+-------------------+\n2 rows in set (0.00 sec)\n```\n显示所有的任务列表\n\n```sql\n\nmysql>  show full processlist;\n+----+-----------------+-----------+---------+---------+--------+------------------------+-----------------------+\n| Id | User            | Host      | db      | Command | Time   | State                  | Info                  |\n+----+-----------------+-----------+---------+---------+--------+------------------------+-----------------------+\n|  5 | event_scheduler | localhost | NULL    | Daemon  | 883049 | Waiting on empty queue | NULL                  |\n| 15 | root            | localhost | kangpan | Query   |      0 | init                   | show full processlist |\n+----+-----------------+-----------+---------+---------+--------+------------------------+-----------------------+\n2 rows in set (0.01 sec)\n```\n\ndataSource.getConnection()执行完，至此一个connection才创建完成。我们验证一下 在dataSource.getConnection()时打一下断点。按F8 执行一步在控制台可以看到connection = com.mysql.jdbc.JDBC4Connection@1500b2f3 实例创建完毕，我们再去数据库中看看连接数加一。\n\n```java\n  protected void openConnection() throws SQLException {\n  if (log.isDebugEnabled()) {\n    log.debug(\"Opening JDBC Connection\");\n  }\n  connection = dataSource.getConnection();// 最终获取连接的地方在这句.\n  if (level != null) {\n    connection.setTransactionIsolation(level.getLevel());// 设置隔离等级\n  }\n  setDesiredAutoCommit(autoCommit);// 是否自动提交，默认false,update不会提交到数据库，需要手动commit\n}\n```\n\n### 不使用连接池的 UnpooledDataSource\n\n当 <dataSource>的type属性被配置成了”UNPOOLED”，MyBatis首先会实例化一个UnpooledDataSourceFactory工厂实例，然后通过.getDataSource()方法返回一个UnpooledDataSource实例对象引用，我们假定为dataSource。\n使用UnpooledDataSource的getConnection()，每调用一次就会产生一个新的Connection实例对象。\n\nUnPooledDataSource的getConnection()方法实现如下：\n\n```java\n/*\nUnpooledDataSource的getConnection()实现\n*/\npublic Connection getConnection() throws SQLException\n{\n  return doGetConnection(username, password);\n}\n\nprivate Connection doGetConnection(String username, String password) throws SQLException\n{\n  // 封装username和password成properties\n  Properties props = new Properties();\n  if (driverProperties != null)\n  {\n      props.putAll(driverProperties);\n  }\n  if (username != null)\n  {\n      props.setProperty(\"user\", username);\n  }\n  if (password != null)\n  {\n      props.setProperty(\"password\", password);\n  }\n  return doGetConnection(props);\n}\n\n/*\n *  获取数据连接\n */\nprivate Connection doGetConnection(Properties properties) throws SQLException\n{\n  // 1.初始化驱动\n  initializeDriver();\n  // 2.从DriverManager中获取连接，获取新的Connection对象\n  Connection connection = DriverManager.getConnection(url, properties);\n  // 3.配置connection属性\n  configureConnection(connection);\n  return connection;\n}\n```\n\nUnpooledDataSource会做以下几件事情：\n\n- 初始化驱动： 判断driver驱动是否已经加载到内存中，如果还没有加载，则会动态地加载driver类，并实例化一个Driver对象，使用DriverManager.registerDriver()方法将其注册到内存中，以供后续使用。\n\n- 创建Connection对象： 使用DriverManager.getConnection()方法创建连接。\n- 配置Connection对象： 设置是否自动提交autoCommit和隔离级别isolationLevel。\n- 返回Connection对象。\n\n我们每调用一次getConnection()方法，都会通过DriverManager.getConnection()返回新的java.sql.Connection实例,这样当然对于资源是一种浪费，为了防止重复的去创建和销毁连接,于是引入了连接池的概念。\n\n### 使用了连接池的 PooledDataSource\n\n要理解连接池，首先要了解它对于connection的容器，它使用PoolState容器来管理所有的conncetion。\n\n```\npublic class PooledDataSource implements DataSource {\n\n  private static final Log log = LogFactory.getLog(PooledDataSource.class);\n\n  private final PoolState state = new PoolState(this);\n\n  private final UnpooledDataSource dataSource;\n}\n```\n\n在PoolState中，它将connection分为两种状态，空闲状态（idle）和活动状态(active)，他们分别被存储到PoolState容器内的idleConnections和activeConnections两个ArrayList中。\n\n```\npublic class PoolState {\n\n  protected PooledDataSource dataSource;\n\n  protected final List<PooledConnection> idleConnections = new ArrayList<PooledConnection>();\n  \n  protected final List<PooledConnection> activeConnections = new ArrayList<PooledConnection>();\n}\n```\n\n- idleConnections：空闲(idle)状态PooledConnection对象被放置到此集合中，表示当前闲置的没有被使用的PooledConnection集合，调用PooledDataSource的getConnection()方法时，会优先从此集合中取PooledConnection对象。当用完一个java.sql.Connection对象时，MyBatis会将其包裹成PooledConnection对象放到此集合中。\n\n- activeConnections：活动(active)状态的PooledConnection对象被放置到名为activeConnections的ArrayList中，表示当前正在被使用的PooledConnection集合，调用PooledDataSource的getConnection()方法时，会优先从idleConnections集合中取PooledConnection对象，如果没有，则看活跃状态的线程集合是否已满，如果未满，PooledDataSource会创建出一个PooledConnection，添加到此集合中，并返回。\n\n#### 从连接池中获取一个连接对象的过程\n\n```java\nprivate PooledConnection popConnection(String username, String password) throws SQLException {\n    boolean countedWait = false;\n    PooledConnection conn = null;\n    long t = System.currentTimeMillis();\n    int localBadConnectionCount = 0;\n\n    while (conn == null) {\n      synchronized (state) {// 给state对象加锁\n        if (!state.idleConnections.isEmpty()) {// 如果空闲列表不空，就从空闲列表中拿connection\n          // Pool has available connection\n          conn = state.idleConnections.remove(0);// 拿出空闲列表中的第一个，去验证连接是否还有效\n          if (log.isDebugEnabled()) {\n            log.debug(\"Checked out connection \" + conn.getRealHashCode() + \" from pool.\");\n          }\n        } else {\n          // 空闲连接池中没有可用的连接，就来看看活跃连接列表中是否有，先判断活动连接总数 是否小于 最大可用的活动连接数\n          if (state.activeConnections.size() < poolMaximumActiveConnections) {\n            // 如果连接数小于list.size 直接创建新的连接。\n            conn = new PooledConnection(dataSource.getConnection(), this);\n            if (log.isDebugEnabled()) {\n              log.debug(\"Created connection \" + conn.getRealHashCode() + \".\");\n            }\n          } else {\n            // 此时连接数也满了，不能创建新的连接。找到最老的那个，检查它是否过期\n            // 计算它的校验时间，如果校验时间大于连接池规定的最大校验时间，则认为它已经过期了\n            // 利用这个PoolConnection内部的realConnection重新生成一个PooledConnection\n            PooledConnection oldestActiveConnection = state.activeConnections.get(0);\n            long longestCheckoutTime = oldestActiveConnection.getCheckoutTime();\n            if (longestCheckoutTime > poolMaximumCheckoutTime) {\n              // 可以要求过期这个连接。\n              state.claimedOverdueConnectionCount++;\n              state.accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime;\n              state.accumulatedCheckoutTime += longestCheckoutTime;\n              state.activeConnections.remove(oldestActiveConnection);\n              if (!oldestActiveConnection.getRealConnection().getAutoCommit()) {\n                try {\n                  oldestActiveConnection.getRealConnection().rollback();\n                } catch (SQLException e) {\n                  log.debug(\"Bad connection. Could not roll back\");\n                }\n              }\n              conn = new PooledConnection(oldestActiveConnection.getRealConnection(), this);\n              conn.setCreatedTimestamp(oldestActiveConnection.getCreatedTimestamp());\n              conn.setLastUsedTimestamp(oldestActiveConnection.getLastUsedTimestamp());\n              oldestActiveConnection.invalidate();\n              if (log.isDebugEnabled()) {\n                log.debug(\"Claimed overdue connection \" + conn.getRealHashCode() + \".\");\n              }\n            } else {\n              // 如果不能释放，则必须等待\n              try {\n                if (!countedWait) {\n                  state.hadToWaitCount++;\n                  countedWait = true;\n                }\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Waiting as long as \" + poolTimeToWait + \" milliseconds for connection.\");\n                }\n                long wt = System.currentTimeMillis();\n                state.wait(poolTimeToWait);\n                state.accumulatedWaitTime += System.currentTimeMillis() - wt;\n              } catch (InterruptedException e) {\n                break;\n              }\n            }\n          }\n        }\n        if (conn != null) {\n          // ping to server and check the connection is valid or not\n          if (conn.isValid()) {// 去验证连接是否还有效。\n            if (!conn.getRealConnection().getAutoCommit()) {\n              conn.getRealConnection().rollback();\n            }\n            conn.setConnectionTypeCode(assembleConnectionTypeCode(dataSource.getUrl(), username, password));\n            conn.setCheckoutTimestamp(System.currentTimeMillis());\n            conn.setLastUsedTimestamp(System.currentTimeMillis());\n            state.activeConnections.add(conn);\n            state.requestCount++;\n            state.accumulatedRequestTime += System.currentTimeMillis() - t;\n          } else {\n            if (log.isDebugEnabled()) {\n              log.debug(\"A bad connection (\" + conn.getRealHashCode() + \") was returned from the pool, getting another connection.\");\n            }\n            state.badConnectionCount++;\n            localBadConnectionCount++;\n            conn = null;\n            if (localBadConnectionCount > (poolMaximumIdleConnections + poolMaximumLocalBadConnectionTolerance)) {\n              if (log.isDebugEnabled()) {\n                log.debug(\"PooledDataSource: Could not get a good connection to the database.\");\n              }\n              throw new SQLException(\"PooledDataSource: Could not get a good connection to the database.\");\n            }\n          }\n        }\n      }\n\n    }\n\n    if (conn == null) {\n      if (log.isDebugEnabled()) {\n        log.debug(\"PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.\");\n      }\n      throw new SQLException(\"PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.\");\n    }\n\n    return conn;\n  }\n```\n\n#### 复用连接的过程\n\n```java\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n    String methodName = method.getName();\n    // 当调用关闭的时候，回收此Connection到PooledDataSource中\n    if (CLOSE.hashCode() == methodName.hashCode() && CLOSE.equals(methodName)) {\n      dataSource.pushConnection(this);\n      return null;\n    } else {\n      try {\n        if (!Object.class.equals(method.getDeclaringClass())) {\n          checkConnection();\n        }\n        return method.invoke(realConnection, args);\n      } catch (Throwable t) {\n        throw ExceptionUtil.unwrapThrowable(t);\n      }\n    }\n  }\n```\n","source":"_posts/Mybatis数据源结构解析之连接池.md","raw":"---\ntitle: MyBatis数据源结构解析之连接池\ndate: 2022-03-19 21:30:44\ntags: MyBatis\n---\n\n### 概述\n\n连接池的作用就是为了提高性能，将已经创建好的连接保存在池中，当有请求来时，直接使用已经创建好的连接对Server端进行访问。这样省略了创建连接和销毁连接的过程，从而在性能上得到了提高。\n\n连接池设计的基本原理是这样的：\n（1）建立连接池对象（服务启动）。\n（2）按照事先指定的参数创建初始数量的连接（即：空闲连接数）。\n（3）对于一个访问请求，直接从连接池中得到一个连接。如果连接池对象中没有空闲的连接，且连接数没有达到最大（即：最大活跃连接数），创建一个新的连接；如果达到最大，则设定一定的超时时间，来获取连接。\n（4）运用连接访问服务。\n（5）访问服务完成，释放连接（此时的释放连接，并非真正关闭，而是将其放入空闲队列中。如实际空闲连接数大于初始空闲连接数则释放连接）。\n\n（6）释放连接池对象（服务停止、维护期间，释放连接池对象，并释放所有连接）。\n\n### 数据源的分类\n\n打开Mybatis源码找到datasource包，可以看到3个子package\n\n- UNPOOLED 不使用连接池的数据源\n- POOLED 使用连接池的数据源\n- JNDI 使用JNDI实现的数据源\n\nMyBatis内部分别定义了实现了java.sql.DataSource接口的UnpooledDataSource，PooledDataSource类来表示UNPOOLED、POOLED类型的数据源。 如下图所示：\n\n- PooledDataSource和UnpooledDataSrouce都实现了java.sql.DataSource接口。\n- PooledDataSource持有一个UnPooledDataSource的引用，当PooledDataSource要创建Connection实例时，实际还是通过UnPooledDataSource来创建的。PooledDataSource只是提供一种缓存连接池机制。\n\nJNDI类型的数据源DataSource，则是通过JNDI上下文中取值。\n\n\n\n### 数据源DataSource的创建过程\n\n在mybatis的XML配置文件中，使用<dataSource>元素来配置数据源：\n\n```xml\n<!-- 配置数据源（连接池） -->\n<dataSource type=\"POOLED\"> //这里 type 属性的取值就是为POOLED、UNPOOLED、JNDI\n  <property name=\"driver\" value=\"${jdbc.driver}\"/>\n  <property name=\"url\" value=\"${jdbc.url}\"/>\n  <property name=\"username\" value=\"${jdbc.username}\"/>\n  <property name=\"password\" value=\"${jdbc.password}\"/>\n</dataSource>\n```\n\nMyBatis在初始化时，解析此文件，根据<dataSource>的type属性来创建相应类型的的数据源DataSource，即：\n\n- type=”POOLED” ：创建PooledDataSource实例。\n- type=”UNPOOLED” ：创建UnpooledDataSource实例。\n- type=”JNDI” ：从JNDI服务上查找DataSource实例。\n\n\n\nMybatis是通过工厂模式来创建数据源对象的 我们来看看源码:\n\n```java\npublic interface DataSourceFactory {\n\nvoid setProperties(Properties props);\n\nDataSource getDataSource();//生产DataSource\n\n}\n```\n\n上述3种类型的数据源，对应有自己的工厂模式,都实现了这个DataSourceFactory。\n\nMyBatis创建了DataSource实例后，会将其放到Configuration对象内的Environment对象中， 供以后使用。\n\n注意dataSource 此时只会保存好配置信息，连接池此时并没有创建好连接。只有当程序在调用操作数据库的方法时，才会初始化连接。\n\n### DataSource什么时候创建Connection对象\n我们需要创建SqlSession对象并需要执行SQL语句时，这时候MyBatis才会去调用dataSource对象来创建java.sql.Connection对象。也就是说，java.sql.Connection对象的创建一直延迟到执行SQL语句的时候。\n\n```\n  @Test\n  public void testMyBatisBuild() throws IOException {\n      Reader reader = Resources.getResourceAsReader(\"mybatis-config.xml\");\n      SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader);\n      SqlSession sqlSession = factory.openSession();\n      TestMapper mapper = sqlSession.getMapper(TestMapper.class);\n      Ttest one = mapper.getOne(1L);// 直到这一行，才会去创建一个数据库连接\n      System.out.println(one);\n      sqlSession.close();\n  }\n```\n\n### 验证Connection创建时机\n\n首先我们先查出现在数据库的所有连接数，在数据库中执行\n\n```sql\nmysql> SELECT * FROM performance_schema.hosts;\n+-----------+---------------------+-------------------+\n| HOST      | CURRENT_CONNECTIONS | TOTAL_CONNECTIONS |\n+-----------+---------------------+-------------------+\n| NULL      |                  36 |                50 |\n| localhost |                   2 |                 5 |\n+-----------+---------------------+-------------------+\n2 rows in set (0.00 sec)\n```\n显示所有的任务列表\n\n```sql\n\nmysql>  show full processlist;\n+----+-----------------+-----------+---------+---------+--------+------------------------+-----------------------+\n| Id | User            | Host      | db      | Command | Time   | State                  | Info                  |\n+----+-----------------+-----------+---------+---------+--------+------------------------+-----------------------+\n|  5 | event_scheduler | localhost | NULL    | Daemon  | 883049 | Waiting on empty queue | NULL                  |\n| 15 | root            | localhost | kangpan | Query   |      0 | init                   | show full processlist |\n+----+-----------------+-----------+---------+---------+--------+------------------------+-----------------------+\n2 rows in set (0.01 sec)\n```\n\ndataSource.getConnection()执行完，至此一个connection才创建完成。我们验证一下 在dataSource.getConnection()时打一下断点。按F8 执行一步在控制台可以看到connection = com.mysql.jdbc.JDBC4Connection@1500b2f3 实例创建完毕，我们再去数据库中看看连接数加一。\n\n```java\n  protected void openConnection() throws SQLException {\n  if (log.isDebugEnabled()) {\n    log.debug(\"Opening JDBC Connection\");\n  }\n  connection = dataSource.getConnection();// 最终获取连接的地方在这句.\n  if (level != null) {\n    connection.setTransactionIsolation(level.getLevel());// 设置隔离等级\n  }\n  setDesiredAutoCommit(autoCommit);// 是否自动提交，默认false,update不会提交到数据库，需要手动commit\n}\n```\n\n### 不使用连接池的 UnpooledDataSource\n\n当 <dataSource>的type属性被配置成了”UNPOOLED”，MyBatis首先会实例化一个UnpooledDataSourceFactory工厂实例，然后通过.getDataSource()方法返回一个UnpooledDataSource实例对象引用，我们假定为dataSource。\n使用UnpooledDataSource的getConnection()，每调用一次就会产生一个新的Connection实例对象。\n\nUnPooledDataSource的getConnection()方法实现如下：\n\n```java\n/*\nUnpooledDataSource的getConnection()实现\n*/\npublic Connection getConnection() throws SQLException\n{\n  return doGetConnection(username, password);\n}\n\nprivate Connection doGetConnection(String username, String password) throws SQLException\n{\n  // 封装username和password成properties\n  Properties props = new Properties();\n  if (driverProperties != null)\n  {\n      props.putAll(driverProperties);\n  }\n  if (username != null)\n  {\n      props.setProperty(\"user\", username);\n  }\n  if (password != null)\n  {\n      props.setProperty(\"password\", password);\n  }\n  return doGetConnection(props);\n}\n\n/*\n *  获取数据连接\n */\nprivate Connection doGetConnection(Properties properties) throws SQLException\n{\n  // 1.初始化驱动\n  initializeDriver();\n  // 2.从DriverManager中获取连接，获取新的Connection对象\n  Connection connection = DriverManager.getConnection(url, properties);\n  // 3.配置connection属性\n  configureConnection(connection);\n  return connection;\n}\n```\n\nUnpooledDataSource会做以下几件事情：\n\n- 初始化驱动： 判断driver驱动是否已经加载到内存中，如果还没有加载，则会动态地加载driver类，并实例化一个Driver对象，使用DriverManager.registerDriver()方法将其注册到内存中，以供后续使用。\n\n- 创建Connection对象： 使用DriverManager.getConnection()方法创建连接。\n- 配置Connection对象： 设置是否自动提交autoCommit和隔离级别isolationLevel。\n- 返回Connection对象。\n\n我们每调用一次getConnection()方法，都会通过DriverManager.getConnection()返回新的java.sql.Connection实例,这样当然对于资源是一种浪费，为了防止重复的去创建和销毁连接,于是引入了连接池的概念。\n\n### 使用了连接池的 PooledDataSource\n\n要理解连接池，首先要了解它对于connection的容器，它使用PoolState容器来管理所有的conncetion。\n\n```\npublic class PooledDataSource implements DataSource {\n\n  private static final Log log = LogFactory.getLog(PooledDataSource.class);\n\n  private final PoolState state = new PoolState(this);\n\n  private final UnpooledDataSource dataSource;\n}\n```\n\n在PoolState中，它将connection分为两种状态，空闲状态（idle）和活动状态(active)，他们分别被存储到PoolState容器内的idleConnections和activeConnections两个ArrayList中。\n\n```\npublic class PoolState {\n\n  protected PooledDataSource dataSource;\n\n  protected final List<PooledConnection> idleConnections = new ArrayList<PooledConnection>();\n  \n  protected final List<PooledConnection> activeConnections = new ArrayList<PooledConnection>();\n}\n```\n\n- idleConnections：空闲(idle)状态PooledConnection对象被放置到此集合中，表示当前闲置的没有被使用的PooledConnection集合，调用PooledDataSource的getConnection()方法时，会优先从此集合中取PooledConnection对象。当用完一个java.sql.Connection对象时，MyBatis会将其包裹成PooledConnection对象放到此集合中。\n\n- activeConnections：活动(active)状态的PooledConnection对象被放置到名为activeConnections的ArrayList中，表示当前正在被使用的PooledConnection集合，调用PooledDataSource的getConnection()方法时，会优先从idleConnections集合中取PooledConnection对象，如果没有，则看活跃状态的线程集合是否已满，如果未满，PooledDataSource会创建出一个PooledConnection，添加到此集合中，并返回。\n\n#### 从连接池中获取一个连接对象的过程\n\n```java\nprivate PooledConnection popConnection(String username, String password) throws SQLException {\n    boolean countedWait = false;\n    PooledConnection conn = null;\n    long t = System.currentTimeMillis();\n    int localBadConnectionCount = 0;\n\n    while (conn == null) {\n      synchronized (state) {// 给state对象加锁\n        if (!state.idleConnections.isEmpty()) {// 如果空闲列表不空，就从空闲列表中拿connection\n          // Pool has available connection\n          conn = state.idleConnections.remove(0);// 拿出空闲列表中的第一个，去验证连接是否还有效\n          if (log.isDebugEnabled()) {\n            log.debug(\"Checked out connection \" + conn.getRealHashCode() + \" from pool.\");\n          }\n        } else {\n          // 空闲连接池中没有可用的连接，就来看看活跃连接列表中是否有，先判断活动连接总数 是否小于 最大可用的活动连接数\n          if (state.activeConnections.size() < poolMaximumActiveConnections) {\n            // 如果连接数小于list.size 直接创建新的连接。\n            conn = new PooledConnection(dataSource.getConnection(), this);\n            if (log.isDebugEnabled()) {\n              log.debug(\"Created connection \" + conn.getRealHashCode() + \".\");\n            }\n          } else {\n            // 此时连接数也满了，不能创建新的连接。找到最老的那个，检查它是否过期\n            // 计算它的校验时间，如果校验时间大于连接池规定的最大校验时间，则认为它已经过期了\n            // 利用这个PoolConnection内部的realConnection重新生成一个PooledConnection\n            PooledConnection oldestActiveConnection = state.activeConnections.get(0);\n            long longestCheckoutTime = oldestActiveConnection.getCheckoutTime();\n            if (longestCheckoutTime > poolMaximumCheckoutTime) {\n              // 可以要求过期这个连接。\n              state.claimedOverdueConnectionCount++;\n              state.accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime;\n              state.accumulatedCheckoutTime += longestCheckoutTime;\n              state.activeConnections.remove(oldestActiveConnection);\n              if (!oldestActiveConnection.getRealConnection().getAutoCommit()) {\n                try {\n                  oldestActiveConnection.getRealConnection().rollback();\n                } catch (SQLException e) {\n                  log.debug(\"Bad connection. Could not roll back\");\n                }\n              }\n              conn = new PooledConnection(oldestActiveConnection.getRealConnection(), this);\n              conn.setCreatedTimestamp(oldestActiveConnection.getCreatedTimestamp());\n              conn.setLastUsedTimestamp(oldestActiveConnection.getLastUsedTimestamp());\n              oldestActiveConnection.invalidate();\n              if (log.isDebugEnabled()) {\n                log.debug(\"Claimed overdue connection \" + conn.getRealHashCode() + \".\");\n              }\n            } else {\n              // 如果不能释放，则必须等待\n              try {\n                if (!countedWait) {\n                  state.hadToWaitCount++;\n                  countedWait = true;\n                }\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Waiting as long as \" + poolTimeToWait + \" milliseconds for connection.\");\n                }\n                long wt = System.currentTimeMillis();\n                state.wait(poolTimeToWait);\n                state.accumulatedWaitTime += System.currentTimeMillis() - wt;\n              } catch (InterruptedException e) {\n                break;\n              }\n            }\n          }\n        }\n        if (conn != null) {\n          // ping to server and check the connection is valid or not\n          if (conn.isValid()) {// 去验证连接是否还有效。\n            if (!conn.getRealConnection().getAutoCommit()) {\n              conn.getRealConnection().rollback();\n            }\n            conn.setConnectionTypeCode(assembleConnectionTypeCode(dataSource.getUrl(), username, password));\n            conn.setCheckoutTimestamp(System.currentTimeMillis());\n            conn.setLastUsedTimestamp(System.currentTimeMillis());\n            state.activeConnections.add(conn);\n            state.requestCount++;\n            state.accumulatedRequestTime += System.currentTimeMillis() - t;\n          } else {\n            if (log.isDebugEnabled()) {\n              log.debug(\"A bad connection (\" + conn.getRealHashCode() + \") was returned from the pool, getting another connection.\");\n            }\n            state.badConnectionCount++;\n            localBadConnectionCount++;\n            conn = null;\n            if (localBadConnectionCount > (poolMaximumIdleConnections + poolMaximumLocalBadConnectionTolerance)) {\n              if (log.isDebugEnabled()) {\n                log.debug(\"PooledDataSource: Could not get a good connection to the database.\");\n              }\n              throw new SQLException(\"PooledDataSource: Could not get a good connection to the database.\");\n            }\n          }\n        }\n      }\n\n    }\n\n    if (conn == null) {\n      if (log.isDebugEnabled()) {\n        log.debug(\"PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.\");\n      }\n      throw new SQLException(\"PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.\");\n    }\n\n    return conn;\n  }\n```\n\n#### 复用连接的过程\n\n```java\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n    String methodName = method.getName();\n    // 当调用关闭的时候，回收此Connection到PooledDataSource中\n    if (CLOSE.hashCode() == methodName.hashCode() && CLOSE.equals(methodName)) {\n      dataSource.pushConnection(this);\n      return null;\n    } else {\n      try {\n        if (!Object.class.equals(method.getDeclaringClass())) {\n          checkConnection();\n        }\n        return method.invoke(realConnection, args);\n      } catch (Throwable t) {\n        throw ExceptionUtil.unwrapThrowable(t);\n      }\n    }\n  }\n```\n","slug":"Mybatis数据源结构解析之连接池","published":1,"updated":"2022-03-19T14:25:34.359Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0xy078r0000e8ln5kyg22c7","content":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>连接池的作用就是为了提高性能，将已经创建好的连接保存在池中，当有请求来时，直接使用已经创建好的连接对Server端进行访问。这样省略了创建连接和销毁连接的过程，从而在性能上得到了提高。</p>\n<p>连接池设计的基本原理是这样的：<br>（1）建立连接池对象（服务启动）。<br>（2）按照事先指定的参数创建初始数量的连接（即：空闲连接数）。<br>（3）对于一个访问请求，直接从连接池中得到一个连接。如果连接池对象中没有空闲的连接，且连接数没有达到最大（即：最大活跃连接数），创建一个新的连接；如果达到最大，则设定一定的超时时间，来获取连接。<br>（4）运用连接访问服务。<br>（5）访问服务完成，释放连接（此时的释放连接，并非真正关闭，而是将其放入空闲队列中。如实际空闲连接数大于初始空闲连接数则释放连接）。</p>\n<p>（6）释放连接池对象（服务停止、维护期间，释放连接池对象，并释放所有连接）。</p>\n<h3 id=\"数据源的分类\"><a href=\"#数据源的分类\" class=\"headerlink\" title=\"数据源的分类\"></a>数据源的分类</h3><p>打开Mybatis源码找到datasource包，可以看到3个子package</p>\n<ul>\n<li>UNPOOLED 不使用连接池的数据源</li>\n<li>POOLED 使用连接池的数据源</li>\n<li>JNDI 使用JNDI实现的数据源</li>\n</ul>\n<p>MyBatis内部分别定义了实现了java.sql.DataSource接口的UnpooledDataSource，PooledDataSource类来表示UNPOOLED、POOLED类型的数据源。 如下图所示：</p>\n<ul>\n<li>PooledDataSource和UnpooledDataSrouce都实现了java.sql.DataSource接口。</li>\n<li>PooledDataSource持有一个UnPooledDataSource的引用，当PooledDataSource要创建Connection实例时，实际还是通过UnPooledDataSource来创建的。PooledDataSource只是提供一种缓存连接池机制。</li>\n</ul>\n<p>JNDI类型的数据源DataSource，则是通过JNDI上下文中取值。</p>\n<h3 id=\"数据源DataSource的创建过程\"><a href=\"#数据源DataSource的创建过程\" class=\"headerlink\" title=\"数据源DataSource的创建过程\"></a>数据源DataSource的创建过程</h3><p>在mybatis的XML配置文件中，使用<dataSource>元素来配置数据源：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 配置数据源（连接池） --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dataSource</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;POOLED&quot;</span>&gt;</span> //这里 type 属性的取值就是为POOLED、UNPOOLED、JNDI</span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;driver&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;url&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>MyBatis在初始化时，解析此文件，根据<dataSource>的type属性来创建相应类型的的数据源DataSource，即：</p>\n<ul>\n<li>type=”POOLED” ：创建PooledDataSource实例。</li>\n<li>type=”UNPOOLED” ：创建UnpooledDataSource实例。</li>\n<li>type=”JNDI” ：从JNDI服务上查找DataSource实例。</li>\n</ul>\n<p>Mybatis是通过工厂模式来创建数据源对象的 我们来看看源码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">DataSourceFactory</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">setProperties</span><span class=\"params\">(Properties props)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">DataSource <span class=\"title function_\">getDataSource</span><span class=\"params\">()</span>;<span class=\"comment\">//生产DataSource</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述3种类型的数据源，对应有自己的工厂模式,都实现了这个DataSourceFactory。</p>\n<p>MyBatis创建了DataSource实例后，会将其放到Configuration对象内的Environment对象中， 供以后使用。</p>\n<p>注意dataSource 此时只会保存好配置信息，连接池此时并没有创建好连接。只有当程序在调用操作数据库的方法时，才会初始化连接。</p>\n<h3 id=\"DataSource什么时候创建Connection对象\"><a href=\"#DataSource什么时候创建Connection对象\" class=\"headerlink\" title=\"DataSource什么时候创建Connection对象\"></a>DataSource什么时候创建Connection对象</h3><p>我们需要创建SqlSession对象并需要执行SQL语句时，这时候MyBatis才会去调用dataSource对象来创建java.sql.Connection对象。也就是说，java.sql.Connection对象的创建一直延迟到执行SQL语句的时候。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void testMyBatisBuild() throws IOException &#123;</span><br><span class=\"line\">    Reader reader = Resources.getResourceAsReader(&quot;mybatis-config.xml&quot;);</span><br><span class=\"line\">    SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader);</span><br><span class=\"line\">    SqlSession sqlSession = factory.openSession();</span><br><span class=\"line\">    TestMapper mapper = sqlSession.getMapper(TestMapper.class);</span><br><span class=\"line\">    Ttest one = mapper.getOne(1L);// 直到这一行，才会去创建一个数据库连接</span><br><span class=\"line\">    System.out.println(one);</span><br><span class=\"line\">    sqlSession.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"验证Connection创建时机\"><a href=\"#验证Connection创建时机\" class=\"headerlink\" title=\"验证Connection创建时机\"></a>验证Connection创建时机</h3><p>首先我们先查出现在数据库的所有连接数，在数据库中执行</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> performance_schema.hosts;</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">-----------+---------------------+-------------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> HOST      <span class=\"operator\">|</span> CURRENT_CONNECTIONS <span class=\"operator\">|</span> TOTAL_CONNECTIONS <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">-----------+---------------------+-------------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"keyword\">NULL</span>      <span class=\"operator\">|</span>                  <span class=\"number\">36</span> <span class=\"operator\">|</span>                <span class=\"number\">50</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> localhost <span class=\"operator\">|</span>                   <span class=\"number\">2</span> <span class=\"operator\">|</span>                 <span class=\"number\">5</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">-----------+---------------------+-------------------+</span></span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n<p>显示所有的任务列表</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span>  <span class=\"keyword\">show</span> <span class=\"keyword\">full</span> processlist;</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">----+-----------------+-----------+---------+---------+--------+------------------------+-----------------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> Id <span class=\"operator\">|</span> <span class=\"keyword\">User</span>            <span class=\"operator\">|</span> Host      <span class=\"operator\">|</span> db      <span class=\"operator\">|</span> Command <span class=\"operator\">|</span> <span class=\"type\">Time</span>   <span class=\"operator\">|</span> State                  <span class=\"operator\">|</span> Info                  <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">----+-----------------+-----------+---------+---------+--------+------------------------+-----------------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span>  <span class=\"number\">5</span> <span class=\"operator\">|</span> event_scheduler <span class=\"operator\">|</span> localhost <span class=\"operator\">|</span> <span class=\"keyword\">NULL</span>    <span class=\"operator\">|</span> Daemon  <span class=\"operator\">|</span> <span class=\"number\">883049</span> <span class=\"operator\">|</span> Waiting <span class=\"keyword\">on</span> <span class=\"keyword\">empty</span> queue <span class=\"operator\">|</span> <span class=\"keyword\">NULL</span>                  <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"number\">15</span> <span class=\"operator\">|</span> root            <span class=\"operator\">|</span> localhost <span class=\"operator\">|</span> kangpan <span class=\"operator\">|</span> Query   <span class=\"operator\">|</span>      <span class=\"number\">0</span> <span class=\"operator\">|</span> init                   <span class=\"operator\">|</span> <span class=\"keyword\">show</span> <span class=\"keyword\">full</span> processlist <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">----+-----------------+-----------+---------+---------+--------+------------------------+-----------------------+</span></span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.01</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p>dataSource.getConnection()执行完，至此一个connection才创建完成。我们验证一下 在dataSource.getConnection()时打一下断点。按F8 执行一步在控制台可以看到connection = com.mysql.jdbc.JDBC4Connection@1500b2f3 实例创建完毕，我们再去数据库中看看连接数加一。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">openConnection</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (log.isDebugEnabled()) &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;Opening JDBC Connection&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  connection = dataSource.getConnection();<span class=\"comment\">// 最终获取连接的地方在这句.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (level != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    connection.setTransactionIsolation(level.getLevel());<span class=\"comment\">// 设置隔离等级</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  setDesiredAutoCommit(autoCommit);<span class=\"comment\">// 是否自动提交，默认false,update不会提交到数据库，需要手动commit</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"不使用连接池的-UnpooledDataSource\"><a href=\"#不使用连接池的-UnpooledDataSource\" class=\"headerlink\" title=\"不使用连接池的 UnpooledDataSource\"></a>不使用连接池的 UnpooledDataSource</h3><p>当 <dataSource>的type属性被配置成了”UNPOOLED”，MyBatis首先会实例化一个UnpooledDataSourceFactory工厂实例，然后通过.getDataSource()方法返回一个UnpooledDataSource实例对象引用，我们假定为dataSource。<br>使用UnpooledDataSource的getConnection()，每调用一次就会产生一个新的Connection实例对象。</p>\n<p>UnPooledDataSource的getConnection()方法实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">UnpooledDataSource的getConnection()实现</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Connection <span class=\"title function_\">getConnection</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> doGetConnection(username, password);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> Connection <span class=\"title function_\">doGetConnection</span><span class=\"params\">(String username, String password)</span> <span class=\"keyword\">throws</span> SQLException</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 封装username和password成properties</span></span><br><span class=\"line\">  <span class=\"type\">Properties</span> <span class=\"variable\">props</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Properties</span>();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (driverProperties != <span class=\"literal\">null</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      props.putAll(driverProperties);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (username != <span class=\"literal\">null</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      props.setProperty(<span class=\"string\">&quot;user&quot;</span>, username);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (password != <span class=\"literal\">null</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      props.setProperty(<span class=\"string\">&quot;password&quot;</span>, password);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> doGetConnection(props);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *  获取数据连接</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Connection <span class=\"title function_\">doGetConnection</span><span class=\"params\">(Properties properties)</span> <span class=\"keyword\">throws</span> SQLException</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1.初始化驱动</span></span><br><span class=\"line\">  initializeDriver();</span><br><span class=\"line\">  <span class=\"comment\">// 2.从DriverManager中获取连接，获取新的Connection对象</span></span><br><span class=\"line\">  <span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> DriverManager.getConnection(url, properties);</span><br><span class=\"line\">  <span class=\"comment\">// 3.配置connection属性</span></span><br><span class=\"line\">  configureConnection(connection);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> connection;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>UnpooledDataSource会做以下几件事情：</p>\n<ul>\n<li><p>初始化驱动： 判断driver驱动是否已经加载到内存中，如果还没有加载，则会动态地加载driver类，并实例化一个Driver对象，使用DriverManager.registerDriver()方法将其注册到内存中，以供后续使用。</p>\n</li>\n<li><p>创建Connection对象： 使用DriverManager.getConnection()方法创建连接。</p>\n</li>\n<li><p>配置Connection对象： 设置是否自动提交autoCommit和隔离级别isolationLevel。</p>\n</li>\n<li><p>返回Connection对象。</p>\n</li>\n</ul>\n<p>我们每调用一次getConnection()方法，都会通过DriverManager.getConnection()返回新的java.sql.Connection实例,这样当然对于资源是一种浪费，为了防止重复的去创建和销毁连接,于是引入了连接池的概念。</p>\n<h3 id=\"使用了连接池的-PooledDataSource\"><a href=\"#使用了连接池的-PooledDataSource\" class=\"headerlink\" title=\"使用了连接池的 PooledDataSource\"></a>使用了连接池的 PooledDataSource</h3><p>要理解连接池，首先要了解它对于connection的容器，它使用PoolState容器来管理所有的conncetion。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PooledDataSource implements DataSource &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  private static final Log log = LogFactory.getLog(PooledDataSource.class);</span><br><span class=\"line\"></span><br><span class=\"line\">  private final PoolState state = new PoolState(this);</span><br><span class=\"line\"></span><br><span class=\"line\">  private final UnpooledDataSource dataSource;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在PoolState中，它将connection分为两种状态，空闲状态（idle）和活动状态(active)，他们分别被存储到PoolState容器内的idleConnections和activeConnections两个ArrayList中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PoolState &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  protected PooledDataSource dataSource;</span><br><span class=\"line\"></span><br><span class=\"line\">  protected final List&lt;PooledConnection&gt; idleConnections = new ArrayList&lt;PooledConnection&gt;();</span><br><span class=\"line\">  </span><br><span class=\"line\">  protected final List&lt;PooledConnection&gt; activeConnections = new ArrayList&lt;PooledConnection&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>idleConnections：空闲(idle)状态PooledConnection对象被放置到此集合中，表示当前闲置的没有被使用的PooledConnection集合，调用PooledDataSource的getConnection()方法时，会优先从此集合中取PooledConnection对象。当用完一个java.sql.Connection对象时，MyBatis会将其包裹成PooledConnection对象放到此集合中。</p>\n</li>\n<li><p>activeConnections：活动(active)状态的PooledConnection对象被放置到名为activeConnections的ArrayList中，表示当前正在被使用的PooledConnection集合，调用PooledDataSource的getConnection()方法时，会优先从idleConnections集合中取PooledConnection对象，如果没有，则看活跃状态的线程集合是否已满，如果未满，PooledDataSource会创建出一个PooledConnection，添加到此集合中，并返回。</p>\n</li>\n</ul>\n<h4 id=\"从连接池中获取一个连接对象的过程\"><a href=\"#从连接池中获取一个连接对象的过程\" class=\"headerlink\" title=\"从连接池中获取一个连接对象的过程\"></a>从连接池中获取一个连接对象的过程</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> PooledConnection <span class=\"title function_\">popConnection</span><span class=\"params\">(String username, String password)</span> <span class=\"keyword\">throws</span> SQLException &#123;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">countedWait</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"type\">PooledConnection</span> <span class=\"variable\">conn</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">localBadConnectionCount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (conn == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (state) &#123;<span class=\"comment\">// 给state对象加锁</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!state.idleConnections.isEmpty()) &#123;<span class=\"comment\">// 如果空闲列表不空，就从空闲列表中拿connection</span></span><br><span class=\"line\">          <span class=\"comment\">// Pool has available connection</span></span><br><span class=\"line\">          conn = state.idleConnections.remove(<span class=\"number\">0</span>);<span class=\"comment\">// 拿出空闲列表中的第一个，去验证连接是否还有效</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (log.isDebugEnabled()) &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;Checked out connection &quot;</span> + conn.getRealHashCode() + <span class=\"string\">&quot; from pool.&quot;</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 空闲连接池中没有可用的连接，就来看看活跃连接列表中是否有，先判断活动连接总数 是否小于 最大可用的活动连接数</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (state.activeConnections.size() &lt; poolMaximumActiveConnections) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果连接数小于list.size 直接创建新的连接。</span></span><br><span class=\"line\">            conn = <span class=\"keyword\">new</span> <span class=\"title class_\">PooledConnection</span>(dataSource.getConnection(), <span class=\"built_in\">this</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (log.isDebugEnabled()) &#123;</span><br><span class=\"line\">              log.debug(<span class=\"string\">&quot;Created connection &quot;</span> + conn.getRealHashCode() + <span class=\"string\">&quot;.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 此时连接数也满了，不能创建新的连接。找到最老的那个，检查它是否过期</span></span><br><span class=\"line\">            <span class=\"comment\">// 计算它的校验时间，如果校验时间大于连接池规定的最大校验时间，则认为它已经过期了</span></span><br><span class=\"line\">            <span class=\"comment\">// 利用这个PoolConnection内部的realConnection重新生成一个PooledConnection</span></span><br><span class=\"line\">            <span class=\"type\">PooledConnection</span> <span class=\"variable\">oldestActiveConnection</span> <span class=\"operator\">=</span> state.activeConnections.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">longestCheckoutTime</span> <span class=\"operator\">=</span> oldestActiveConnection.getCheckoutTime();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (longestCheckoutTime &gt; poolMaximumCheckoutTime) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 可以要求过期这个连接。</span></span><br><span class=\"line\">              state.claimedOverdueConnectionCount++;</span><br><span class=\"line\">              state.accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime;</span><br><span class=\"line\">              state.accumulatedCheckoutTime += longestCheckoutTime;</span><br><span class=\"line\">              state.activeConnections.remove(oldestActiveConnection);</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!oldestActiveConnection.getRealConnection().getAutoCommit()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                  oldestActiveConnection.getRealConnection().rollback();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (SQLException e) &#123;</span><br><span class=\"line\">                  log.debug(<span class=\"string\">&quot;Bad connection. Could not roll back&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              conn = <span class=\"keyword\">new</span> <span class=\"title class_\">PooledConnection</span>(oldestActiveConnection.getRealConnection(), <span class=\"built_in\">this</span>);</span><br><span class=\"line\">              conn.setCreatedTimestamp(oldestActiveConnection.getCreatedTimestamp());</span><br><span class=\"line\">              conn.setLastUsedTimestamp(oldestActiveConnection.getLastUsedTimestamp());</span><br><span class=\"line\">              oldestActiveConnection.invalidate();</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (log.isDebugEnabled()) &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;Claimed overdue connection &quot;</span> + conn.getRealHashCode() + <span class=\"string\">&quot;.&quot;</span>);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 如果不能释放，则必须等待</span></span><br><span class=\"line\">              <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!countedWait) &#123;</span><br><span class=\"line\">                  state.hadToWaitCount++;</span><br><span class=\"line\">                  countedWait = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (log.isDebugEnabled()) &#123;</span><br><span class=\"line\">                  log.debug(<span class=\"string\">&quot;Waiting as long as &quot;</span> + poolTimeToWait + <span class=\"string\">&quot; milliseconds for connection.&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"type\">long</span> <span class=\"variable\">wt</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">                state.wait(poolTimeToWait);</span><br><span class=\"line\">                state.accumulatedWaitTime += System.currentTimeMillis() - wt;</span><br><span class=\"line\">              &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (conn != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// ping to server and check the connection is valid or not</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (conn.isValid()) &#123;<span class=\"comment\">// 去验证连接是否还有效。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class=\"line\">              conn.getRealConnection().rollback();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            conn.setConnectionTypeCode(assembleConnectionTypeCode(dataSource.getUrl(), username, password));</span><br><span class=\"line\">            conn.setCheckoutTimestamp(System.currentTimeMillis());</span><br><span class=\"line\">            conn.setLastUsedTimestamp(System.currentTimeMillis());</span><br><span class=\"line\">            state.activeConnections.add(conn);</span><br><span class=\"line\">            state.requestCount++;</span><br><span class=\"line\">            state.accumulatedRequestTime += System.currentTimeMillis() - t;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (log.isDebugEnabled()) &#123;</span><br><span class=\"line\">              log.debug(<span class=\"string\">&quot;A bad connection (&quot;</span> + conn.getRealHashCode() + <span class=\"string\">&quot;) was returned from the pool, getting another connection.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            state.badConnectionCount++;</span><br><span class=\"line\">            localBadConnectionCount++;</span><br><span class=\"line\">            conn = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (localBadConnectionCount &gt; (poolMaximumIdleConnections + poolMaximumLocalBadConnectionTolerance)) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (log.isDebugEnabled()) &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;PooledDataSource: Could not get a good connection to the database.&quot;</span>);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SQLException</span>(<span class=\"string\">&quot;PooledDataSource: Could not get a good connection to the database.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (conn == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (log.isDebugEnabled()) &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SQLException</span>(<span class=\"string\">&quot;PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> conn;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"复用连接的过程\"><a href=\"#复用连接的过程\" class=\"headerlink\" title=\"复用连接的过程\"></a>复用连接的过程</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">methodName</span> <span class=\"operator\">=</span> method.getName();</span><br><span class=\"line\">    <span class=\"comment\">// 当调用关闭的时候，回收此Connection到PooledDataSource中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (CLOSE.hashCode() == methodName.hashCode() &amp;&amp; CLOSE.equals(methodName)) &#123;</span><br><span class=\"line\">      dataSource.pushConnection(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class=\"line\">          checkConnection();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> method.invoke(realConnection, args);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>连接池的作用就是为了提高性能，将已经创建好的连接保存在池中，当有请求来时，直接使用已经创建好的连接对Server端进行访问。这样省略了创建连接和销毁连接的过程，从而在性能上得到了提高。</p>\n<p>连接池设计的基本原理是这样的：<br>（1）建立连接池对象（服务启动）。<br>（2）按照事先指定的参数创建初始数量的连接（即：空闲连接数）。<br>（3）对于一个访问请求，直接从连接池中得到一个连接。如果连接池对象中没有空闲的连接，且连接数没有达到最大（即：最大活跃连接数），创建一个新的连接；如果达到最大，则设定一定的超时时间，来获取连接。<br>（4）运用连接访问服务。<br>（5）访问服务完成，释放连接（此时的释放连接，并非真正关闭，而是将其放入空闲队列中。如实际空闲连接数大于初始空闲连接数则释放连接）。</p>\n<p>（6）释放连接池对象（服务停止、维护期间，释放连接池对象，并释放所有连接）。</p>\n<h3 id=\"数据源的分类\"><a href=\"#数据源的分类\" class=\"headerlink\" title=\"数据源的分类\"></a>数据源的分类</h3><p>打开Mybatis源码找到datasource包，可以看到3个子package</p>\n<ul>\n<li>UNPOOLED 不使用连接池的数据源</li>\n<li>POOLED 使用连接池的数据源</li>\n<li>JNDI 使用JNDI实现的数据源</li>\n</ul>\n<p>MyBatis内部分别定义了实现了java.sql.DataSource接口的UnpooledDataSource，PooledDataSource类来表示UNPOOLED、POOLED类型的数据源。 如下图所示：</p>\n<ul>\n<li>PooledDataSource和UnpooledDataSrouce都实现了java.sql.DataSource接口。</li>\n<li>PooledDataSource持有一个UnPooledDataSource的引用，当PooledDataSource要创建Connection实例时，实际还是通过UnPooledDataSource来创建的。PooledDataSource只是提供一种缓存连接池机制。</li>\n</ul>\n<p>JNDI类型的数据源DataSource，则是通过JNDI上下文中取值。</p>\n<h3 id=\"数据源DataSource的创建过程\"><a href=\"#数据源DataSource的创建过程\" class=\"headerlink\" title=\"数据源DataSource的创建过程\"></a>数据源DataSource的创建过程</h3><p>在mybatis的XML配置文件中，使用<dataSource>元素来配置数据源：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 配置数据源（连接池） --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dataSource</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;POOLED&quot;</span>&gt;</span> //这里 type 属性的取值就是为POOLED、UNPOOLED、JNDI</span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;driver&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;url&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>MyBatis在初始化时，解析此文件，根据<dataSource>的type属性来创建相应类型的的数据源DataSource，即：</p>\n<ul>\n<li>type=”POOLED” ：创建PooledDataSource实例。</li>\n<li>type=”UNPOOLED” ：创建UnpooledDataSource实例。</li>\n<li>type=”JNDI” ：从JNDI服务上查找DataSource实例。</li>\n</ul>\n<p>Mybatis是通过工厂模式来创建数据源对象的 我们来看看源码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">DataSourceFactory</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">setProperties</span><span class=\"params\">(Properties props)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">DataSource <span class=\"title function_\">getDataSource</span><span class=\"params\">()</span>;<span class=\"comment\">//生产DataSource</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述3种类型的数据源，对应有自己的工厂模式,都实现了这个DataSourceFactory。</p>\n<p>MyBatis创建了DataSource实例后，会将其放到Configuration对象内的Environment对象中， 供以后使用。</p>\n<p>注意dataSource 此时只会保存好配置信息，连接池此时并没有创建好连接。只有当程序在调用操作数据库的方法时，才会初始化连接。</p>\n<h3 id=\"DataSource什么时候创建Connection对象\"><a href=\"#DataSource什么时候创建Connection对象\" class=\"headerlink\" title=\"DataSource什么时候创建Connection对象\"></a>DataSource什么时候创建Connection对象</h3><p>我们需要创建SqlSession对象并需要执行SQL语句时，这时候MyBatis才会去调用dataSource对象来创建java.sql.Connection对象。也就是说，java.sql.Connection对象的创建一直延迟到执行SQL语句的时候。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void testMyBatisBuild() throws IOException &#123;</span><br><span class=\"line\">    Reader reader = Resources.getResourceAsReader(&quot;mybatis-config.xml&quot;);</span><br><span class=\"line\">    SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader);</span><br><span class=\"line\">    SqlSession sqlSession = factory.openSession();</span><br><span class=\"line\">    TestMapper mapper = sqlSession.getMapper(TestMapper.class);</span><br><span class=\"line\">    Ttest one = mapper.getOne(1L);// 直到这一行，才会去创建一个数据库连接</span><br><span class=\"line\">    System.out.println(one);</span><br><span class=\"line\">    sqlSession.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"验证Connection创建时机\"><a href=\"#验证Connection创建时机\" class=\"headerlink\" title=\"验证Connection创建时机\"></a>验证Connection创建时机</h3><p>首先我们先查出现在数据库的所有连接数，在数据库中执行</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> performance_schema.hosts;</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">-----------+---------------------+-------------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> HOST      <span class=\"operator\">|</span> CURRENT_CONNECTIONS <span class=\"operator\">|</span> TOTAL_CONNECTIONS <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">-----------+---------------------+-------------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"keyword\">NULL</span>      <span class=\"operator\">|</span>                  <span class=\"number\">36</span> <span class=\"operator\">|</span>                <span class=\"number\">50</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> localhost <span class=\"operator\">|</span>                   <span class=\"number\">2</span> <span class=\"operator\">|</span>                 <span class=\"number\">5</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">-----------+---------------------+-------------------+</span></span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n<p>显示所有的任务列表</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span>  <span class=\"keyword\">show</span> <span class=\"keyword\">full</span> processlist;</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">----+-----------------+-----------+---------+---------+--------+------------------------+-----------------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> Id <span class=\"operator\">|</span> <span class=\"keyword\">User</span>            <span class=\"operator\">|</span> Host      <span class=\"operator\">|</span> db      <span class=\"operator\">|</span> Command <span class=\"operator\">|</span> <span class=\"type\">Time</span>   <span class=\"operator\">|</span> State                  <span class=\"operator\">|</span> Info                  <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">----+-----------------+-----------+---------+---------+--------+------------------------+-----------------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span>  <span class=\"number\">5</span> <span class=\"operator\">|</span> event_scheduler <span class=\"operator\">|</span> localhost <span class=\"operator\">|</span> <span class=\"keyword\">NULL</span>    <span class=\"operator\">|</span> Daemon  <span class=\"operator\">|</span> <span class=\"number\">883049</span> <span class=\"operator\">|</span> Waiting <span class=\"keyword\">on</span> <span class=\"keyword\">empty</span> queue <span class=\"operator\">|</span> <span class=\"keyword\">NULL</span>                  <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"number\">15</span> <span class=\"operator\">|</span> root            <span class=\"operator\">|</span> localhost <span class=\"operator\">|</span> kangpan <span class=\"operator\">|</span> Query   <span class=\"operator\">|</span>      <span class=\"number\">0</span> <span class=\"operator\">|</span> init                   <span class=\"operator\">|</span> <span class=\"keyword\">show</span> <span class=\"keyword\">full</span> processlist <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">----+-----------------+-----------+---------+---------+--------+------------------------+-----------------------+</span></span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.01</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p>dataSource.getConnection()执行完，至此一个connection才创建完成。我们验证一下 在dataSource.getConnection()时打一下断点。按F8 执行一步在控制台可以看到connection = com.mysql.jdbc.JDBC4Connection@1500b2f3 实例创建完毕，我们再去数据库中看看连接数加一。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">openConnection</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (log.isDebugEnabled()) &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;Opening JDBC Connection&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  connection = dataSource.getConnection();<span class=\"comment\">// 最终获取连接的地方在这句.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (level != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    connection.setTransactionIsolation(level.getLevel());<span class=\"comment\">// 设置隔离等级</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  setDesiredAutoCommit(autoCommit);<span class=\"comment\">// 是否自动提交，默认false,update不会提交到数据库，需要手动commit</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"不使用连接池的-UnpooledDataSource\"><a href=\"#不使用连接池的-UnpooledDataSource\" class=\"headerlink\" title=\"不使用连接池的 UnpooledDataSource\"></a>不使用连接池的 UnpooledDataSource</h3><p>当 <dataSource>的type属性被配置成了”UNPOOLED”，MyBatis首先会实例化一个UnpooledDataSourceFactory工厂实例，然后通过.getDataSource()方法返回一个UnpooledDataSource实例对象引用，我们假定为dataSource。<br>使用UnpooledDataSource的getConnection()，每调用一次就会产生一个新的Connection实例对象。</p>\n<p>UnPooledDataSource的getConnection()方法实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">UnpooledDataSource的getConnection()实现</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Connection <span class=\"title function_\">getConnection</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> doGetConnection(username, password);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> Connection <span class=\"title function_\">doGetConnection</span><span class=\"params\">(String username, String password)</span> <span class=\"keyword\">throws</span> SQLException</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 封装username和password成properties</span></span><br><span class=\"line\">  <span class=\"type\">Properties</span> <span class=\"variable\">props</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Properties</span>();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (driverProperties != <span class=\"literal\">null</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      props.putAll(driverProperties);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (username != <span class=\"literal\">null</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      props.setProperty(<span class=\"string\">&quot;user&quot;</span>, username);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (password != <span class=\"literal\">null</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      props.setProperty(<span class=\"string\">&quot;password&quot;</span>, password);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> doGetConnection(props);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *  获取数据连接</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Connection <span class=\"title function_\">doGetConnection</span><span class=\"params\">(Properties properties)</span> <span class=\"keyword\">throws</span> SQLException</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1.初始化驱动</span></span><br><span class=\"line\">  initializeDriver();</span><br><span class=\"line\">  <span class=\"comment\">// 2.从DriverManager中获取连接，获取新的Connection对象</span></span><br><span class=\"line\">  <span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> DriverManager.getConnection(url, properties);</span><br><span class=\"line\">  <span class=\"comment\">// 3.配置connection属性</span></span><br><span class=\"line\">  configureConnection(connection);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> connection;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>UnpooledDataSource会做以下几件事情：</p>\n<ul>\n<li><p>初始化驱动： 判断driver驱动是否已经加载到内存中，如果还没有加载，则会动态地加载driver类，并实例化一个Driver对象，使用DriverManager.registerDriver()方法将其注册到内存中，以供后续使用。</p>\n</li>\n<li><p>创建Connection对象： 使用DriverManager.getConnection()方法创建连接。</p>\n</li>\n<li><p>配置Connection对象： 设置是否自动提交autoCommit和隔离级别isolationLevel。</p>\n</li>\n<li><p>返回Connection对象。</p>\n</li>\n</ul>\n<p>我们每调用一次getConnection()方法，都会通过DriverManager.getConnection()返回新的java.sql.Connection实例,这样当然对于资源是一种浪费，为了防止重复的去创建和销毁连接,于是引入了连接池的概念。</p>\n<h3 id=\"使用了连接池的-PooledDataSource\"><a href=\"#使用了连接池的-PooledDataSource\" class=\"headerlink\" title=\"使用了连接池的 PooledDataSource\"></a>使用了连接池的 PooledDataSource</h3><p>要理解连接池，首先要了解它对于connection的容器，它使用PoolState容器来管理所有的conncetion。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PooledDataSource implements DataSource &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  private static final Log log = LogFactory.getLog(PooledDataSource.class);</span><br><span class=\"line\"></span><br><span class=\"line\">  private final PoolState state = new PoolState(this);</span><br><span class=\"line\"></span><br><span class=\"line\">  private final UnpooledDataSource dataSource;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在PoolState中，它将connection分为两种状态，空闲状态（idle）和活动状态(active)，他们分别被存储到PoolState容器内的idleConnections和activeConnections两个ArrayList中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PoolState &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  protected PooledDataSource dataSource;</span><br><span class=\"line\"></span><br><span class=\"line\">  protected final List&lt;PooledConnection&gt; idleConnections = new ArrayList&lt;PooledConnection&gt;();</span><br><span class=\"line\">  </span><br><span class=\"line\">  protected final List&lt;PooledConnection&gt; activeConnections = new ArrayList&lt;PooledConnection&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>idleConnections：空闲(idle)状态PooledConnection对象被放置到此集合中，表示当前闲置的没有被使用的PooledConnection集合，调用PooledDataSource的getConnection()方法时，会优先从此集合中取PooledConnection对象。当用完一个java.sql.Connection对象时，MyBatis会将其包裹成PooledConnection对象放到此集合中。</p>\n</li>\n<li><p>activeConnections：活动(active)状态的PooledConnection对象被放置到名为activeConnections的ArrayList中，表示当前正在被使用的PooledConnection集合，调用PooledDataSource的getConnection()方法时，会优先从idleConnections集合中取PooledConnection对象，如果没有，则看活跃状态的线程集合是否已满，如果未满，PooledDataSource会创建出一个PooledConnection，添加到此集合中，并返回。</p>\n</li>\n</ul>\n<h4 id=\"从连接池中获取一个连接对象的过程\"><a href=\"#从连接池中获取一个连接对象的过程\" class=\"headerlink\" title=\"从连接池中获取一个连接对象的过程\"></a>从连接池中获取一个连接对象的过程</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> PooledConnection <span class=\"title function_\">popConnection</span><span class=\"params\">(String username, String password)</span> <span class=\"keyword\">throws</span> SQLException &#123;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">countedWait</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"type\">PooledConnection</span> <span class=\"variable\">conn</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">localBadConnectionCount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (conn == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (state) &#123;<span class=\"comment\">// 给state对象加锁</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!state.idleConnections.isEmpty()) &#123;<span class=\"comment\">// 如果空闲列表不空，就从空闲列表中拿connection</span></span><br><span class=\"line\">          <span class=\"comment\">// Pool has available connection</span></span><br><span class=\"line\">          conn = state.idleConnections.remove(<span class=\"number\">0</span>);<span class=\"comment\">// 拿出空闲列表中的第一个，去验证连接是否还有效</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (log.isDebugEnabled()) &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;Checked out connection &quot;</span> + conn.getRealHashCode() + <span class=\"string\">&quot; from pool.&quot;</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 空闲连接池中没有可用的连接，就来看看活跃连接列表中是否有，先判断活动连接总数 是否小于 最大可用的活动连接数</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (state.activeConnections.size() &lt; poolMaximumActiveConnections) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果连接数小于list.size 直接创建新的连接。</span></span><br><span class=\"line\">            conn = <span class=\"keyword\">new</span> <span class=\"title class_\">PooledConnection</span>(dataSource.getConnection(), <span class=\"built_in\">this</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (log.isDebugEnabled()) &#123;</span><br><span class=\"line\">              log.debug(<span class=\"string\">&quot;Created connection &quot;</span> + conn.getRealHashCode() + <span class=\"string\">&quot;.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 此时连接数也满了，不能创建新的连接。找到最老的那个，检查它是否过期</span></span><br><span class=\"line\">            <span class=\"comment\">// 计算它的校验时间，如果校验时间大于连接池规定的最大校验时间，则认为它已经过期了</span></span><br><span class=\"line\">            <span class=\"comment\">// 利用这个PoolConnection内部的realConnection重新生成一个PooledConnection</span></span><br><span class=\"line\">            <span class=\"type\">PooledConnection</span> <span class=\"variable\">oldestActiveConnection</span> <span class=\"operator\">=</span> state.activeConnections.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">longestCheckoutTime</span> <span class=\"operator\">=</span> oldestActiveConnection.getCheckoutTime();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (longestCheckoutTime &gt; poolMaximumCheckoutTime) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 可以要求过期这个连接。</span></span><br><span class=\"line\">              state.claimedOverdueConnectionCount++;</span><br><span class=\"line\">              state.accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime;</span><br><span class=\"line\">              state.accumulatedCheckoutTime += longestCheckoutTime;</span><br><span class=\"line\">              state.activeConnections.remove(oldestActiveConnection);</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!oldestActiveConnection.getRealConnection().getAutoCommit()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                  oldestActiveConnection.getRealConnection().rollback();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (SQLException e) &#123;</span><br><span class=\"line\">                  log.debug(<span class=\"string\">&quot;Bad connection. Could not roll back&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              conn = <span class=\"keyword\">new</span> <span class=\"title class_\">PooledConnection</span>(oldestActiveConnection.getRealConnection(), <span class=\"built_in\">this</span>);</span><br><span class=\"line\">              conn.setCreatedTimestamp(oldestActiveConnection.getCreatedTimestamp());</span><br><span class=\"line\">              conn.setLastUsedTimestamp(oldestActiveConnection.getLastUsedTimestamp());</span><br><span class=\"line\">              oldestActiveConnection.invalidate();</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (log.isDebugEnabled()) &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;Claimed overdue connection &quot;</span> + conn.getRealHashCode() + <span class=\"string\">&quot;.&quot;</span>);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 如果不能释放，则必须等待</span></span><br><span class=\"line\">              <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!countedWait) &#123;</span><br><span class=\"line\">                  state.hadToWaitCount++;</span><br><span class=\"line\">                  countedWait = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (log.isDebugEnabled()) &#123;</span><br><span class=\"line\">                  log.debug(<span class=\"string\">&quot;Waiting as long as &quot;</span> + poolTimeToWait + <span class=\"string\">&quot; milliseconds for connection.&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"type\">long</span> <span class=\"variable\">wt</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">                state.wait(poolTimeToWait);</span><br><span class=\"line\">                state.accumulatedWaitTime += System.currentTimeMillis() - wt;</span><br><span class=\"line\">              &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (conn != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// ping to server and check the connection is valid or not</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (conn.isValid()) &#123;<span class=\"comment\">// 去验证连接是否还有效。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class=\"line\">              conn.getRealConnection().rollback();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            conn.setConnectionTypeCode(assembleConnectionTypeCode(dataSource.getUrl(), username, password));</span><br><span class=\"line\">            conn.setCheckoutTimestamp(System.currentTimeMillis());</span><br><span class=\"line\">            conn.setLastUsedTimestamp(System.currentTimeMillis());</span><br><span class=\"line\">            state.activeConnections.add(conn);</span><br><span class=\"line\">            state.requestCount++;</span><br><span class=\"line\">            state.accumulatedRequestTime += System.currentTimeMillis() - t;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (log.isDebugEnabled()) &#123;</span><br><span class=\"line\">              log.debug(<span class=\"string\">&quot;A bad connection (&quot;</span> + conn.getRealHashCode() + <span class=\"string\">&quot;) was returned from the pool, getting another connection.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            state.badConnectionCount++;</span><br><span class=\"line\">            localBadConnectionCount++;</span><br><span class=\"line\">            conn = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (localBadConnectionCount &gt; (poolMaximumIdleConnections + poolMaximumLocalBadConnectionTolerance)) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (log.isDebugEnabled()) &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;PooledDataSource: Could not get a good connection to the database.&quot;</span>);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SQLException</span>(<span class=\"string\">&quot;PooledDataSource: Could not get a good connection to the database.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (conn == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (log.isDebugEnabled()) &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SQLException</span>(<span class=\"string\">&quot;PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> conn;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"复用连接的过程\"><a href=\"#复用连接的过程\" class=\"headerlink\" title=\"复用连接的过程\"></a>复用连接的过程</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">methodName</span> <span class=\"operator\">=</span> method.getName();</span><br><span class=\"line\">    <span class=\"comment\">// 当调用关闭的时候，回收此Connection到PooledDataSource中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (CLOSE.hashCode() == methodName.hashCode() &amp;&amp; CLOSE.equals(methodName)) &#123;</span><br><span class=\"line\">      dataSource.pushConnection(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class=\"line\">          checkConnection();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> method.invoke(realConnection, args);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"简历","date":"2022-03-20T06:55:32.000Z","_content":"\n### 个人优势\n\n热爱IT行业，喜欢专研技术。能独立完成一个项目，有个人的博客，为公司员工开发过一个网站，搭建公司内部文档网页，在公司曾获得华为山头奖。\n\n### 工作经历\n\n1. 2020.05-至今\n\n   **广州赛意信息科技股份有限公司 ／ 新物料选型认证**\n\n   全栈开发工程师\n\n   \n\n   我任职赛意公司PG3部门，是新物料选型认证项目中的导师及全栈开发工程师。\n\n   它属于一个流程管理项目，对物料进行一个选型和认证的过程。\n\n   整套系统部署在docker容器，集成华为的HIC系统进行打包和发布。\n\n   我的主要职责：\n\n   1.带新同事熟悉项目及指导开发工作；\n\n   2.独立带领同事完成华为方UT指标；\n\n   3.完成项目中日常开发工作。\n\n2. 2018.08-2020.04\n\n   **深圳软通动力信息技术有限公司 ／ GPS业务应用部**\n\n   Java开发及运维\n\n   \n\n   我担任公司的Java后端开发及运维工作，主要负责ISDP集成交付作业平台项目，业务架构三层：交易层(销售-供应-人力-采购-财经) 项目层 作业层。技术架构使用的是Springboot、SpringCloud及华为内部jalor框架。\n\n   我的主要职责\n\n   1. 系统运维，负责多个模块的事件处理，解决用户问题；\n   2. 敏捷开发，保证每次迭代上线\n   3. 参与PG切换\n\n   \n\n3. 2017.07-2018.07\n\n   **深圳中软国际科技服务有限公司 ／ 质量流程IT管理**\n\n   Java开发\n\n   \n\n   我主要担任公司的Java开发\n\n   1. 负责模块有联系人基本信息模块，客户声音模块，客户活动模块。\n   2. 负责并参与系统需求分析、功能模块详细设计，完成系统业务功能实现、QC、UT及维护工作。\n   3. 负责编写相应的需求、设计与技术文档，向系统使用者提供技术支持服务。\n\n   \n\n### 项目经历\n\n1. **UPC多租户**（广州赛意信息科技股份有限公司）\n\n   2021.05-至今\n\n   提供基础服务的平台（基础配置，用户信息等），注册到eureka中心，给其它子模块项目调用。\n\n   1. 参与设计配置表（国际化，数据字典，lookup, 导航菜单等）\n   2. 参与开发支持Mysql及Oracle数据库的mapper层\n   3. 参与开发mybatis插件分页\n   4. 参与服务调用模板开发\n\n2. **新物料选型认证**（广州赛意信息科技股份有限公司）\n\n   2020.05-至今\n\n   属于流程关联项目，华为方购买物料的时候要进行一系列的筛选，经过选型及认证的过程，流程中有组建sourcingTeam，执行sourcing，发布选型结论，测试认证，认证综合结论等节点。\n\n   1. 独立开发节点之间代办功能，应用号功能\n   2. 独立开发出各个节点关闭功能及开启功能\n   3. 参与前端页面模块化设计，tip设计\n   4. 参与流程节点导航图的设计\n\n3. **ISDP集成交付作业平台**（深圳软通动力信息技术有限公司）\n\n   2018.09-2020.04\n\n   一个ISDP集成交付作业平台\n\n   业务架构三层：\n\n   交易层(销售-供应-人力-采购-财经) 项目层 作业层\n\n   总体架构：\n\n   1. 技术：Springboot、SpringCloud；\n\n   2. 微内核+可插拔组建：提供基础的平台服务（注册中心、配置中心、网关等）和公共组建（导入导出、任务调度、消息处理等）；\n\n   3. HW内部集成：整合HW内部的SSO、SGOV、iData等基础服务，封装HIC的Redis、MQS、HS2、EDM、Kafka等平台能力；\n\n   4. 运维支撑：整合HIC，支持日志、监控、服务跟踪等运维工具，给开发运维提供良好的支撑；\n\n   5. 全球分布式：提供基于平台的全球分布式部署能力，提供自定义的路由解决方案；\n\n   6. 公共服务：SDCP2.0是基于SpringCloud的微服务开发框架，提供了很多公共服务能力用于快速构建SDCP微服务应用。\n\n   \n\n   分层模式：采用前中后三层结构\n\n   前台：前台资源集中管理，统一在Nginx容器中部署；\n\n   中台：基于SpringCloud的微服务分布式部署，基于eureka的全球服务注册发现；\n\n   后台：每个微服务独立数据库，基于RDI实现数据库之间的分发和汇聚 。\n\n   \n\n   1. 单独负责ISDP项目层中的合同管理层开发，多次上线0生产问题；\n\n   2. 运维绩效季度好评前十名。\n\n   \n\n   项目链接: https://isdp-dg.huawei.com\n\n4. **CRM**（深圳中软国际科技服务有限公司）\n\n   2017.07-2018.07\n\n   CRM 客户关系管理，一个企业客户的关系网站，主要有Account、Contact、FollowUp、Activity、Plan这2五大模块。项目使用的技术是spring + jalor5 + maven + mybatis,数据库用的是oracle，DB层对接的siebel。使用mybaits访问DB层。前端使用的是华为jalor5技术，封装的jquery。\n\n   1. 设计过重复提交功能及国际化转换\n\n### 教育经历\n\n1. 2010.09-2015.07\n\n   **东华理工大学**\n\n   本科 . 统招 / 软件工程\n\n### 社交主页\n\n1. https://github.com/kangpanwork\n2. http://kangpan.work\n","source":"_posts/简历.md","raw":"---\ntitle: 简历\ndate: 2022-03-20 14:55:32\ntags: Other\n---\n\n### 个人优势\n\n热爱IT行业，喜欢专研技术。能独立完成一个项目，有个人的博客，为公司员工开发过一个网站，搭建公司内部文档网页，在公司曾获得华为山头奖。\n\n### 工作经历\n\n1. 2020.05-至今\n\n   **广州赛意信息科技股份有限公司 ／ 新物料选型认证**\n\n   全栈开发工程师\n\n   \n\n   我任职赛意公司PG3部门，是新物料选型认证项目中的导师及全栈开发工程师。\n\n   它属于一个流程管理项目，对物料进行一个选型和认证的过程。\n\n   整套系统部署在docker容器，集成华为的HIC系统进行打包和发布。\n\n   我的主要职责：\n\n   1.带新同事熟悉项目及指导开发工作；\n\n   2.独立带领同事完成华为方UT指标；\n\n   3.完成项目中日常开发工作。\n\n2. 2018.08-2020.04\n\n   **深圳软通动力信息技术有限公司 ／ GPS业务应用部**\n\n   Java开发及运维\n\n   \n\n   我担任公司的Java后端开发及运维工作，主要负责ISDP集成交付作业平台项目，业务架构三层：交易层(销售-供应-人力-采购-财经) 项目层 作业层。技术架构使用的是Springboot、SpringCloud及华为内部jalor框架。\n\n   我的主要职责\n\n   1. 系统运维，负责多个模块的事件处理，解决用户问题；\n   2. 敏捷开发，保证每次迭代上线\n   3. 参与PG切换\n\n   \n\n3. 2017.07-2018.07\n\n   **深圳中软国际科技服务有限公司 ／ 质量流程IT管理**\n\n   Java开发\n\n   \n\n   我主要担任公司的Java开发\n\n   1. 负责模块有联系人基本信息模块，客户声音模块，客户活动模块。\n   2. 负责并参与系统需求分析、功能模块详细设计，完成系统业务功能实现、QC、UT及维护工作。\n   3. 负责编写相应的需求、设计与技术文档，向系统使用者提供技术支持服务。\n\n   \n\n### 项目经历\n\n1. **UPC多租户**（广州赛意信息科技股份有限公司）\n\n   2021.05-至今\n\n   提供基础服务的平台（基础配置，用户信息等），注册到eureka中心，给其它子模块项目调用。\n\n   1. 参与设计配置表（国际化，数据字典，lookup, 导航菜单等）\n   2. 参与开发支持Mysql及Oracle数据库的mapper层\n   3. 参与开发mybatis插件分页\n   4. 参与服务调用模板开发\n\n2. **新物料选型认证**（广州赛意信息科技股份有限公司）\n\n   2020.05-至今\n\n   属于流程关联项目，华为方购买物料的时候要进行一系列的筛选，经过选型及认证的过程，流程中有组建sourcingTeam，执行sourcing，发布选型结论，测试认证，认证综合结论等节点。\n\n   1. 独立开发节点之间代办功能，应用号功能\n   2. 独立开发出各个节点关闭功能及开启功能\n   3. 参与前端页面模块化设计，tip设计\n   4. 参与流程节点导航图的设计\n\n3. **ISDP集成交付作业平台**（深圳软通动力信息技术有限公司）\n\n   2018.09-2020.04\n\n   一个ISDP集成交付作业平台\n\n   业务架构三层：\n\n   交易层(销售-供应-人力-采购-财经) 项目层 作业层\n\n   总体架构：\n\n   1. 技术：Springboot、SpringCloud；\n\n   2. 微内核+可插拔组建：提供基础的平台服务（注册中心、配置中心、网关等）和公共组建（导入导出、任务调度、消息处理等）；\n\n   3. HW内部集成：整合HW内部的SSO、SGOV、iData等基础服务，封装HIC的Redis、MQS、HS2、EDM、Kafka等平台能力；\n\n   4. 运维支撑：整合HIC，支持日志、监控、服务跟踪等运维工具，给开发运维提供良好的支撑；\n\n   5. 全球分布式：提供基于平台的全球分布式部署能力，提供自定义的路由解决方案；\n\n   6. 公共服务：SDCP2.0是基于SpringCloud的微服务开发框架，提供了很多公共服务能力用于快速构建SDCP微服务应用。\n\n   \n\n   分层模式：采用前中后三层结构\n\n   前台：前台资源集中管理，统一在Nginx容器中部署；\n\n   中台：基于SpringCloud的微服务分布式部署，基于eureka的全球服务注册发现；\n\n   后台：每个微服务独立数据库，基于RDI实现数据库之间的分发和汇聚 。\n\n   \n\n   1. 单独负责ISDP项目层中的合同管理层开发，多次上线0生产问题；\n\n   2. 运维绩效季度好评前十名。\n\n   \n\n   项目链接: https://isdp-dg.huawei.com\n\n4. **CRM**（深圳中软国际科技服务有限公司）\n\n   2017.07-2018.07\n\n   CRM 客户关系管理，一个企业客户的关系网站，主要有Account、Contact、FollowUp、Activity、Plan这2五大模块。项目使用的技术是spring + jalor5 + maven + mybatis,数据库用的是oracle，DB层对接的siebel。使用mybaits访问DB层。前端使用的是华为jalor5技术，封装的jquery。\n\n   1. 设计过重复提交功能及国际化转换\n\n### 教育经历\n\n1. 2010.09-2015.07\n\n   **东华理工大学**\n\n   本科 . 统招 / 软件工程\n\n### 社交主页\n\n1. https://github.com/kangpanwork\n2. http://kangpan.work\n","slug":"简历","published":1,"updated":"2022-03-20T07:00:16.202Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0yxjemr0000hclng5xs6c5n","content":"<h3 id=\"个人优势\"><a href=\"#个人优势\" class=\"headerlink\" title=\"个人优势\"></a>个人优势</h3><p>热爱IT行业，喜欢专研技术。能独立完成一个项目，有个人的博客，为公司员工开发过一个网站，搭建公司内部文档网页，在公司曾获得华为山头奖。</p>\n<h3 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h3><ol>\n<li><p>2020.05-至今</p>\n<p><strong>广州赛意信息科技股份有限公司 ／ 新物料选型认证</strong></p>\n<p>全栈开发工程师</p>\n<p>我任职赛意公司PG3部门，是新物料选型认证项目中的导师及全栈开发工程师。</p>\n<p>它属于一个流程管理项目，对物料进行一个选型和认证的过程。</p>\n<p>整套系统部署在docker容器，集成华为的HIC系统进行打包和发布。</p>\n<p>我的主要职责：</p>\n<p>1.带新同事熟悉项目及指导开发工作；</p>\n<p>2.独立带领同事完成华为方UT指标；</p>\n<p>3.完成项目中日常开发工作。</p>\n</li>\n<li><p>2018.08-2020.04</p>\n<p><strong>深圳软通动力信息技术有限公司 ／ GPS业务应用部</strong></p>\n<p>Java开发及运维</p>\n<p>我担任公司的Java后端开发及运维工作，主要负责ISDP集成交付作业平台项目，业务架构三层：交易层(销售-供应-人力-采购-财经) 项目层 作业层。技术架构使用的是Springboot、SpringCloud及华为内部jalor框架。</p>\n<p>我的主要职责</p>\n<ol>\n<li>系统运维，负责多个模块的事件处理，解决用户问题；</li>\n<li>敏捷开发，保证每次迭代上线</li>\n<li>参与PG切换</li>\n</ol>\n</li>\n<li><p>2017.07-2018.07</p>\n<p><strong>深圳中软国际科技服务有限公司 ／ 质量流程IT管理</strong></p>\n<p>Java开发</p>\n<p>我主要担任公司的Java开发</p>\n<ol>\n<li>负责模块有联系人基本信息模块，客户声音模块，客户活动模块。</li>\n<li>负责并参与系统需求分析、功能模块详细设计，完成系统业务功能实现、QC、UT及维护工作。</li>\n<li>负责编写相应的需求、设计与技术文档，向系统使用者提供技术支持服务。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"项目经历\"><a href=\"#项目经历\" class=\"headerlink\" title=\"项目经历\"></a>项目经历</h3><ol>\n<li><p><strong>UPC多租户</strong>（广州赛意信息科技股份有限公司）</p>\n<p>2021.05-至今</p>\n<p>提供基础服务的平台（基础配置，用户信息等），注册到eureka中心，给其它子模块项目调用。</p>\n<ol>\n<li>参与设计配置表（国际化，数据字典，lookup, 导航菜单等）</li>\n<li>参与开发支持Mysql及Oracle数据库的mapper层</li>\n<li>参与开发mybatis插件分页</li>\n<li>参与服务调用模板开发</li>\n</ol>\n</li>\n<li><p><strong>新物料选型认证</strong>（广州赛意信息科技股份有限公司）</p>\n<p>2020.05-至今</p>\n<p>属于流程关联项目，华为方购买物料的时候要进行一系列的筛选，经过选型及认证的过程，流程中有组建sourcingTeam，执行sourcing，发布选型结论，测试认证，认证综合结论等节点。</p>\n<ol>\n<li>独立开发节点之间代办功能，应用号功能</li>\n<li>独立开发出各个节点关闭功能及开启功能</li>\n<li>参与前端页面模块化设计，tip设计</li>\n<li>参与流程节点导航图的设计</li>\n</ol>\n</li>\n<li><p><strong>ISDP集成交付作业平台</strong>（深圳软通动力信息技术有限公司）</p>\n<p>2018.09-2020.04</p>\n<p>一个ISDP集成交付作业平台</p>\n<p>业务架构三层：</p>\n<p>交易层(销售-供应-人力-采购-财经) 项目层 作业层</p>\n<p>总体架构：</p>\n<ol>\n<li><p>技术：Springboot、SpringCloud；</p>\n</li>\n<li><p>微内核+可插拔组建：提供基础的平台服务（注册中心、配置中心、网关等）和公共组建（导入导出、任务调度、消息处理等）；</p>\n</li>\n<li><p>HW内部集成：整合HW内部的SSO、SGOV、iData等基础服务，封装HIC的Redis、MQS、HS2、EDM、Kafka等平台能力；</p>\n</li>\n<li><p>运维支撑：整合HIC，支持日志、监控、服务跟踪等运维工具，给开发运维提供良好的支撑；</p>\n</li>\n<li><p>全球分布式：提供基于平台的全球分布式部署能力，提供自定义的路由解决方案；</p>\n</li>\n<li><p>公共服务：SDCP2.0是基于SpringCloud的微服务开发框架，提供了很多公共服务能力用于快速构建SDCP微服务应用。</p>\n</li>\n</ol>\n<p>分层模式：采用前中后三层结构</p>\n<p>前台：前台资源集中管理，统一在Nginx容器中部署；</p>\n<p>中台：基于SpringCloud的微服务分布式部署，基于eureka的全球服务注册发现；</p>\n<p>后台：每个微服务独立数据库，基于RDI实现数据库之间的分发和汇聚 。</p>\n<ol>\n<li><p>单独负责ISDP项目层中的合同管理层开发，多次上线0生产问题；</p>\n</li>\n<li><p>运维绩效季度好评前十名。</p>\n</li>\n</ol>\n<p>项目链接: <a href=\"https://isdp-dg.huawei.com/\">https://isdp-dg.huawei.com</a></p>\n</li>\n<li><p><strong>CRM</strong>（深圳中软国际科技服务有限公司）</p>\n<p>2017.07-2018.07</p>\n<p>CRM 客户关系管理，一个企业客户的关系网站，主要有Account、Contact、FollowUp、Activity、Plan这2五大模块。项目使用的技术是spring + jalor5 + maven + mybatis,数据库用的是oracle，DB层对接的siebel。使用mybaits访问DB层。前端使用的是华为jalor5技术，封装的jquery。</p>\n<ol>\n<li>设计过重复提交功能及国际化转换</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"教育经历\"><a href=\"#教育经历\" class=\"headerlink\" title=\"教育经历\"></a>教育经历</h3><ol>\n<li><p>2010.09-2015.07</p>\n<p><strong>东华理工大学</strong></p>\n<p>本科 . 统招 / 软件工程</p>\n</li>\n</ol>\n<h3 id=\"社交主页\"><a href=\"#社交主页\" class=\"headerlink\" title=\"社交主页\"></a>社交主页</h3><ol>\n<li><a href=\"https://github.com/kangpanwork\">https://github.com/kangpanwork</a></li>\n<li><a href=\"http://kangpan.work/\">http://kangpan.work</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"个人优势\"><a href=\"#个人优势\" class=\"headerlink\" title=\"个人优势\"></a>个人优势</h3><p>热爱IT行业，喜欢专研技术。能独立完成一个项目，有个人的博客，为公司员工开发过一个网站，搭建公司内部文档网页，在公司曾获得华为山头奖。</p>\n<h3 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h3><ol>\n<li><p>2020.05-至今</p>\n<p><strong>广州赛意信息科技股份有限公司 ／ 新物料选型认证</strong></p>\n<p>全栈开发工程师</p>\n<p>我任职赛意公司PG3部门，是新物料选型认证项目中的导师及全栈开发工程师。</p>\n<p>它属于一个流程管理项目，对物料进行一个选型和认证的过程。</p>\n<p>整套系统部署在docker容器，集成华为的HIC系统进行打包和发布。</p>\n<p>我的主要职责：</p>\n<p>1.带新同事熟悉项目及指导开发工作；</p>\n<p>2.独立带领同事完成华为方UT指标；</p>\n<p>3.完成项目中日常开发工作。</p>\n</li>\n<li><p>2018.08-2020.04</p>\n<p><strong>深圳软通动力信息技术有限公司 ／ GPS业务应用部</strong></p>\n<p>Java开发及运维</p>\n<p>我担任公司的Java后端开发及运维工作，主要负责ISDP集成交付作业平台项目，业务架构三层：交易层(销售-供应-人力-采购-财经) 项目层 作业层。技术架构使用的是Springboot、SpringCloud及华为内部jalor框架。</p>\n<p>我的主要职责</p>\n<ol>\n<li>系统运维，负责多个模块的事件处理，解决用户问题；</li>\n<li>敏捷开发，保证每次迭代上线</li>\n<li>参与PG切换</li>\n</ol>\n</li>\n<li><p>2017.07-2018.07</p>\n<p><strong>深圳中软国际科技服务有限公司 ／ 质量流程IT管理</strong></p>\n<p>Java开发</p>\n<p>我主要担任公司的Java开发</p>\n<ol>\n<li>负责模块有联系人基本信息模块，客户声音模块，客户活动模块。</li>\n<li>负责并参与系统需求分析、功能模块详细设计，完成系统业务功能实现、QC、UT及维护工作。</li>\n<li>负责编写相应的需求、设计与技术文档，向系统使用者提供技术支持服务。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"项目经历\"><a href=\"#项目经历\" class=\"headerlink\" title=\"项目经历\"></a>项目经历</h3><ol>\n<li><p><strong>UPC多租户</strong>（广州赛意信息科技股份有限公司）</p>\n<p>2021.05-至今</p>\n<p>提供基础服务的平台（基础配置，用户信息等），注册到eureka中心，给其它子模块项目调用。</p>\n<ol>\n<li>参与设计配置表（国际化，数据字典，lookup, 导航菜单等）</li>\n<li>参与开发支持Mysql及Oracle数据库的mapper层</li>\n<li>参与开发mybatis插件分页</li>\n<li>参与服务调用模板开发</li>\n</ol>\n</li>\n<li><p><strong>新物料选型认证</strong>（广州赛意信息科技股份有限公司）</p>\n<p>2020.05-至今</p>\n<p>属于流程关联项目，华为方购买物料的时候要进行一系列的筛选，经过选型及认证的过程，流程中有组建sourcingTeam，执行sourcing，发布选型结论，测试认证，认证综合结论等节点。</p>\n<ol>\n<li>独立开发节点之间代办功能，应用号功能</li>\n<li>独立开发出各个节点关闭功能及开启功能</li>\n<li>参与前端页面模块化设计，tip设计</li>\n<li>参与流程节点导航图的设计</li>\n</ol>\n</li>\n<li><p><strong>ISDP集成交付作业平台</strong>（深圳软通动力信息技术有限公司）</p>\n<p>2018.09-2020.04</p>\n<p>一个ISDP集成交付作业平台</p>\n<p>业务架构三层：</p>\n<p>交易层(销售-供应-人力-采购-财经) 项目层 作业层</p>\n<p>总体架构：</p>\n<ol>\n<li><p>技术：Springboot、SpringCloud；</p>\n</li>\n<li><p>微内核+可插拔组建：提供基础的平台服务（注册中心、配置中心、网关等）和公共组建（导入导出、任务调度、消息处理等）；</p>\n</li>\n<li><p>HW内部集成：整合HW内部的SSO、SGOV、iData等基础服务，封装HIC的Redis、MQS、HS2、EDM、Kafka等平台能力；</p>\n</li>\n<li><p>运维支撑：整合HIC，支持日志、监控、服务跟踪等运维工具，给开发运维提供良好的支撑；</p>\n</li>\n<li><p>全球分布式：提供基于平台的全球分布式部署能力，提供自定义的路由解决方案；</p>\n</li>\n<li><p>公共服务：SDCP2.0是基于SpringCloud的微服务开发框架，提供了很多公共服务能力用于快速构建SDCP微服务应用。</p>\n</li>\n</ol>\n<p>分层模式：采用前中后三层结构</p>\n<p>前台：前台资源集中管理，统一在Nginx容器中部署；</p>\n<p>中台：基于SpringCloud的微服务分布式部署，基于eureka的全球服务注册发现；</p>\n<p>后台：每个微服务独立数据库，基于RDI实现数据库之间的分发和汇聚 。</p>\n<ol>\n<li><p>单独负责ISDP项目层中的合同管理层开发，多次上线0生产问题；</p>\n</li>\n<li><p>运维绩效季度好评前十名。</p>\n</li>\n</ol>\n<p>项目链接: <a href=\"https://isdp-dg.huawei.com/\">https://isdp-dg.huawei.com</a></p>\n</li>\n<li><p><strong>CRM</strong>（深圳中软国际科技服务有限公司）</p>\n<p>2017.07-2018.07</p>\n<p>CRM 客户关系管理，一个企业客户的关系网站，主要有Account、Contact、FollowUp、Activity、Plan这2五大模块。项目使用的技术是spring + jalor5 + maven + mybatis,数据库用的是oracle，DB层对接的siebel。使用mybaits访问DB层。前端使用的是华为jalor5技术，封装的jquery。</p>\n<ol>\n<li>设计过重复提交功能及国际化转换</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"教育经历\"><a href=\"#教育经历\" class=\"headerlink\" title=\"教育经历\"></a>教育经历</h3><ol>\n<li><p>2010.09-2015.07</p>\n<p><strong>东华理工大学</strong></p>\n<p>本科 . 统招 / 软件工程</p>\n</li>\n</ol>\n<h3 id=\"社交主页\"><a href=\"#社交主页\" class=\"headerlink\" title=\"社交主页\"></a>社交主页</h3><ol>\n<li><a href=\"https://github.com/kangpanwork\">https://github.com/kangpanwork</a></li>\n<li><a href=\"http://kangpan.work/\">http://kangpan.work</a></li>\n</ol>\n"},{"title":"LotReassign","date":"2022-05-09T08:30:19.000Z","_content":"\n\n\n在北京中芯国际出差这段日子，主要负责了 Lot Reassign 这个功能模块，同时也了解了 EDC 这个功能模块，我会在之后的文章介绍。\n\n### 功能描述\n\n#### Lot Reassign 分为三个功能模块：\n\n1. Only Product Change\n2. Lot Reassign\n3. Only Version Up\n\n\n\n#### Lot Reassign\n\nLot Reassign 主要是对当前 Lot 进行 Product、Process 、Route、 Step 进行更改。\n\n下图是 Process、Route 及 Step 的关系图，可以理解为工艺、工步、工序。\n\nProcess、Route、Step 在 MDS 进行配置。\n\n![a2be5408ea04bcf4ce341d0a10809ff7.png](https://img.gejiba.com/images/a2be5408ea04bcf4ce341d0a10809ff7.png)\n\n#### Only Product Change \n\n对 Lot 的 Product 信息进行改变，Product 信息 在 MDS 系统进行配置，可以配置当前 Product 和 升版的 Product 及 Active 的 Product，eg：ProductA.1、ProductA.2（Active）。如果对某个 Lot 进行 Product Change 那么默认取 Active 的最高版本的 Product。\n\n\n\n如果 Product 对应的 Process、Route 及 Step 有 Active 并且升版的数据，那么默认也要取这些数据进行Update。\n\n\n\n#### Only Version Up \n\n仅仅对 Lot 的 Product、Process、Route、Step 进行升版（版本应该处于 Active 状态）。\n\n\n\n### 详细设计\n\n#### Future Action\n\n针对这三个功能，它们有着公共的需要处理的业务场景就是 Future Action，\n\neg：Future Hold，Future Rework，Future Merger、Future Split、Future Reassign。\n\n如下图：绿色区域表示 Lot 所在 Step ，红色区域表示未来发生的动作。如果用户勾选删除 Future Action 复选框，进行 Reassign 之前应当提示用户 Lot 的 Process 有哪些 Future Action 会失效。Process A 切换到 Process B ，400 站点的 Future Action 会失效，如果用户未勾选，那么将进行 Copy，Process B 的 400 站点也将设置相同的 Future Action。\n\n![c9203e83b558854ceee83791060af954.png](https://img.gejiba.com/images/c9203e83b558854ceee83791060af954.png)\n\n\n\n#### Check\n\n在执行这三个功能的前置动作除了 Future Action 提示外，还将进行一系列的 Check 操作，eg：检查 Lot 的状态是否处于 Hold 状态，是否是要生产的 Lot（可能已经报废，终止，完成）等，是否正在进行加工中，是否处于异步执行等逻辑。这些检查逻辑需要详细的罗列出来，并且检查顺序要有一个优先级。当不满足某个条件，应当立即返回提示信息。因为界面支持批量，对多个 Lot 进行 Reassign 操作，所以 Check 之后应当提示哪些 Lot 是成功的，哪些是失败的及失败原因。这里存在性能问题，因为是批量，并且需要检查很多业务逻辑，调用很多不同的查询方法，接口性能需控制在 300ms，所以应当控制多少个 Lot 去处理。\n\n\n\n#### Do Action\n\n当经过一系列的检查逻辑之后，该 Lot 满足执行 Reassign 操作，在执行 Reassign 之前还将触发某些 Action ，eg：当 Process A 100 直接 Reassign to Process A 400。具体可能触发  Hold，Future Reassign 等，这些 Action 需具体罗列出来，并且排列优先级去执行。当前站点可能多个 Action ，应当考虑先触发哪个，后触发哪个，或者哪些不会触发。 eg：400 站点有 Hold Action、Rework Action、Reassign Action。必须先触发 Hold，\n\n然而 Rework 和 Reassign 哪个先执行呢，这个很让人头大，因为这两个 Action 只会先执行其中一个，如果先执行 Rework，那么回到了 400 前的站点，同时删除 Rework Action，当又到达 400 站点的时候，Rework Action 不存在，这个时候就会执行 Reassign。那假设先执行的 Reassign ，Lot 可能已经不在当前 Flow 了，如果用户勾选了删除 Future Action，那么 Rework 永远不会执行。如果未勾选会 Copy Rework Action，参考下图：\n\n但如果 A 400 到 B 400 之后是不会触发 Copy 的 Action，此时 Copy 对当前 Lot 没有意义。关于执行优先级需要沟通，根据业务场景定好优先级。因为触发顺序不一样，结果也不一样。\n\n![1fb33840e007d2cb619fc2ace11dd958.png](https://img.gejiba.com/images/1fb33840e007d2cb619fc2ace11dd958.png)\n\n如果 Process A 的 100 站点 Reassign to Process B 的 200 站点设置了 Future Action，那么将触发该 Action。\n\n有一种特殊情况，就是 B Flow 的 200 站点 Action 是 Future Reassign 并且指向的 A Flow 的 100 站点，那么又回到 Reassign 之前的 Flow A，这种操作就会毫无意义，界面应该给予友好提示。更糟糕的事是如果 A Flow 的 100 站点同样设置了 Future Reassign to B  Flow 200，那么将导致死循环。B 200 跳 A 100，A 100 跳 B 200。为了避免这种事情发生，如果 A 100 设置了 Future Reassign to B 200，那么 B 200 是不能设置 Future Reassign to A 100。\n\n![c9203e83b558854ceee83791060af954.png](https://img.gejiba.com/images/c9203e83b558854ceee83791060af954.png)\n\n这里模拟了几种执行 Action 情况，还有很多情况需要考虑，例如 FSM（Future Split & Merger）等。\n\n\n\n#### Copy Action\n\n参考上图，如果原 Flow 的站点和目标 Flow 的站点对应，将原 Flow 站点的 Action 进行 Copy。Copy 的时候需要检查目标站点是否发生变化，如果此时站点已经更新了，400 站点不存在，那么应 Hold 原 Flow 当站 100，并且给予提示。\n\n\n\n#### Do Reassign\n\n这一步之前仍然需要 Check 目标信息是否存在，如果不存在 Hold 当站，并且给予提示。将进行 Product Change 或者 Version Up 或者 Flow 的变更操作，之后就是写入历史记录。如果某个 Lot 正在加工中，具有 Control Job\n\n那么会创建一条 Future Reassign，也就是 Post Reassign。\n\n![71ae22434c908489f4eb8106ff4d4953.png](https://img.gejiba.com/images/71ae22434c908489f4eb8106ff4d4953.png) \n\n#### Post Reassign\n\n当前 Lot 已经进入机台正在加工中，这个时候是不能进行 Reassign 操作的，但是会默认创建一条 Future Reassign 的数据，Lot Move out 的时候再去执行这条数据。这里有几点要注意，因为这种情况 200 站点已经创建了一条 Future Reassign ，那么界面上不能手动再去创建 200 站点的 Future Reassign。一个站点只能有一条 Future Reassign 数据。因为是先创建数据，然后再去执行，所以执行的时候需要 Check 数据信息的正确性。如果目标站点不存在那么需要 Hold 当站，并且给予提示。\n\n![437b42ecaedae43ee2c623c55ad9db0f.png](https://img.gejiba.com/images/437b42ecaedae43ee2c623c55ad9db0f.png)\n\n\n\n#### Future Reassign\n\n未来执行的 Reassign 操作，可以提前设置。当 Lot 进行 Move Out （移出机台）或者 Pass Thu （过站）等操作的时候，会异步执行 Reassign 操作。有些 Main Process （主要的业务操作）有很多 Post Process（异步操作），例如 Move Out 可能会有以下异步操作。\n\n![dc0b99d09e34722f9f0cf444997e5aca.png](https://img.gejiba.com/images/dc0b99d09e34722f9f0cf444997e5aca.png)\n\nFuture Reassign 也属于其中一种，如果 Future Reassign 在 Check 阶段失败了，那么应当怎么处理。因为它是\n\n异步操作，没有和主逻辑在同一个事务，Future Reassign 失败了，Move Out 还是成功的。并且如果 Process Move 这个操作在 Future Reassign 之前，那么还会到下个站点。这种情况不符合业务场景，Future Reassign 失败了应该 Hold 当站，不能移动到下个站点，而且界面应当具备可以查看哪些异步操作是成功，哪些是失败，失败原因是什么。在 Future Reassign 中 Hold 方法和 Check 方法是同一个事务，Check 方法失败抛异常会导致 Hold 方法事务回滚，所以没有办法去 Hold 当站。（可以通过环境变量去控制，这个我会在之后的 Post Process 文章详细介绍）。\n\n界面支持手动创建和删除 Future Reassign。\n\n#### History\n\nNA\n\n### 界面设计\n\n#### 条件查询区域\n\nFrom 区域：用户可以根据 Product、Process、Route、Lot 四个之一去查询，例如 Process 下拉框，下拉会查询所有的 Process 数据，如果用户先选择 Product，那么需联动出来对应的 Process 和 Route 数据，如果有一对多关系，需用户手动选择，如果只有一个，默认带出。可以查询 Active 和非 Active 的数据。\n\nTo 区域：只能查询 Active 的数据，并且只能联动，不能单个下拉查询。\n\n\n\n#### 是否删除 Future Action\n\nProduct Change 和 Version Up 默认不勾选，因为这两种情况一般不会改变 Flow ，所以保持原样。\n\nReassign 默认勾选删除，因为会从当前 Flow 改变到其它 Flow。当前 Flow 的 Action 对应该 Lot 是\n\n没有意义的，需要 Copy 到新的 Flow 上。\n\n\n\n####  查询的数据列表区域\n\n默认查所有，暂时不支持分页。可以下拉选择然后添加到右边列表。\n\n\n\n#### 添加\n\n如果单选框选择的是 Product Change，那么添加的时候只能添加相同 Process 的数据。\n\n保持 Flow 不变，仅仅改变 Product 。\n\n如果选择的是 Version Up，那么 Lot 的 Product、Process、Route 必须一致才能添加。\n\n如果选择的是 Reassign ，无需卡控，查询出来的数据都能添加到右边列表中。\n\n\n\n![fc89d8b2b53d567e77dc9c03386f4d04.png](https://img.gejiba.com/images/fc89d8b2b53d567e77dc9c03386f4d04.png)\n\n### 接口设计\n\nNA\n\n### 数据库设计\n\n\n#### PD \n\n图中一个个原点表示（Process Define 数据）\n\n#### PF\n\n一个原点与原点直接的黑色实线表示 PF（记录 PD 的下级所属关系表）\n\n其中有个字段 LEVEL，有以下三种值\n\n- Main_Mod（Process 与 Route 关系）\n- Main_Ope（Process 与 Step 关系）\n- Module（Route 与 Step 关系）\n\nPF_Route 、PF_Step 表示具体的信息。\n\n#### POS \n\nStep 配置信息\n\n#### PO\n\nProcess Operation 运行时数据 \n\n\n\n\n\n![a2be5408ea04bcf4ce341d0a10809ff7.png](https://img.gejiba.com/images/a2be5408ea04bcf4ce341d0a10809ff7.png)\n","source":"_posts/LotReassign.md","raw":"---\ntitle: LotReassign\ndate: 2022-05-09 16:30:19\ntags: Design\n---\n\n\n\n在北京中芯国际出差这段日子，主要负责了 Lot Reassign 这个功能模块，同时也了解了 EDC 这个功能模块，我会在之后的文章介绍。\n\n### 功能描述\n\n#### Lot Reassign 分为三个功能模块：\n\n1. Only Product Change\n2. Lot Reassign\n3. Only Version Up\n\n\n\n#### Lot Reassign\n\nLot Reassign 主要是对当前 Lot 进行 Product、Process 、Route、 Step 进行更改。\n\n下图是 Process、Route 及 Step 的关系图，可以理解为工艺、工步、工序。\n\nProcess、Route、Step 在 MDS 进行配置。\n\n![a2be5408ea04bcf4ce341d0a10809ff7.png](https://img.gejiba.com/images/a2be5408ea04bcf4ce341d0a10809ff7.png)\n\n#### Only Product Change \n\n对 Lot 的 Product 信息进行改变，Product 信息 在 MDS 系统进行配置，可以配置当前 Product 和 升版的 Product 及 Active 的 Product，eg：ProductA.1、ProductA.2（Active）。如果对某个 Lot 进行 Product Change 那么默认取 Active 的最高版本的 Product。\n\n\n\n如果 Product 对应的 Process、Route 及 Step 有 Active 并且升版的数据，那么默认也要取这些数据进行Update。\n\n\n\n#### Only Version Up \n\n仅仅对 Lot 的 Product、Process、Route、Step 进行升版（版本应该处于 Active 状态）。\n\n\n\n### 详细设计\n\n#### Future Action\n\n针对这三个功能，它们有着公共的需要处理的业务场景就是 Future Action，\n\neg：Future Hold，Future Rework，Future Merger、Future Split、Future Reassign。\n\n如下图：绿色区域表示 Lot 所在 Step ，红色区域表示未来发生的动作。如果用户勾选删除 Future Action 复选框，进行 Reassign 之前应当提示用户 Lot 的 Process 有哪些 Future Action 会失效。Process A 切换到 Process B ，400 站点的 Future Action 会失效，如果用户未勾选，那么将进行 Copy，Process B 的 400 站点也将设置相同的 Future Action。\n\n![c9203e83b558854ceee83791060af954.png](https://img.gejiba.com/images/c9203e83b558854ceee83791060af954.png)\n\n\n\n#### Check\n\n在执行这三个功能的前置动作除了 Future Action 提示外，还将进行一系列的 Check 操作，eg：检查 Lot 的状态是否处于 Hold 状态，是否是要生产的 Lot（可能已经报废，终止，完成）等，是否正在进行加工中，是否处于异步执行等逻辑。这些检查逻辑需要详细的罗列出来，并且检查顺序要有一个优先级。当不满足某个条件，应当立即返回提示信息。因为界面支持批量，对多个 Lot 进行 Reassign 操作，所以 Check 之后应当提示哪些 Lot 是成功的，哪些是失败的及失败原因。这里存在性能问题，因为是批量，并且需要检查很多业务逻辑，调用很多不同的查询方法，接口性能需控制在 300ms，所以应当控制多少个 Lot 去处理。\n\n\n\n#### Do Action\n\n当经过一系列的检查逻辑之后，该 Lot 满足执行 Reassign 操作，在执行 Reassign 之前还将触发某些 Action ，eg：当 Process A 100 直接 Reassign to Process A 400。具体可能触发  Hold，Future Reassign 等，这些 Action 需具体罗列出来，并且排列优先级去执行。当前站点可能多个 Action ，应当考虑先触发哪个，后触发哪个，或者哪些不会触发。 eg：400 站点有 Hold Action、Rework Action、Reassign Action。必须先触发 Hold，\n\n然而 Rework 和 Reassign 哪个先执行呢，这个很让人头大，因为这两个 Action 只会先执行其中一个，如果先执行 Rework，那么回到了 400 前的站点，同时删除 Rework Action，当又到达 400 站点的时候，Rework Action 不存在，这个时候就会执行 Reassign。那假设先执行的 Reassign ，Lot 可能已经不在当前 Flow 了，如果用户勾选了删除 Future Action，那么 Rework 永远不会执行。如果未勾选会 Copy Rework Action，参考下图：\n\n但如果 A 400 到 B 400 之后是不会触发 Copy 的 Action，此时 Copy 对当前 Lot 没有意义。关于执行优先级需要沟通，根据业务场景定好优先级。因为触发顺序不一样，结果也不一样。\n\n![1fb33840e007d2cb619fc2ace11dd958.png](https://img.gejiba.com/images/1fb33840e007d2cb619fc2ace11dd958.png)\n\n如果 Process A 的 100 站点 Reassign to Process B 的 200 站点设置了 Future Action，那么将触发该 Action。\n\n有一种特殊情况，就是 B Flow 的 200 站点 Action 是 Future Reassign 并且指向的 A Flow 的 100 站点，那么又回到 Reassign 之前的 Flow A，这种操作就会毫无意义，界面应该给予友好提示。更糟糕的事是如果 A Flow 的 100 站点同样设置了 Future Reassign to B  Flow 200，那么将导致死循环。B 200 跳 A 100，A 100 跳 B 200。为了避免这种事情发生，如果 A 100 设置了 Future Reassign to B 200，那么 B 200 是不能设置 Future Reassign to A 100。\n\n![c9203e83b558854ceee83791060af954.png](https://img.gejiba.com/images/c9203e83b558854ceee83791060af954.png)\n\n这里模拟了几种执行 Action 情况，还有很多情况需要考虑，例如 FSM（Future Split & Merger）等。\n\n\n\n#### Copy Action\n\n参考上图，如果原 Flow 的站点和目标 Flow 的站点对应，将原 Flow 站点的 Action 进行 Copy。Copy 的时候需要检查目标站点是否发生变化，如果此时站点已经更新了，400 站点不存在，那么应 Hold 原 Flow 当站 100，并且给予提示。\n\n\n\n#### Do Reassign\n\n这一步之前仍然需要 Check 目标信息是否存在，如果不存在 Hold 当站，并且给予提示。将进行 Product Change 或者 Version Up 或者 Flow 的变更操作，之后就是写入历史记录。如果某个 Lot 正在加工中，具有 Control Job\n\n那么会创建一条 Future Reassign，也就是 Post Reassign。\n\n![71ae22434c908489f4eb8106ff4d4953.png](https://img.gejiba.com/images/71ae22434c908489f4eb8106ff4d4953.png) \n\n#### Post Reassign\n\n当前 Lot 已经进入机台正在加工中，这个时候是不能进行 Reassign 操作的，但是会默认创建一条 Future Reassign 的数据，Lot Move out 的时候再去执行这条数据。这里有几点要注意，因为这种情况 200 站点已经创建了一条 Future Reassign ，那么界面上不能手动再去创建 200 站点的 Future Reassign。一个站点只能有一条 Future Reassign 数据。因为是先创建数据，然后再去执行，所以执行的时候需要 Check 数据信息的正确性。如果目标站点不存在那么需要 Hold 当站，并且给予提示。\n\n![437b42ecaedae43ee2c623c55ad9db0f.png](https://img.gejiba.com/images/437b42ecaedae43ee2c623c55ad9db0f.png)\n\n\n\n#### Future Reassign\n\n未来执行的 Reassign 操作，可以提前设置。当 Lot 进行 Move Out （移出机台）或者 Pass Thu （过站）等操作的时候，会异步执行 Reassign 操作。有些 Main Process （主要的业务操作）有很多 Post Process（异步操作），例如 Move Out 可能会有以下异步操作。\n\n![dc0b99d09e34722f9f0cf444997e5aca.png](https://img.gejiba.com/images/dc0b99d09e34722f9f0cf444997e5aca.png)\n\nFuture Reassign 也属于其中一种，如果 Future Reassign 在 Check 阶段失败了，那么应当怎么处理。因为它是\n\n异步操作，没有和主逻辑在同一个事务，Future Reassign 失败了，Move Out 还是成功的。并且如果 Process Move 这个操作在 Future Reassign 之前，那么还会到下个站点。这种情况不符合业务场景，Future Reassign 失败了应该 Hold 当站，不能移动到下个站点，而且界面应当具备可以查看哪些异步操作是成功，哪些是失败，失败原因是什么。在 Future Reassign 中 Hold 方法和 Check 方法是同一个事务，Check 方法失败抛异常会导致 Hold 方法事务回滚，所以没有办法去 Hold 当站。（可以通过环境变量去控制，这个我会在之后的 Post Process 文章详细介绍）。\n\n界面支持手动创建和删除 Future Reassign。\n\n#### History\n\nNA\n\n### 界面设计\n\n#### 条件查询区域\n\nFrom 区域：用户可以根据 Product、Process、Route、Lot 四个之一去查询，例如 Process 下拉框，下拉会查询所有的 Process 数据，如果用户先选择 Product，那么需联动出来对应的 Process 和 Route 数据，如果有一对多关系，需用户手动选择，如果只有一个，默认带出。可以查询 Active 和非 Active 的数据。\n\nTo 区域：只能查询 Active 的数据，并且只能联动，不能单个下拉查询。\n\n\n\n#### 是否删除 Future Action\n\nProduct Change 和 Version Up 默认不勾选，因为这两种情况一般不会改变 Flow ，所以保持原样。\n\nReassign 默认勾选删除，因为会从当前 Flow 改变到其它 Flow。当前 Flow 的 Action 对应该 Lot 是\n\n没有意义的，需要 Copy 到新的 Flow 上。\n\n\n\n####  查询的数据列表区域\n\n默认查所有，暂时不支持分页。可以下拉选择然后添加到右边列表。\n\n\n\n#### 添加\n\n如果单选框选择的是 Product Change，那么添加的时候只能添加相同 Process 的数据。\n\n保持 Flow 不变，仅仅改变 Product 。\n\n如果选择的是 Version Up，那么 Lot 的 Product、Process、Route 必须一致才能添加。\n\n如果选择的是 Reassign ，无需卡控，查询出来的数据都能添加到右边列表中。\n\n\n\n![fc89d8b2b53d567e77dc9c03386f4d04.png](https://img.gejiba.com/images/fc89d8b2b53d567e77dc9c03386f4d04.png)\n\n### 接口设计\n\nNA\n\n### 数据库设计\n\n\n#### PD \n\n图中一个个原点表示（Process Define 数据）\n\n#### PF\n\n一个原点与原点直接的黑色实线表示 PF（记录 PD 的下级所属关系表）\n\n其中有个字段 LEVEL，有以下三种值\n\n- Main_Mod（Process 与 Route 关系）\n- Main_Ope（Process 与 Step 关系）\n- Module（Route 与 Step 关系）\n\nPF_Route 、PF_Step 表示具体的信息。\n\n#### POS \n\nStep 配置信息\n\n#### PO\n\nProcess Operation 运行时数据 \n\n\n\n\n\n![a2be5408ea04bcf4ce341d0a10809ff7.png](https://img.gejiba.com/images/a2be5408ea04bcf4ce341d0a10809ff7.png)\n","slug":"LotReassign","published":1,"updated":"2022-05-10T04:18:33.068Z","_id":"cl2yhjkqe00003kln6lxtedx1","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在北京中芯国际出差这段日子，主要负责了 Lot Reassign 这个功能模块，同时也了解了 EDC 这个功能模块，我会在之后的文章介绍。</p>\n<h3 id=\"功能描述\"><a href=\"#功能描述\" class=\"headerlink\" title=\"功能描述\"></a>功能描述</h3><h4 id=\"Lot-Reassign-分为三个功能模块：\"><a href=\"#Lot-Reassign-分为三个功能模块：\" class=\"headerlink\" title=\"Lot Reassign 分为三个功能模块：\"></a>Lot Reassign 分为三个功能模块：</h4><ol>\n<li>Only Product Change</li>\n<li>Lot Reassign</li>\n<li>Only Version Up</li>\n</ol>\n<h4 id=\"Lot-Reassign\"><a href=\"#Lot-Reassign\" class=\"headerlink\" title=\"Lot Reassign\"></a>Lot Reassign</h4><p>Lot Reassign 主要是对当前 Lot 进行 Product、Process 、Route、 Step 进行更改。</p>\n<p>下图是 Process、Route 及 Step 的关系图，可以理解为工艺、工步、工序。</p>\n<p>Process、Route、Step 在 MDS 进行配置。</p>\n<p><img src=\"https://img.gejiba.com/images/a2be5408ea04bcf4ce341d0a10809ff7.png\" alt=\"a2be5408ea04bcf4ce341d0a10809ff7.png\"></p>\n<h4 id=\"Only-Product-Change\"><a href=\"#Only-Product-Change\" class=\"headerlink\" title=\"Only Product Change\"></a>Only Product Change</h4><p>对 Lot 的 Product 信息进行改变，Product 信息 在 MDS 系统进行配置，可以配置当前 Product 和 升版的 Product 及 Active 的 Product，eg：ProductA.1、ProductA.2（Active）。如果对某个 Lot 进行 Product Change 那么默认取 Active 的最高版本的 Product。</p>\n<p>如果 Product 对应的 Process、Route 及 Step 有 Active 并且升版的数据，那么默认也要取这些数据进行Update。</p>\n<h4 id=\"Only-Version-Up\"><a href=\"#Only-Version-Up\" class=\"headerlink\" title=\"Only Version Up\"></a>Only Version Up</h4><p>仅仅对 Lot 的 Product、Process、Route、Step 进行升版（版本应该处于 Active 状态）。</p>\n<h3 id=\"详细设计\"><a href=\"#详细设计\" class=\"headerlink\" title=\"详细设计\"></a>详细设计</h3><h4 id=\"Future-Action\"><a href=\"#Future-Action\" class=\"headerlink\" title=\"Future Action\"></a>Future Action</h4><p>针对这三个功能，它们有着公共的需要处理的业务场景就是 Future Action，</p>\n<p>eg：Future Hold，Future Rework，Future Merger、Future Split、Future Reassign。</p>\n<p>如下图：绿色区域表示 Lot 所在 Step ，红色区域表示未来发生的动作。如果用户勾选删除 Future Action 复选框，进行 Reassign 之前应当提示用户 Lot 的 Process 有哪些 Future Action 会失效。Process A 切换到 Process B ，400 站点的 Future Action 会失效，如果用户未勾选，那么将进行 Copy，Process B 的 400 站点也将设置相同的 Future Action。</p>\n<p><img src=\"https://img.gejiba.com/images/c9203e83b558854ceee83791060af954.png\" alt=\"c9203e83b558854ceee83791060af954.png\"></p>\n<h4 id=\"Check\"><a href=\"#Check\" class=\"headerlink\" title=\"Check\"></a>Check</h4><p>在执行这三个功能的前置动作除了 Future Action 提示外，还将进行一系列的 Check 操作，eg：检查 Lot 的状态是否处于 Hold 状态，是否是要生产的 Lot（可能已经报废，终止，完成）等，是否正在进行加工中，是否处于异步执行等逻辑。这些检查逻辑需要详细的罗列出来，并且检查顺序要有一个优先级。当不满足某个条件，应当立即返回提示信息。因为界面支持批量，对多个 Lot 进行 Reassign 操作，所以 Check 之后应当提示哪些 Lot 是成功的，哪些是失败的及失败原因。这里存在性能问题，因为是批量，并且需要检查很多业务逻辑，调用很多不同的查询方法，接口性能需控制在 300ms，所以应当控制多少个 Lot 去处理。</p>\n<h4 id=\"Do-Action\"><a href=\"#Do-Action\" class=\"headerlink\" title=\"Do Action\"></a>Do Action</h4><p>当经过一系列的检查逻辑之后，该 Lot 满足执行 Reassign 操作，在执行 Reassign 之前还将触发某些 Action ，eg：当 Process A 100 直接 Reassign to Process A 400。具体可能触发  Hold，Future Reassign 等，这些 Action 需具体罗列出来，并且排列优先级去执行。当前站点可能多个 Action ，应当考虑先触发哪个，后触发哪个，或者哪些不会触发。 eg：400 站点有 Hold Action、Rework Action、Reassign Action。必须先触发 Hold，</p>\n<p>然而 Rework 和 Reassign 哪个先执行呢，这个很让人头大，因为这两个 Action 只会先执行其中一个，如果先执行 Rework，那么回到了 400 前的站点，同时删除 Rework Action，当又到达 400 站点的时候，Rework Action 不存在，这个时候就会执行 Reassign。那假设先执行的 Reassign ，Lot 可能已经不在当前 Flow 了，如果用户勾选了删除 Future Action，那么 Rework 永远不会执行。如果未勾选会 Copy Rework Action，参考下图：</p>\n<p>但如果 A 400 到 B 400 之后是不会触发 Copy 的 Action，此时 Copy 对当前 Lot 没有意义。关于执行优先级需要沟通，根据业务场景定好优先级。因为触发顺序不一样，结果也不一样。</p>\n<p><img src=\"https://img.gejiba.com/images/1fb33840e007d2cb619fc2ace11dd958.png\" alt=\"1fb33840e007d2cb619fc2ace11dd958.png\"></p>\n<p>如果 Process A 的 100 站点 Reassign to Process B 的 200 站点设置了 Future Action，那么将触发该 Action。</p>\n<p>有一种特殊情况，就是 B Flow 的 200 站点 Action 是 Future Reassign 并且指向的 A Flow 的 100 站点，那么又回到 Reassign 之前的 Flow A，这种操作就会毫无意义，界面应该给予友好提示。更糟糕的事是如果 A Flow 的 100 站点同样设置了 Future Reassign to B  Flow 200，那么将导致死循环。B 200 跳 A 100，A 100 跳 B 200。为了避免这种事情发生，如果 A 100 设置了 Future Reassign to B 200，那么 B 200 是不能设置 Future Reassign to A 100。</p>\n<p><img src=\"https://img.gejiba.com/images/c9203e83b558854ceee83791060af954.png\" alt=\"c9203e83b558854ceee83791060af954.png\"></p>\n<p>这里模拟了几种执行 Action 情况，还有很多情况需要考虑，例如 FSM（Future Split &amp; Merger）等。</p>\n<h4 id=\"Copy-Action\"><a href=\"#Copy-Action\" class=\"headerlink\" title=\"Copy Action\"></a>Copy Action</h4><p>参考上图，如果原 Flow 的站点和目标 Flow 的站点对应，将原 Flow 站点的 Action 进行 Copy。Copy 的时候需要检查目标站点是否发生变化，如果此时站点已经更新了，400 站点不存在，那么应 Hold 原 Flow 当站 100，并且给予提示。</p>\n<h4 id=\"Do-Reassign\"><a href=\"#Do-Reassign\" class=\"headerlink\" title=\"Do Reassign\"></a>Do Reassign</h4><p>这一步之前仍然需要 Check 目标信息是否存在，如果不存在 Hold 当站，并且给予提示。将进行 Product Change 或者 Version Up 或者 Flow 的变更操作，之后就是写入历史记录。如果某个 Lot 正在加工中，具有 Control Job</p>\n<p>那么会创建一条 Future Reassign，也就是 Post Reassign。</p>\n<p><img src=\"https://img.gejiba.com/images/71ae22434c908489f4eb8106ff4d4953.png\" alt=\"71ae22434c908489f4eb8106ff4d4953.png\"> </p>\n<h4 id=\"Post-Reassign\"><a href=\"#Post-Reassign\" class=\"headerlink\" title=\"Post Reassign\"></a>Post Reassign</h4><p>当前 Lot 已经进入机台正在加工中，这个时候是不能进行 Reassign 操作的，但是会默认创建一条 Future Reassign 的数据，Lot Move out 的时候再去执行这条数据。这里有几点要注意，因为这种情况 200 站点已经创建了一条 Future Reassign ，那么界面上不能手动再去创建 200 站点的 Future Reassign。一个站点只能有一条 Future Reassign 数据。因为是先创建数据，然后再去执行，所以执行的时候需要 Check 数据信息的正确性。如果目标站点不存在那么需要 Hold 当站，并且给予提示。</p>\n<p><img src=\"https://img.gejiba.com/images/437b42ecaedae43ee2c623c55ad9db0f.png\" alt=\"437b42ecaedae43ee2c623c55ad9db0f.png\"></p>\n<h4 id=\"Future-Reassign\"><a href=\"#Future-Reassign\" class=\"headerlink\" title=\"Future Reassign\"></a>Future Reassign</h4><p>未来执行的 Reassign 操作，可以提前设置。当 Lot 进行 Move Out （移出机台）或者 Pass Thu （过站）等操作的时候，会异步执行 Reassign 操作。有些 Main Process （主要的业务操作）有很多 Post Process（异步操作），例如 Move Out 可能会有以下异步操作。</p>\n<p><img src=\"https://img.gejiba.com/images/dc0b99d09e34722f9f0cf444997e5aca.png\" alt=\"dc0b99d09e34722f9f0cf444997e5aca.png\"></p>\n<p>Future Reassign 也属于其中一种，如果 Future Reassign 在 Check 阶段失败了，那么应当怎么处理。因为它是</p>\n<p>异步操作，没有和主逻辑在同一个事务，Future Reassign 失败了，Move Out 还是成功的。并且如果 Process Move 这个操作在 Future Reassign 之前，那么还会到下个站点。这种情况不符合业务场景，Future Reassign 失败了应该 Hold 当站，不能移动到下个站点，而且界面应当具备可以查看哪些异步操作是成功，哪些是失败，失败原因是什么。在 Future Reassign 中 Hold 方法和 Check 方法是同一个事务，Check 方法失败抛异常会导致 Hold 方法事务回滚，所以没有办法去 Hold 当站。（可以通过环境变量去控制，这个我会在之后的 Post Process 文章详细介绍）。</p>\n<p>界面支持手动创建和删除 Future Reassign。</p>\n<h4 id=\"History\"><a href=\"#History\" class=\"headerlink\" title=\"History\"></a>History</h4><p>NA</p>\n<h3 id=\"界面设计\"><a href=\"#界面设计\" class=\"headerlink\" title=\"界面设计\"></a>界面设计</h3><h4 id=\"条件查询区域\"><a href=\"#条件查询区域\" class=\"headerlink\" title=\"条件查询区域\"></a>条件查询区域</h4><p>From 区域：用户可以根据 Product、Process、Route、Lot 四个之一去查询，例如 Process 下拉框，下拉会查询所有的 Process 数据，如果用户先选择 Product，那么需联动出来对应的 Process 和 Route 数据，如果有一对多关系，需用户手动选择，如果只有一个，默认带出。可以查询 Active 和非 Active 的数据。</p>\n<p>To 区域：只能查询 Active 的数据，并且只能联动，不能单个下拉查询。</p>\n<h4 id=\"是否删除-Future-Action\"><a href=\"#是否删除-Future-Action\" class=\"headerlink\" title=\"是否删除 Future Action\"></a>是否删除 Future Action</h4><p>Product Change 和 Version Up 默认不勾选，因为这两种情况一般不会改变 Flow ，所以保持原样。</p>\n<p>Reassign 默认勾选删除，因为会从当前 Flow 改变到其它 Flow。当前 Flow 的 Action 对应该 Lot 是</p>\n<p>没有意义的，需要 Copy 到新的 Flow 上。</p>\n<h4 id=\"查询的数据列表区域\"><a href=\"#查询的数据列表区域\" class=\"headerlink\" title=\"查询的数据列表区域\"></a>查询的数据列表区域</h4><p>默认查所有，暂时不支持分页。可以下拉选择然后添加到右边列表。</p>\n<h4 id=\"添加\"><a href=\"#添加\" class=\"headerlink\" title=\"添加\"></a>添加</h4><p>如果单选框选择的是 Product Change，那么添加的时候只能添加相同 Process 的数据。</p>\n<p>保持 Flow 不变，仅仅改变 Product 。</p>\n<p>如果选择的是 Version Up，那么 Lot 的 Product、Process、Route 必须一致才能添加。</p>\n<p>如果选择的是 Reassign ，无需卡控，查询出来的数据都能添加到右边列表中。</p>\n<p><img src=\"https://img.gejiba.com/images/fc89d8b2b53d567e77dc9c03386f4d04.png\" alt=\"fc89d8b2b53d567e77dc9c03386f4d04.png\"></p>\n<h3 id=\"接口设计\"><a href=\"#接口设计\" class=\"headerlink\" title=\"接口设计\"></a>接口设计</h3><p>NA</p>\n<h3 id=\"数据库设计\"><a href=\"#数据库设计\" class=\"headerlink\" title=\"数据库设计\"></a>数据库设计</h3><h4 id=\"PD\"><a href=\"#PD\" class=\"headerlink\" title=\"PD\"></a>PD</h4><p>图中一个个原点表示（Process Define 数据）</p>\n<h4 id=\"PF\"><a href=\"#PF\" class=\"headerlink\" title=\"PF\"></a>PF</h4><p>一个原点与原点直接的黑色实线表示 PF（记录 PD 的下级所属关系表）</p>\n<p>其中有个字段 LEVEL，有以下三种值</p>\n<ul>\n<li>Main_Mod（Process 与 Route 关系）</li>\n<li>Main_Ope（Process 与 Step 关系）</li>\n<li>Module（Route 与 Step 关系）</li>\n</ul>\n<p>PF_Route 、PF_Step 表示具体的信息。</p>\n<h4 id=\"POS\"><a href=\"#POS\" class=\"headerlink\" title=\"POS\"></a>POS</h4><p>Step 配置信息</p>\n<h4 id=\"PO\"><a href=\"#PO\" class=\"headerlink\" title=\"PO\"></a>PO</h4><p>Process Operation 运行时数据 </p>\n<p><img src=\"https://img.gejiba.com/images/a2be5408ea04bcf4ce341d0a10809ff7.png\" alt=\"a2be5408ea04bcf4ce341d0a10809ff7.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在北京中芯国际出差这段日子，主要负责了 Lot Reassign 这个功能模块，同时也了解了 EDC 这个功能模块，我会在之后的文章介绍。</p>\n<h3 id=\"功能描述\"><a href=\"#功能描述\" class=\"headerlink\" title=\"功能描述\"></a>功能描述</h3><h4 id=\"Lot-Reassign-分为三个功能模块：\"><a href=\"#Lot-Reassign-分为三个功能模块：\" class=\"headerlink\" title=\"Lot Reassign 分为三个功能模块：\"></a>Lot Reassign 分为三个功能模块：</h4><ol>\n<li>Only Product Change</li>\n<li>Lot Reassign</li>\n<li>Only Version Up</li>\n</ol>\n<h4 id=\"Lot-Reassign\"><a href=\"#Lot-Reassign\" class=\"headerlink\" title=\"Lot Reassign\"></a>Lot Reassign</h4><p>Lot Reassign 主要是对当前 Lot 进行 Product、Process 、Route、 Step 进行更改。</p>\n<p>下图是 Process、Route 及 Step 的关系图，可以理解为工艺、工步、工序。</p>\n<p>Process、Route、Step 在 MDS 进行配置。</p>\n<p><img src=\"https://img.gejiba.com/images/a2be5408ea04bcf4ce341d0a10809ff7.png\" alt=\"a2be5408ea04bcf4ce341d0a10809ff7.png\"></p>\n<h4 id=\"Only-Product-Change\"><a href=\"#Only-Product-Change\" class=\"headerlink\" title=\"Only Product Change\"></a>Only Product Change</h4><p>对 Lot 的 Product 信息进行改变，Product 信息 在 MDS 系统进行配置，可以配置当前 Product 和 升版的 Product 及 Active 的 Product，eg：ProductA.1、ProductA.2（Active）。如果对某个 Lot 进行 Product Change 那么默认取 Active 的最高版本的 Product。</p>\n<p>如果 Product 对应的 Process、Route 及 Step 有 Active 并且升版的数据，那么默认也要取这些数据进行Update。</p>\n<h4 id=\"Only-Version-Up\"><a href=\"#Only-Version-Up\" class=\"headerlink\" title=\"Only Version Up\"></a>Only Version Up</h4><p>仅仅对 Lot 的 Product、Process、Route、Step 进行升版（版本应该处于 Active 状态）。</p>\n<h3 id=\"详细设计\"><a href=\"#详细设计\" class=\"headerlink\" title=\"详细设计\"></a>详细设计</h3><h4 id=\"Future-Action\"><a href=\"#Future-Action\" class=\"headerlink\" title=\"Future Action\"></a>Future Action</h4><p>针对这三个功能，它们有着公共的需要处理的业务场景就是 Future Action，</p>\n<p>eg：Future Hold，Future Rework，Future Merger、Future Split、Future Reassign。</p>\n<p>如下图：绿色区域表示 Lot 所在 Step ，红色区域表示未来发生的动作。如果用户勾选删除 Future Action 复选框，进行 Reassign 之前应当提示用户 Lot 的 Process 有哪些 Future Action 会失效。Process A 切换到 Process B ，400 站点的 Future Action 会失效，如果用户未勾选，那么将进行 Copy，Process B 的 400 站点也将设置相同的 Future Action。</p>\n<p><img src=\"https://img.gejiba.com/images/c9203e83b558854ceee83791060af954.png\" alt=\"c9203e83b558854ceee83791060af954.png\"></p>\n<h4 id=\"Check\"><a href=\"#Check\" class=\"headerlink\" title=\"Check\"></a>Check</h4><p>在执行这三个功能的前置动作除了 Future Action 提示外，还将进行一系列的 Check 操作，eg：检查 Lot 的状态是否处于 Hold 状态，是否是要生产的 Lot（可能已经报废，终止，完成）等，是否正在进行加工中，是否处于异步执行等逻辑。这些检查逻辑需要详细的罗列出来，并且检查顺序要有一个优先级。当不满足某个条件，应当立即返回提示信息。因为界面支持批量，对多个 Lot 进行 Reassign 操作，所以 Check 之后应当提示哪些 Lot 是成功的，哪些是失败的及失败原因。这里存在性能问题，因为是批量，并且需要检查很多业务逻辑，调用很多不同的查询方法，接口性能需控制在 300ms，所以应当控制多少个 Lot 去处理。</p>\n<h4 id=\"Do-Action\"><a href=\"#Do-Action\" class=\"headerlink\" title=\"Do Action\"></a>Do Action</h4><p>当经过一系列的检查逻辑之后，该 Lot 满足执行 Reassign 操作，在执行 Reassign 之前还将触发某些 Action ，eg：当 Process A 100 直接 Reassign to Process A 400。具体可能触发  Hold，Future Reassign 等，这些 Action 需具体罗列出来，并且排列优先级去执行。当前站点可能多个 Action ，应当考虑先触发哪个，后触发哪个，或者哪些不会触发。 eg：400 站点有 Hold Action、Rework Action、Reassign Action。必须先触发 Hold，</p>\n<p>然而 Rework 和 Reassign 哪个先执行呢，这个很让人头大，因为这两个 Action 只会先执行其中一个，如果先执行 Rework，那么回到了 400 前的站点，同时删除 Rework Action，当又到达 400 站点的时候，Rework Action 不存在，这个时候就会执行 Reassign。那假设先执行的 Reassign ，Lot 可能已经不在当前 Flow 了，如果用户勾选了删除 Future Action，那么 Rework 永远不会执行。如果未勾选会 Copy Rework Action，参考下图：</p>\n<p>但如果 A 400 到 B 400 之后是不会触发 Copy 的 Action，此时 Copy 对当前 Lot 没有意义。关于执行优先级需要沟通，根据业务场景定好优先级。因为触发顺序不一样，结果也不一样。</p>\n<p><img src=\"https://img.gejiba.com/images/1fb33840e007d2cb619fc2ace11dd958.png\" alt=\"1fb33840e007d2cb619fc2ace11dd958.png\"></p>\n<p>如果 Process A 的 100 站点 Reassign to Process B 的 200 站点设置了 Future Action，那么将触发该 Action。</p>\n<p>有一种特殊情况，就是 B Flow 的 200 站点 Action 是 Future Reassign 并且指向的 A Flow 的 100 站点，那么又回到 Reassign 之前的 Flow A，这种操作就会毫无意义，界面应该给予友好提示。更糟糕的事是如果 A Flow 的 100 站点同样设置了 Future Reassign to B  Flow 200，那么将导致死循环。B 200 跳 A 100，A 100 跳 B 200。为了避免这种事情发生，如果 A 100 设置了 Future Reassign to B 200，那么 B 200 是不能设置 Future Reassign to A 100。</p>\n<p><img src=\"https://img.gejiba.com/images/c9203e83b558854ceee83791060af954.png\" alt=\"c9203e83b558854ceee83791060af954.png\"></p>\n<p>这里模拟了几种执行 Action 情况，还有很多情况需要考虑，例如 FSM（Future Split &amp; Merger）等。</p>\n<h4 id=\"Copy-Action\"><a href=\"#Copy-Action\" class=\"headerlink\" title=\"Copy Action\"></a>Copy Action</h4><p>参考上图，如果原 Flow 的站点和目标 Flow 的站点对应，将原 Flow 站点的 Action 进行 Copy。Copy 的时候需要检查目标站点是否发生变化，如果此时站点已经更新了，400 站点不存在，那么应 Hold 原 Flow 当站 100，并且给予提示。</p>\n<h4 id=\"Do-Reassign\"><a href=\"#Do-Reassign\" class=\"headerlink\" title=\"Do Reassign\"></a>Do Reassign</h4><p>这一步之前仍然需要 Check 目标信息是否存在，如果不存在 Hold 当站，并且给予提示。将进行 Product Change 或者 Version Up 或者 Flow 的变更操作，之后就是写入历史记录。如果某个 Lot 正在加工中，具有 Control Job</p>\n<p>那么会创建一条 Future Reassign，也就是 Post Reassign。</p>\n<p><img src=\"https://img.gejiba.com/images/71ae22434c908489f4eb8106ff4d4953.png\" alt=\"71ae22434c908489f4eb8106ff4d4953.png\"> </p>\n<h4 id=\"Post-Reassign\"><a href=\"#Post-Reassign\" class=\"headerlink\" title=\"Post Reassign\"></a>Post Reassign</h4><p>当前 Lot 已经进入机台正在加工中，这个时候是不能进行 Reassign 操作的，但是会默认创建一条 Future Reassign 的数据，Lot Move out 的时候再去执行这条数据。这里有几点要注意，因为这种情况 200 站点已经创建了一条 Future Reassign ，那么界面上不能手动再去创建 200 站点的 Future Reassign。一个站点只能有一条 Future Reassign 数据。因为是先创建数据，然后再去执行，所以执行的时候需要 Check 数据信息的正确性。如果目标站点不存在那么需要 Hold 当站，并且给予提示。</p>\n<p><img src=\"https://img.gejiba.com/images/437b42ecaedae43ee2c623c55ad9db0f.png\" alt=\"437b42ecaedae43ee2c623c55ad9db0f.png\"></p>\n<h4 id=\"Future-Reassign\"><a href=\"#Future-Reassign\" class=\"headerlink\" title=\"Future Reassign\"></a>Future Reassign</h4><p>未来执行的 Reassign 操作，可以提前设置。当 Lot 进行 Move Out （移出机台）或者 Pass Thu （过站）等操作的时候，会异步执行 Reassign 操作。有些 Main Process （主要的业务操作）有很多 Post Process（异步操作），例如 Move Out 可能会有以下异步操作。</p>\n<p><img src=\"https://img.gejiba.com/images/dc0b99d09e34722f9f0cf444997e5aca.png\" alt=\"dc0b99d09e34722f9f0cf444997e5aca.png\"></p>\n<p>Future Reassign 也属于其中一种，如果 Future Reassign 在 Check 阶段失败了，那么应当怎么处理。因为它是</p>\n<p>异步操作，没有和主逻辑在同一个事务，Future Reassign 失败了，Move Out 还是成功的。并且如果 Process Move 这个操作在 Future Reassign 之前，那么还会到下个站点。这种情况不符合业务场景，Future Reassign 失败了应该 Hold 当站，不能移动到下个站点，而且界面应当具备可以查看哪些异步操作是成功，哪些是失败，失败原因是什么。在 Future Reassign 中 Hold 方法和 Check 方法是同一个事务，Check 方法失败抛异常会导致 Hold 方法事务回滚，所以没有办法去 Hold 当站。（可以通过环境变量去控制，这个我会在之后的 Post Process 文章详细介绍）。</p>\n<p>界面支持手动创建和删除 Future Reassign。</p>\n<h4 id=\"History\"><a href=\"#History\" class=\"headerlink\" title=\"History\"></a>History</h4><p>NA</p>\n<h3 id=\"界面设计\"><a href=\"#界面设计\" class=\"headerlink\" title=\"界面设计\"></a>界面设计</h3><h4 id=\"条件查询区域\"><a href=\"#条件查询区域\" class=\"headerlink\" title=\"条件查询区域\"></a>条件查询区域</h4><p>From 区域：用户可以根据 Product、Process、Route、Lot 四个之一去查询，例如 Process 下拉框，下拉会查询所有的 Process 数据，如果用户先选择 Product，那么需联动出来对应的 Process 和 Route 数据，如果有一对多关系，需用户手动选择，如果只有一个，默认带出。可以查询 Active 和非 Active 的数据。</p>\n<p>To 区域：只能查询 Active 的数据，并且只能联动，不能单个下拉查询。</p>\n<h4 id=\"是否删除-Future-Action\"><a href=\"#是否删除-Future-Action\" class=\"headerlink\" title=\"是否删除 Future Action\"></a>是否删除 Future Action</h4><p>Product Change 和 Version Up 默认不勾选，因为这两种情况一般不会改变 Flow ，所以保持原样。</p>\n<p>Reassign 默认勾选删除，因为会从当前 Flow 改变到其它 Flow。当前 Flow 的 Action 对应该 Lot 是</p>\n<p>没有意义的，需要 Copy 到新的 Flow 上。</p>\n<h4 id=\"查询的数据列表区域\"><a href=\"#查询的数据列表区域\" class=\"headerlink\" title=\"查询的数据列表区域\"></a>查询的数据列表区域</h4><p>默认查所有，暂时不支持分页。可以下拉选择然后添加到右边列表。</p>\n<h4 id=\"添加\"><a href=\"#添加\" class=\"headerlink\" title=\"添加\"></a>添加</h4><p>如果单选框选择的是 Product Change，那么添加的时候只能添加相同 Process 的数据。</p>\n<p>保持 Flow 不变，仅仅改变 Product 。</p>\n<p>如果选择的是 Version Up，那么 Lot 的 Product、Process、Route 必须一致才能添加。</p>\n<p>如果选择的是 Reassign ，无需卡控，查询出来的数据都能添加到右边列表中。</p>\n<p><img src=\"https://img.gejiba.com/images/fc89d8b2b53d567e77dc9c03386f4d04.png\" alt=\"fc89d8b2b53d567e77dc9c03386f4d04.png\"></p>\n<h3 id=\"接口设计\"><a href=\"#接口设计\" class=\"headerlink\" title=\"接口设计\"></a>接口设计</h3><p>NA</p>\n<h3 id=\"数据库设计\"><a href=\"#数据库设计\" class=\"headerlink\" title=\"数据库设计\"></a>数据库设计</h3><h4 id=\"PD\"><a href=\"#PD\" class=\"headerlink\" title=\"PD\"></a>PD</h4><p>图中一个个原点表示（Process Define 数据）</p>\n<h4 id=\"PF\"><a href=\"#PF\" class=\"headerlink\" title=\"PF\"></a>PF</h4><p>一个原点与原点直接的黑色实线表示 PF（记录 PD 的下级所属关系表）</p>\n<p>其中有个字段 LEVEL，有以下三种值</p>\n<ul>\n<li>Main_Mod（Process 与 Route 关系）</li>\n<li>Main_Ope（Process 与 Step 关系）</li>\n<li>Module（Route 与 Step 关系）</li>\n</ul>\n<p>PF_Route 、PF_Step 表示具体的信息。</p>\n<h4 id=\"POS\"><a href=\"#POS\" class=\"headerlink\" title=\"POS\"></a>POS</h4><p>Step 配置信息</p>\n<h4 id=\"PO\"><a href=\"#PO\" class=\"headerlink\" title=\"PO\"></a>PO</h4><p>Process Operation 运行时数据 </p>\n<p><img src=\"https://img.gejiba.com/images/a2be5408ea04bcf4ce341d0a10809ff7.png\" alt=\"a2be5408ea04bcf4ce341d0a10809ff7.png\"></p>\n"},{"title":"HJ30字符串合并处理","date":"2022-05-11T01:57:03.000Z","_content":"\n## 描述\n\n按照指定规则对输入的字符串进行处理。\n\n详细描述：\n\n第一步：将输入的两个字符串 str1 和 str2 进行前后合并。如给定字符串  \"dec\"  和字符串  \"fab\" ， 合并后生成的字符串为  \"decfab\"。\n\n第二步：对合并后的字符串进行排序，要求为：下标为奇数的字符和下标为偶数的字符分别从小到大排序。这里的下标的意思是字符在字符串中的位置。注意排序后在新串中仍需要保持原来的奇偶性。例如刚刚得到的字符串 “decfab”，分别对下标为偶数的字符 'd'、'c'、'a' 和下标为奇数的字符 'e'、'f'、'b' 进行排序（生成  'a'、'c'、'd' 和 'b' 、'e' 、'f' ），再依次分别放回原串中的偶数位和奇数位，新字符串变为 “abcedf”。\n\n第三步：对排序后的字符串中的 '0' 到 '9'、'A' 到 'F' 和 'a'到 'f' 字符，需要进行转换操作。\n\n转换规则如下：\n\n对以上需要进行转换的字符所代表的十六进制用二进制表示并倒序，然后再转换成对应的十六进制大写字符（注：字符 a 到 f 的十六进制对应十进制的10 到 15，大写同理）。\n\n如字符 '4'，其二进制为 0100 ，则翻转后为 0010 ，也就是 2 。转换后的字符为 '2'。\n\n如字符 ‘7’，其二进制为 0111 ，则翻转后为 1110 ，对应的十进制是14，转换为十六进制的大写字母为 'E'。\n\n如字符 'C'，代表的十进制是 12 ，其二进制为 1100 ，则翻转后为 0011，也就是3。转换后的字符是 '3'。\n\n根据这个转换规则，由第二步生成的字符串 “abcedf” 转换后会生成字符串 \"5D37BF\"。\n\n数据范围：输入的字符串长度满足 1≤*n*≤100 \n\n\n\n### 输入描述：\n\n样例输入两个字符串，用空格隔开。\n\n### 输出描述：\n\n输出转化后的结果。\n\n## 示例1\n\n输入：\n\n```\ndec fab\n```\n\n输出：\n\n```\n5D37BF\n```\n\n## 示例2\n\n输入：\n\n```\nab CD\n```\n\n输出：\n\n```\n3B5D\n```\n\n说明：\n\n```\n合并后为abCD，按奇数位和偶数位排序后是CDab（请注意要按ascii码进行排序，所以C在a前面，D在b前面），转换后为3B5D       \n```\n\n## 示例3\n\n输入：\n\n```\nEqr v9oEb12U2ur4xu7rd931G1f50qDo\n```\n\n输出：\n\n```\n8084842CAE9B9G7D7BUFooqqrrrvuxu\n```\n\n\n\n## 题解\n\n![386e8979817cb5b5cd48d1136bbc147c.png](https://img.gejiba.com/images/386e8979817cb5b5cd48d1136bbc147c.png)\n\n\n\n\n\n```java\nimport java.util.*;\n\npublic class HJ30 {\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String firStr = \"\";\n        String secStr = \"\";\n        while (scanner.hasNext()) {\n            firStr = scanner.next();\n            secStr = scanner.next();\n            System.out.println(transform(firStr, secStr));\n        }\n    }\n\n    public static char[] transform(String fStr, String sStr) {\n        String conStr = fStr.concat(sStr);\n        int len = conStr.length();\n        // 奇数位\n        char[] oChars = new char[(len & 1) == 0 ? len / 2 : len / 2 + 1];\n        // 偶数位\n        char[] eChars = new char[len / 2];\n\n        for (int i = 0; i < conStr.length(); i++) {\n            if ((i & 1) == 0) {\n                oChars[i / 2] = conStr.charAt(i);\n            } else {\n                eChars[i / 2] = conStr.charAt(i);\n            }\n        }\n        Arrays.sort(oChars);\n        Arrays.sort(eChars);\n        // 奇数和偶数归位\n        char[] newChars = new char[len];\n        for (int i = 0; i < oChars.length; i++) {\n            System.arraycopy(oChars, i, newChars, i * 2,\n                    1);\n            if (i < eChars.length) {\n                System.arraycopy(eChars, i, newChars, i * 2 + 1,\n                        1);\n            }\n        }\n        for (int i = 0; i < newChars.length; i++) {\n            char c = newChars[i];\n            if (String.valueOf(newChars[i]).matches(\"[A-Fa-f0-9]\")) {\n                // 8 -> 1000 -> 1 （16转2，再反转）\n                String s = new StringBuffer(Integer.toBinaryString(\n                        Integer.valueOf(Character.toString(newChars[i]), 16))).reverse().toString();\n                // 1 -> 1000（拼4位）\n                s = s.concat(\"0000\").substring(0, 4);\n                // 1000 -> 1 （转16进制）\n                c = Integer.toHexString(Integer.valueOf(s, 2)).toCharArray()[0];\n                // 是字母\n                if (Character.isLetter(c)) {\n                    newChars[i] = Character.toUpperCase(c);\n                } else {\n                    newChars[i] = c;\n                }\n            } else {\n                newChars[i] = c;\n            }\n        }\n        return newChars;\n    }\n}\n\n```\n\n\n\n","source":"_posts/HJ30字符串合并处理.md","raw":"---\ntitle: HJ30字符串合并处理\ndate: 2022-05-11 09:57:03\ntags: 牛客网华为题目\n---\n\n## 描述\n\n按照指定规则对输入的字符串进行处理。\n\n详细描述：\n\n第一步：将输入的两个字符串 str1 和 str2 进行前后合并。如给定字符串  \"dec\"  和字符串  \"fab\" ， 合并后生成的字符串为  \"decfab\"。\n\n第二步：对合并后的字符串进行排序，要求为：下标为奇数的字符和下标为偶数的字符分别从小到大排序。这里的下标的意思是字符在字符串中的位置。注意排序后在新串中仍需要保持原来的奇偶性。例如刚刚得到的字符串 “decfab”，分别对下标为偶数的字符 'd'、'c'、'a' 和下标为奇数的字符 'e'、'f'、'b' 进行排序（生成  'a'、'c'、'd' 和 'b' 、'e' 、'f' ），再依次分别放回原串中的偶数位和奇数位，新字符串变为 “abcedf”。\n\n第三步：对排序后的字符串中的 '0' 到 '9'、'A' 到 'F' 和 'a'到 'f' 字符，需要进行转换操作。\n\n转换规则如下：\n\n对以上需要进行转换的字符所代表的十六进制用二进制表示并倒序，然后再转换成对应的十六进制大写字符（注：字符 a 到 f 的十六进制对应十进制的10 到 15，大写同理）。\n\n如字符 '4'，其二进制为 0100 ，则翻转后为 0010 ，也就是 2 。转换后的字符为 '2'。\n\n如字符 ‘7’，其二进制为 0111 ，则翻转后为 1110 ，对应的十进制是14，转换为十六进制的大写字母为 'E'。\n\n如字符 'C'，代表的十进制是 12 ，其二进制为 1100 ，则翻转后为 0011，也就是3。转换后的字符是 '3'。\n\n根据这个转换规则，由第二步生成的字符串 “abcedf” 转换后会生成字符串 \"5D37BF\"。\n\n数据范围：输入的字符串长度满足 1≤*n*≤100 \n\n\n\n### 输入描述：\n\n样例输入两个字符串，用空格隔开。\n\n### 输出描述：\n\n输出转化后的结果。\n\n## 示例1\n\n输入：\n\n```\ndec fab\n```\n\n输出：\n\n```\n5D37BF\n```\n\n## 示例2\n\n输入：\n\n```\nab CD\n```\n\n输出：\n\n```\n3B5D\n```\n\n说明：\n\n```\n合并后为abCD，按奇数位和偶数位排序后是CDab（请注意要按ascii码进行排序，所以C在a前面，D在b前面），转换后为3B5D       \n```\n\n## 示例3\n\n输入：\n\n```\nEqr v9oEb12U2ur4xu7rd931G1f50qDo\n```\n\n输出：\n\n```\n8084842CAE9B9G7D7BUFooqqrrrvuxu\n```\n\n\n\n## 题解\n\n![386e8979817cb5b5cd48d1136bbc147c.png](https://img.gejiba.com/images/386e8979817cb5b5cd48d1136bbc147c.png)\n\n\n\n\n\n```java\nimport java.util.*;\n\npublic class HJ30 {\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String firStr = \"\";\n        String secStr = \"\";\n        while (scanner.hasNext()) {\n            firStr = scanner.next();\n            secStr = scanner.next();\n            System.out.println(transform(firStr, secStr));\n        }\n    }\n\n    public static char[] transform(String fStr, String sStr) {\n        String conStr = fStr.concat(sStr);\n        int len = conStr.length();\n        // 奇数位\n        char[] oChars = new char[(len & 1) == 0 ? len / 2 : len / 2 + 1];\n        // 偶数位\n        char[] eChars = new char[len / 2];\n\n        for (int i = 0; i < conStr.length(); i++) {\n            if ((i & 1) == 0) {\n                oChars[i / 2] = conStr.charAt(i);\n            } else {\n                eChars[i / 2] = conStr.charAt(i);\n            }\n        }\n        Arrays.sort(oChars);\n        Arrays.sort(eChars);\n        // 奇数和偶数归位\n        char[] newChars = new char[len];\n        for (int i = 0; i < oChars.length; i++) {\n            System.arraycopy(oChars, i, newChars, i * 2,\n                    1);\n            if (i < eChars.length) {\n                System.arraycopy(eChars, i, newChars, i * 2 + 1,\n                        1);\n            }\n        }\n        for (int i = 0; i < newChars.length; i++) {\n            char c = newChars[i];\n            if (String.valueOf(newChars[i]).matches(\"[A-Fa-f0-9]\")) {\n                // 8 -> 1000 -> 1 （16转2，再反转）\n                String s = new StringBuffer(Integer.toBinaryString(\n                        Integer.valueOf(Character.toString(newChars[i]), 16))).reverse().toString();\n                // 1 -> 1000（拼4位）\n                s = s.concat(\"0000\").substring(0, 4);\n                // 1000 -> 1 （转16进制）\n                c = Integer.toHexString(Integer.valueOf(s, 2)).toCharArray()[0];\n                // 是字母\n                if (Character.isLetter(c)) {\n                    newChars[i] = Character.toUpperCase(c);\n                } else {\n                    newChars[i] = c;\n                }\n            } else {\n                newChars[i] = c;\n            }\n        }\n        return newChars;\n    }\n}\n\n```\n\n\n\n","slug":"HJ30字符串合并处理","published":1,"updated":"2022-05-11T02:45:55.437Z","_id":"cl30z7gfq0000p0lnbjsn2q4r","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>按照指定规则对输入的字符串进行处理。</p>\n<p>详细描述：</p>\n<p>第一步：将输入的两个字符串 str1 和 str2 进行前后合并。如给定字符串  “dec”  和字符串  “fab” ， 合并后生成的字符串为  “decfab”。</p>\n<p>第二步：对合并后的字符串进行排序，要求为：下标为奇数的字符和下标为偶数的字符分别从小到大排序。这里的下标的意思是字符在字符串中的位置。注意排序后在新串中仍需要保持原来的奇偶性。例如刚刚得到的字符串 “decfab”，分别对下标为偶数的字符 ‘d’、’c’、’a’ 和下标为奇数的字符 ‘e’、’f’、’b’ 进行排序（生成  ‘a’、’c’、’d’ 和 ‘b’ 、’e’ 、’f’ ），再依次分别放回原串中的偶数位和奇数位，新字符串变为 “abcedf”。</p>\n<p>第三步：对排序后的字符串中的 ‘0’ 到 ‘9’、’A’ 到 ‘F’ 和 ‘a’到 ‘f’ 字符，需要进行转换操作。</p>\n<p>转换规则如下：</p>\n<p>对以上需要进行转换的字符所代表的十六进制用二进制表示并倒序，然后再转换成对应的十六进制大写字符（注：字符 a 到 f 的十六进制对应十进制的10 到 15，大写同理）。</p>\n<p>如字符 ‘4’，其二进制为 0100 ，则翻转后为 0010 ，也就是 2 。转换后的字符为 ‘2’。</p>\n<p>如字符 ‘7’，其二进制为 0111 ，则翻转后为 1110 ，对应的十进制是14，转换为十六进制的大写字母为 ‘E’。</p>\n<p>如字符 ‘C’，代表的十进制是 12 ，其二进制为 1100 ，则翻转后为 0011，也就是3。转换后的字符是 ‘3’。</p>\n<p>根据这个转换规则，由第二步生成的字符串 “abcedf” 转换后会生成字符串 “5D37BF”。</p>\n<p>数据范围：输入的字符串长度满足 1≤<em>n</em>≤100 </p>\n<h3 id=\"输入描述：\"><a href=\"#输入描述：\" class=\"headerlink\" title=\"输入描述：\"></a>输入描述：</h3><p>样例输入两个字符串，用空格隔开。</p>\n<h3 id=\"输出描述：\"><a href=\"#输出描述：\" class=\"headerlink\" title=\"输出描述：\"></a>输出描述：</h3><p>输出转化后的结果。</p>\n<h2 id=\"示例1\"><a href=\"#示例1\" class=\"headerlink\" title=\"示例1\"></a>示例1</h2><p>输入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dec fab</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5D37BF</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"示例2\"><a href=\"#示例2\" class=\"headerlink\" title=\"示例2\"></a>示例2</h2><p>输入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ab CD</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3B5D</span><br></pre></td></tr></table></figure>\n\n<p>说明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">合并后为abCD，按奇数位和偶数位排序后是CDab（请注意要按ascii码进行排序，所以C在a前面，D在b前面），转换后为3B5D       </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"示例3\"><a href=\"#示例3\" class=\"headerlink\" title=\"示例3\"></a>示例3</h2><p>输入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Eqr v9oEb12U2ur4xu7rd931G1f50qDo</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">8084842CAE9B9G7D7BUFooqqrrrvuxu</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p><img src=\"https://img.gejiba.com/images/386e8979817cb5b5cd48d1136bbc147c.png\" alt=\"386e8979817cb5b5cd48d1136bbc147c.png\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HJ30</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">firStr</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">secStr</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">            firStr = scanner.next();</span><br><span class=\"line\">            secStr = scanner.next();</span><br><span class=\"line\">            System.out.println(transform(firStr, secStr));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">char</span>[] transform(String fStr, String sStr) &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">conStr</span> <span class=\"operator\">=</span> fStr.concat(sStr);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> conStr.length();</span><br><span class=\"line\">        <span class=\"comment\">// 奇数位</span></span><br><span class=\"line\">        <span class=\"type\">char</span>[] oChars = <span class=\"keyword\">new</span> <span class=\"title class_\">char</span>[(len &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span> ? len / <span class=\"number\">2</span> : len / <span class=\"number\">2</span> + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"comment\">// 偶数位</span></span><br><span class=\"line\">        <span class=\"type\">char</span>[] eChars = <span class=\"keyword\">new</span> <span class=\"title class_\">char</span>[len / <span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; conStr.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((i &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                oChars[i / <span class=\"number\">2</span>] = conStr.charAt(i);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                eChars[i / <span class=\"number\">2</span>] = conStr.charAt(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Arrays.sort(oChars);</span><br><span class=\"line\">        Arrays.sort(eChars);</span><br><span class=\"line\">        <span class=\"comment\">// 奇数和偶数归位</span></span><br><span class=\"line\">        <span class=\"type\">char</span>[] newChars = <span class=\"keyword\">new</span> <span class=\"title class_\">char</span>[len];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; oChars.length; i++) &#123;</span><br><span class=\"line\">            System.arraycopy(oChars, i, newChars, i * <span class=\"number\">2</span>,</span><br><span class=\"line\">                    <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt; eChars.length) &#123;</span><br><span class=\"line\">                System.arraycopy(eChars, i, newChars, i * <span class=\"number\">2</span> + <span class=\"number\">1</span>,</span><br><span class=\"line\">                        <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; newChars.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> newChars[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (String.valueOf(newChars[i]).matches(<span class=\"string\">&quot;[A-Fa-f0-9]&quot;</span>)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 8 -&gt; 1000 -&gt; 1 （16转2，再反转）</span></span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>(Integer.toBinaryString(</span><br><span class=\"line\">                        Integer.valueOf(Character.toString(newChars[i]), <span class=\"number\">16</span>))).reverse().toString();</span><br><span class=\"line\">                <span class=\"comment\">// 1 -&gt; 1000（拼4位）</span></span><br><span class=\"line\">                s = s.concat(<span class=\"string\">&quot;0000&quot;</span>).substring(<span class=\"number\">0</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 1000 -&gt; 1 （转16进制）</span></span><br><span class=\"line\">                c = Integer.toHexString(Integer.valueOf(s, <span class=\"number\">2</span>)).toCharArray()[<span class=\"number\">0</span>];</span><br><span class=\"line\">                <span class=\"comment\">// 是字母</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Character.isLetter(c)) &#123;</span><br><span class=\"line\">                    newChars[i] = Character.toUpperCase(c);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    newChars[i] = c;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                newChars[i] = c;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newChars;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>按照指定规则对输入的字符串进行处理。</p>\n<p>详细描述：</p>\n<p>第一步：将输入的两个字符串 str1 和 str2 进行前后合并。如给定字符串  “dec”  和字符串  “fab” ， 合并后生成的字符串为  “decfab”。</p>\n<p>第二步：对合并后的字符串进行排序，要求为：下标为奇数的字符和下标为偶数的字符分别从小到大排序。这里的下标的意思是字符在字符串中的位置。注意排序后在新串中仍需要保持原来的奇偶性。例如刚刚得到的字符串 “decfab”，分别对下标为偶数的字符 ‘d’、’c’、’a’ 和下标为奇数的字符 ‘e’、’f’、’b’ 进行排序（生成  ‘a’、’c’、’d’ 和 ‘b’ 、’e’ 、’f’ ），再依次分别放回原串中的偶数位和奇数位，新字符串变为 “abcedf”。</p>\n<p>第三步：对排序后的字符串中的 ‘0’ 到 ‘9’、’A’ 到 ‘F’ 和 ‘a’到 ‘f’ 字符，需要进行转换操作。</p>\n<p>转换规则如下：</p>\n<p>对以上需要进行转换的字符所代表的十六进制用二进制表示并倒序，然后再转换成对应的十六进制大写字符（注：字符 a 到 f 的十六进制对应十进制的10 到 15，大写同理）。</p>\n<p>如字符 ‘4’，其二进制为 0100 ，则翻转后为 0010 ，也就是 2 。转换后的字符为 ‘2’。</p>\n<p>如字符 ‘7’，其二进制为 0111 ，则翻转后为 1110 ，对应的十进制是14，转换为十六进制的大写字母为 ‘E’。</p>\n<p>如字符 ‘C’，代表的十进制是 12 ，其二进制为 1100 ，则翻转后为 0011，也就是3。转换后的字符是 ‘3’。</p>\n<p>根据这个转换规则，由第二步生成的字符串 “abcedf” 转换后会生成字符串 “5D37BF”。</p>\n<p>数据范围：输入的字符串长度满足 1≤<em>n</em>≤100 </p>\n<h3 id=\"输入描述：\"><a href=\"#输入描述：\" class=\"headerlink\" title=\"输入描述：\"></a>输入描述：</h3><p>样例输入两个字符串，用空格隔开。</p>\n<h3 id=\"输出描述：\"><a href=\"#输出描述：\" class=\"headerlink\" title=\"输出描述：\"></a>输出描述：</h3><p>输出转化后的结果。</p>\n<h2 id=\"示例1\"><a href=\"#示例1\" class=\"headerlink\" title=\"示例1\"></a>示例1</h2><p>输入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dec fab</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5D37BF</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"示例2\"><a href=\"#示例2\" class=\"headerlink\" title=\"示例2\"></a>示例2</h2><p>输入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ab CD</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3B5D</span><br></pre></td></tr></table></figure>\n\n<p>说明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">合并后为abCD，按奇数位和偶数位排序后是CDab（请注意要按ascii码进行排序，所以C在a前面，D在b前面），转换后为3B5D       </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"示例3\"><a href=\"#示例3\" class=\"headerlink\" title=\"示例3\"></a>示例3</h2><p>输入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Eqr v9oEb12U2ur4xu7rd931G1f50qDo</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">8084842CAE9B9G7D7BUFooqqrrrvuxu</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p><img src=\"https://img.gejiba.com/images/386e8979817cb5b5cd48d1136bbc147c.png\" alt=\"386e8979817cb5b5cd48d1136bbc147c.png\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HJ30</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">firStr</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">secStr</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">            firStr = scanner.next();</span><br><span class=\"line\">            secStr = scanner.next();</span><br><span class=\"line\">            System.out.println(transform(firStr, secStr));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">char</span>[] transform(String fStr, String sStr) &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">conStr</span> <span class=\"operator\">=</span> fStr.concat(sStr);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> conStr.length();</span><br><span class=\"line\">        <span class=\"comment\">// 奇数位</span></span><br><span class=\"line\">        <span class=\"type\">char</span>[] oChars = <span class=\"keyword\">new</span> <span class=\"title class_\">char</span>[(len &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span> ? len / <span class=\"number\">2</span> : len / <span class=\"number\">2</span> + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"comment\">// 偶数位</span></span><br><span class=\"line\">        <span class=\"type\">char</span>[] eChars = <span class=\"keyword\">new</span> <span class=\"title class_\">char</span>[len / <span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; conStr.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((i &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                oChars[i / <span class=\"number\">2</span>] = conStr.charAt(i);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                eChars[i / <span class=\"number\">2</span>] = conStr.charAt(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Arrays.sort(oChars);</span><br><span class=\"line\">        Arrays.sort(eChars);</span><br><span class=\"line\">        <span class=\"comment\">// 奇数和偶数归位</span></span><br><span class=\"line\">        <span class=\"type\">char</span>[] newChars = <span class=\"keyword\">new</span> <span class=\"title class_\">char</span>[len];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; oChars.length; i++) &#123;</span><br><span class=\"line\">            System.arraycopy(oChars, i, newChars, i * <span class=\"number\">2</span>,</span><br><span class=\"line\">                    <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt; eChars.length) &#123;</span><br><span class=\"line\">                System.arraycopy(eChars, i, newChars, i * <span class=\"number\">2</span> + <span class=\"number\">1</span>,</span><br><span class=\"line\">                        <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; newChars.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> newChars[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (String.valueOf(newChars[i]).matches(<span class=\"string\">&quot;[A-Fa-f0-9]&quot;</span>)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 8 -&gt; 1000 -&gt; 1 （16转2，再反转）</span></span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>(Integer.toBinaryString(</span><br><span class=\"line\">                        Integer.valueOf(Character.toString(newChars[i]), <span class=\"number\">16</span>))).reverse().toString();</span><br><span class=\"line\">                <span class=\"comment\">// 1 -&gt; 1000（拼4位）</span></span><br><span class=\"line\">                s = s.concat(<span class=\"string\">&quot;0000&quot;</span>).substring(<span class=\"number\">0</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 1000 -&gt; 1 （转16进制）</span></span><br><span class=\"line\">                c = Integer.toHexString(Integer.valueOf(s, <span class=\"number\">2</span>)).toCharArray()[<span class=\"number\">0</span>];</span><br><span class=\"line\">                <span class=\"comment\">// 是字母</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Character.isLetter(c)) &#123;</span><br><span class=\"line\">                    newChars[i] = Character.toUpperCase(c);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    newChars[i] = c;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                newChars[i] = c;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newChars;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"HJ30合法IP","date":"2022-05-11T07:31:51.000Z","_content":"\n## 描述\n\nIPV4 地址可以用一个 32 位无符号整数来表示，一般用点分方式来显示，点将 IP 地址分成 4 个部分，每个部分为8 位，表示成一个无符号整数（因此正号不需要出现），如 10.137.17.1，是我们非常熟悉的IP地址，一个IP地址串中没有空格出现（因为要表示成一个 32 数字）。\n\n现在需要你用程序来判断IP是否合法。\n\n数据范围：数据组数：1≤*t*≤18 \n\n进阶：时间复杂度：O(n) ，空间复杂度：O(n)\n\n\n\n### 输入描述：\n\n输入一个ip地址，保证不包含空格\n\n### 输出描述：\n\n返回判断的结果YES or NO\n\n## 题解\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n// 测试数据 \n// a.1.1.1 \n// .1.1.1\n// 1.1.1.\n// 01.1.1.1\n// +1.1.1.1\npublic class HJ90 {\n    public static void main(String[] args) throws IOException {\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n        String str;\n        while ((str = bufferedReader.readLine()) != null) {\n            String result = checkIp(str);\n            System.out.println(result);\n        }\n    }\n\n    public static String checkIp(String str) {\n        String result = \"YES\";\n        String[] arrStr = str.split(\"\\\\.\");\n        if (arrStr.length != 4) {\n            result = \"NO\";\n        }\n        for (String ele : arrStr) {\n            if (ele.isEmpty() || ele.length() > 3) {\n                result = \"NO\";\n                break;\n            }\n            char[] chars = ele.toCharArray();\n            boolean flag = false;\n            for (int i = 0; i < chars.length; i++) {\n                if (!Character.isDigit(chars[i])) {\n                    result = \"NO\";\n                    flag = true;\n                    break;\n                }\n            }\n            if (flag) {\n                break;\n            }\n            if (chars.length > 1 && chars[0] == '0') {\n                result = \"NO\";\n                break;\n            }\n            int num = Integer.parseInt(ele);\n            if (num > 255 || num < 0) {\n                result = \"NO\";\n                break;\n            }\n        }\n        return result;\n    }\n}\n```\n\n","source":"_posts/HJ30合法IP.md","raw":"---\ntitle: HJ30合法IP\ndate: 2022-05-11 15:31:51\ntags: 牛客网华为题目\n---\n\n## 描述\n\nIPV4 地址可以用一个 32 位无符号整数来表示，一般用点分方式来显示，点将 IP 地址分成 4 个部分，每个部分为8 位，表示成一个无符号整数（因此正号不需要出现），如 10.137.17.1，是我们非常熟悉的IP地址，一个IP地址串中没有空格出现（因为要表示成一个 32 数字）。\n\n现在需要你用程序来判断IP是否合法。\n\n数据范围：数据组数：1≤*t*≤18 \n\n进阶：时间复杂度：O(n) ，空间复杂度：O(n)\n\n\n\n### 输入描述：\n\n输入一个ip地址，保证不包含空格\n\n### 输出描述：\n\n返回判断的结果YES or NO\n\n## 题解\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n// 测试数据 \n// a.1.1.1 \n// .1.1.1\n// 1.1.1.\n// 01.1.1.1\n// +1.1.1.1\npublic class HJ90 {\n    public static void main(String[] args) throws IOException {\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n        String str;\n        while ((str = bufferedReader.readLine()) != null) {\n            String result = checkIp(str);\n            System.out.println(result);\n        }\n    }\n\n    public static String checkIp(String str) {\n        String result = \"YES\";\n        String[] arrStr = str.split(\"\\\\.\");\n        if (arrStr.length != 4) {\n            result = \"NO\";\n        }\n        for (String ele : arrStr) {\n            if (ele.isEmpty() || ele.length() > 3) {\n                result = \"NO\";\n                break;\n            }\n            char[] chars = ele.toCharArray();\n            boolean flag = false;\n            for (int i = 0; i < chars.length; i++) {\n                if (!Character.isDigit(chars[i])) {\n                    result = \"NO\";\n                    flag = true;\n                    break;\n                }\n            }\n            if (flag) {\n                break;\n            }\n            if (chars.length > 1 && chars[0] == '0') {\n                result = \"NO\";\n                break;\n            }\n            int num = Integer.parseInt(ele);\n            if (num > 255 || num < 0) {\n                result = \"NO\";\n                break;\n            }\n        }\n        return result;\n    }\n}\n```\n\n","slug":"HJ30合法IP","published":1,"updated":"2022-05-11T08:09:26.853Z","_id":"cl319pqdp0000dklnb4z8hq07","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>IPV4 地址可以用一个 32 位无符号整数来表示，一般用点分方式来显示，点将 IP 地址分成 4 个部分，每个部分为8 位，表示成一个无符号整数（因此正号不需要出现），如 10.137.17.1，是我们非常熟悉的IP地址，一个IP地址串中没有空格出现（因为要表示成一个 32 数字）。</p>\n<p>现在需要你用程序来判断IP是否合法。</p>\n<p>数据范围：数据组数：1≤<em>t</em>≤18 </p>\n<p>进阶：时间复杂度：O(n) ，空间复杂度：O(n)</p>\n<h3 id=\"输入描述：\"><a href=\"#输入描述：\" class=\"headerlink\" title=\"输入描述：\"></a>输入描述：</h3><p>输入一个ip地址，保证不包含空格</p>\n<h3 id=\"输出描述：\"><a href=\"#输出描述：\" class=\"headerlink\" title=\"输出描述：\"></a>输出描述：</h3><p>返回判断的结果YES or NO</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.BufferedReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStreamReader;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试数据 </span></span><br><span class=\"line\"><span class=\"comment\">// a.1.1.1 </span></span><br><span class=\"line\"><span class=\"comment\">// .1.1.1</span></span><br><span class=\"line\"><span class=\"comment\">// 1.1.1.</span></span><br><span class=\"line\"><span class=\"comment\">// 01.1.1.1</span></span><br><span class=\"line\"><span class=\"comment\">// +1.1.1.1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HJ90</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">BufferedReader</span> <span class=\"variable\">bufferedReader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedReader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(System.in));</span><br><span class=\"line\">        String str;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((str = bufferedReader.readLine()) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> checkIp(str);</span><br><span class=\"line\">            System.out.println(result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">checkIp</span><span class=\"params\">(String str)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;YES&quot;</span>;</span><br><span class=\"line\">        String[] arrStr = str.split(<span class=\"string\">&quot;\\\\.&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arrStr.length != <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">            result = <span class=\"string\">&quot;NO&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String ele : arrStr) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ele.isEmpty() || ele.length() &gt; <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                result = <span class=\"string\">&quot;NO&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">char</span>[] chars = ele.toCharArray();</span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!Character.isDigit(chars[i])) &#123;</span><br><span class=\"line\">                    result = <span class=\"string\">&quot;NO&quot;</span>;</span><br><span class=\"line\">                    flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (chars.length &gt; <span class=\"number\">1</span> &amp;&amp; chars[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;0&#x27;</span>) &#123;</span><br><span class=\"line\">                result = <span class=\"string\">&quot;NO&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> Integer.parseInt(ele);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (num &gt; <span class=\"number\">255</span> || num &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                result = <span class=\"string\">&quot;NO&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>IPV4 地址可以用一个 32 位无符号整数来表示，一般用点分方式来显示，点将 IP 地址分成 4 个部分，每个部分为8 位，表示成一个无符号整数（因此正号不需要出现），如 10.137.17.1，是我们非常熟悉的IP地址，一个IP地址串中没有空格出现（因为要表示成一个 32 数字）。</p>\n<p>现在需要你用程序来判断IP是否合法。</p>\n<p>数据范围：数据组数：1≤<em>t</em>≤18 </p>\n<p>进阶：时间复杂度：O(n) ，空间复杂度：O(n)</p>\n<h3 id=\"输入描述：\"><a href=\"#输入描述：\" class=\"headerlink\" title=\"输入描述：\"></a>输入描述：</h3><p>输入一个ip地址，保证不包含空格</p>\n<h3 id=\"输出描述：\"><a href=\"#输出描述：\" class=\"headerlink\" title=\"输出描述：\"></a>输出描述：</h3><p>返回判断的结果YES or NO</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.BufferedReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStreamReader;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试数据 </span></span><br><span class=\"line\"><span class=\"comment\">// a.1.1.1 </span></span><br><span class=\"line\"><span class=\"comment\">// .1.1.1</span></span><br><span class=\"line\"><span class=\"comment\">// 1.1.1.</span></span><br><span class=\"line\"><span class=\"comment\">// 01.1.1.1</span></span><br><span class=\"line\"><span class=\"comment\">// +1.1.1.1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HJ90</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">BufferedReader</span> <span class=\"variable\">bufferedReader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedReader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(System.in));</span><br><span class=\"line\">        String str;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((str = bufferedReader.readLine()) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> checkIp(str);</span><br><span class=\"line\">            System.out.println(result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">checkIp</span><span class=\"params\">(String str)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;YES&quot;</span>;</span><br><span class=\"line\">        String[] arrStr = str.split(<span class=\"string\">&quot;\\\\.&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arrStr.length != <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">            result = <span class=\"string\">&quot;NO&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String ele : arrStr) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ele.isEmpty() || ele.length() &gt; <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                result = <span class=\"string\">&quot;NO&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">char</span>[] chars = ele.toCharArray();</span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!Character.isDigit(chars[i])) &#123;</span><br><span class=\"line\">                    result = <span class=\"string\">&quot;NO&quot;</span>;</span><br><span class=\"line\">                    flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (chars.length &gt; <span class=\"number\">1</span> &amp;&amp; chars[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;0&#x27;</span>) &#123;</span><br><span class=\"line\">                result = <span class=\"string\">&quot;NO&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> Integer.parseInt(ele);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (num &gt; <span class=\"number\">255</span> || num &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                result = <span class=\"string\">&quot;NO&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"HJ10字符个数统计","date":"2022-05-11T08:10:00.000Z","_content":"\n## 描述\n\n编写一个函数，计算字符串中含有的不同字符的个数。字符在 ASCII 码范围内( 0 ~ 127 ，包括 0 和 127 )，换行表示结束符，不算在字符里。不在范围内的不作统计。多个相同的字符只计算一次\n\n例如，对于字符串 abaca 而言，有 a、b、c 三种不同的字符，因此输出 3 。\n\n数据范围： 1≤*n*≤500 \n\n### 输入描述：\n\n输入一行没有空格的字符串。\n\n### 输出描述：\n\n输出 输入字符串 中范围在(0 ~ 127，包括0和127)字符的种数。\n\n## 题解\n\n```java\nimport java.util.Scanner;\n\npublic class HJ10 {\n    public static void main(String[] args) {\n        int[] c = new int[128];\n        Scanner scanner = new Scanner(System.in);\n        String str = scanner.nextLine();\n        int count = 0;\n        for (int i = 0; i < str.length(); i++) {\n            if (c[str.charAt(i)] == 0) {\n                count++;\n            }\n            c[str.charAt(i)] ++;\n        }\n        System.out.println(count);\n    }\n}\n\n```\n\n","source":"_posts/HJ10字符个数统计.md","raw":"---\ntitle: HJ10字符个数统计\ndate: 2022-05-11 16:10:00\ntags: 牛客网华为题目\n---\n\n## 描述\n\n编写一个函数，计算字符串中含有的不同字符的个数。字符在 ASCII 码范围内( 0 ~ 127 ，包括 0 和 127 )，换行表示结束符，不算在字符里。不在范围内的不作统计。多个相同的字符只计算一次\n\n例如，对于字符串 abaca 而言，有 a、b、c 三种不同的字符，因此输出 3 。\n\n数据范围： 1≤*n*≤500 \n\n### 输入描述：\n\n输入一行没有空格的字符串。\n\n### 输出描述：\n\n输出 输入字符串 中范围在(0 ~ 127，包括0和127)字符的种数。\n\n## 题解\n\n```java\nimport java.util.Scanner;\n\npublic class HJ10 {\n    public static void main(String[] args) {\n        int[] c = new int[128];\n        Scanner scanner = new Scanner(System.in);\n        String str = scanner.nextLine();\n        int count = 0;\n        for (int i = 0; i < str.length(); i++) {\n            if (c[str.charAt(i)] == 0) {\n                count++;\n            }\n            c[str.charAt(i)] ++;\n        }\n        System.out.println(count);\n    }\n}\n\n```\n\n","slug":"HJ10字符个数统计","published":1,"updated":"2022-05-11T08:11:39.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl31azf3f0000k4lne4hdf47q","content":"<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>编写一个函数，计算字符串中含有的不同字符的个数。字符在 ASCII 码范围内( 0 ~ 127 ，包括 0 和 127 )，换行表示结束符，不算在字符里。不在范围内的不作统计。多个相同的字符只计算一次</p>\n<p>例如，对于字符串 abaca 而言，有 a、b、c 三种不同的字符，因此输出 3 。</p>\n<p>数据范围： 1≤<em>n</em>≤500 </p>\n<h3 id=\"输入描述：\"><a href=\"#输入描述：\" class=\"headerlink\" title=\"输入描述：\"></a>输入描述：</h3><p>输入一行没有空格的字符串。</p>\n<h3 id=\"输出描述：\"><a href=\"#输出描述：\" class=\"headerlink\" title=\"输出描述：\"></a>输出描述：</h3><p>输出 输入字符串 中范围在(0 ~ 127，包括0和127)字符的种数。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HJ10</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] c = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">128</span>];</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> scanner.nextLine();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c[str.charAt(i)] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            c[str.charAt(i)] ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>编写一个函数，计算字符串中含有的不同字符的个数。字符在 ASCII 码范围内( 0 ~ 127 ，包括 0 和 127 )，换行表示结束符，不算在字符里。不在范围内的不作统计。多个相同的字符只计算一次</p>\n<p>例如，对于字符串 abaca 而言，有 a、b、c 三种不同的字符，因此输出 3 。</p>\n<p>数据范围： 1≤<em>n</em>≤500 </p>\n<h3 id=\"输入描述：\"><a href=\"#输入描述：\" class=\"headerlink\" title=\"输入描述：\"></a>输入描述：</h3><p>输入一行没有空格的字符串。</p>\n<h3 id=\"输出描述：\"><a href=\"#输出描述：\" class=\"headerlink\" title=\"输出描述：\"></a>输出描述：</h3><p>输出 输入字符串 中范围在(0 ~ 127，包括0和127)字符的种数。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HJ10</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] c = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">128</span>];</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> scanner.nextLine();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c[str.charAt(i)] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            c[str.charAt(i)] ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n"},{"title":"JVM","date":"2022-05-12T06:03:35.000Z","_content":"\n### 运行时数据区域\n\nHotSpot 虚拟机\n\n![61739beeb3810e7c2ae5e30bb5980584.png](https://img.gejiba.com/images/61739beeb3810e7c2ae5e30bb5980584.png)\n\nJAVA 1.8 移除方法区，移到了本地内存的元空间。\n\n![5249b2be8bc23b68fc0b388a0fcd1485.png](https://img.gejiba.com/images/5249b2be8bc23b68fc0b388a0fcd1485.png)\n\n\n\n### 程序计数器\n\n程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令、分支、循环、\n\n跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。为什么需要程序计数器？程序一般都是多线程执行，JVM多线程是通过 CPU 时间片切换来实现，如果某个线程在执行的过程中挂起，当再次获取时间片时，字节码解释器需要从挂起的位置继续执行，程序计数器可以用来记录执行位置。\n\n特点：\n\n1. 线程隔离\n2. 内存小\n3. 不会造成 OOM\n4. 记录程序执行字节码的地址\n5. 执行 Native 本地方法，值为空。通过 JNI 调用本地 C++、C 库来实现。\n\n\n\n### 虚拟机栈\n\n每个方法执行都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。下图是运行时栈帧结构。\n\n![f333c830ac58ac1de49ccda5230081d5.png](https://img.gejiba.com/images/f333c830ac58ac1de49ccda5230081d5.png)\n\n\n\n#### 局部变量表\n\n局部变量表用于存放方法参数和方法内部定义的局部变量，包括各种基本数据类型（boolean、byte、char、short、int、float、long、double、对象引用 reference类型）。\n\n局部变量表 Slot 复用对垃圾收集的影响，参考代码，启动参数添加 -verbose:gc\n\n```java\npublic static void main(String[] args) {\n    {\n        byte[] placeholder = new byte[64 * 1024 * 1024];\n    }\n    // int a = 1; // 新加一个赋值操作\n    System.gc();\n}\n```\n\n发现并没有被回收，因为方法里面局部变量 placeholder 的 Slot 没有被其它变量复用，即使离开了方法的作用域，它仍然是一个 GC Root，取消上面注释能正常回收或者添加参数 -verbose:gc -Xcomp，在经过 JIT 编译优化后，上面代码可以正常回收，无需添加赋值操作。\n\n\n\n#### 操作数栈\n\n操作数栈的每一个元素可以是任意的 Java 数据类型。当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指令往操作数栈中写入和提取，也就是出站和入栈。通过 javap -c 命令可以查看 class 文件的反编译指令，可分析方法如果执行字节码指令。在程序编译完成生成 class 文件之后，可以确定局部变量表的大小，以及操作数栈的大小。\n\n\n\n#### 动态链接\n\n​        每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。Class 文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。\n\n\n\n#### 返回地址\n\n当一个方法开始执行后，只有两种方式可以退出这个方法。第一种是执行引擎遇到任意一个方法返回的字节码指令。另一种是方法执行过程中遇到异常，并且这个异常没有在方法体内得到处理。方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用栈帧的操作数栈中，调用 PC 计数器的值指向方法调用指令后的一条指令等。\n\n\n\n#### 虚拟机栈溢出\n\n如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 StackOverflowError 异常。\n\n```java\npublic class JavaVMStackSOF {\n    private int stackLength = 1;\n    public void stackLeak() {\n        stackLength++;\n        stackLeak();\n    }\n\n    public static void main(String[] args) {\n        JavaVMStackSOF oom = new JavaVMStackSOF();\n        try {\n            oom.stackLeak();\n        } catch (Throwable e) {\n            System.out.println(\"stack length: \" + oom.stackLength);\n            throw e;\n        }\n    }\n}\n```\n\n\n\nVM 参数分别设置  -Xms256m -Xmx256m -Xmn128m -Xss256k 和 设置 -Xms256m -Xmx256m -Xmn128m -Xss512k，查看运行结果（stack length 变大），随着线程栈的大小越大，能够支持越多的方法调用，也就是能够存储更多的栈帧，栈帧越多越耗内存。\n\n| 参数说明 | 含义           | 说明                                                         |\n| -------- | -------------- | ------------------------------------------------------------ |\n| -Xms     | 初始堆大小     | 默认（MinHeapFreeRatio / -Xminf 参数可以调整）空余堆内存小于40%时，JVM 就会增大堆直到 -Xmx 的最大限制。 |\n| -Xmx     | 最大堆大小     | 默认（MaxHeapFreeRatio / -Xmaxf 参数可以调整）空余堆内存大于 70% 时，JVM 会减少堆直到 -Xms的最小限制 |\n| -Xmn     | 年轻代大小     | Eden + 2 survivor space                                      |\n| -Xss     | 线程的堆栈大小 |                                                              |\n\n在 stackLeak 方法增加参数，栈帧中的本地变量表就会增加，对应的栈帧内存就越大，栈的深度反而变小。\n\n\n\n下面代码为创建线程导致内存溢出异常，\n\n```java\npublic class JavaVMStackOOM {\n    private static void notStop() {\n        while (true) {\n\n        }\n    }\n    public void stackLeakByThread() {\n        while (true) {\n            Thread thread = new Thread(JavaVMStackOOM::notStop);\n            thread.start();\n        }\n    }\n\n    public static void main(String[] args) {\n        JavaVMStackOOM oom = new JavaVMStackOOM();\n        oom.stackLeakByThread();\n    }\n}\n```\n\n这个异常是由于操作系统没有足够的资源来产生这个线程造成的，虚拟机提供了参数来控制 Java 堆（Xmx）和方法区（MaxPermSize）的内存最大值。程序计数器消耗内存非常小，如果不计算虚拟机本身耗费的内存，剩下的内存就由虚拟机栈和本地方法栈来瓜分，每个线程分配的栈容量越大，线程数量就越少，建立线程就很容易耗尽内存。考虑这种情况，\n\n- 可以重新设计系统减少线程数量\n\n- 减少最大堆和减少栈容量来换取更多的线程。\n\n### 堆\n\n堆是垃圾收集器管理的主要区域，也叫 GC 堆 （Garbage Collected Heap）。如果收集器采用的是分代垃圾收集算法，则堆可细分为：新生代（Eden、Survivor），老年代。在 JDK 7版本之前，还增加了永久代 （Permanent Generation），JDK 8 版本后 PermGen 已被元空间（Metaspace）取代，使用的是直接内存（不是 JVM 管控）\n\n![e9c92acf8383df44e7beedbe095877a5.png](https://img.gejiba.com/images/e9c92acf8383df44e7beedbe095877a5.png)\n\n\n\n#### 堆扩展\n\n如果以下三个条件之一为 true，那么堆的活动部分将扩展为最大值。\n\n- 垃圾收集器未释放足够的存储空间来满足分配请求。\n\n- 可用空间小于使用  -Xminf 参数设置的最小可用空间。缺省值为 30%。\n\n- 垃圾回收所用时间超过使用 -Xmaxt  参数设置的最大时间阈值。缺省值为 13%。\n\n  \n\n#### 堆压缩\n\n如果以下所有情况都为 true，那么在收缩前将发生压缩：\n\n- 在此垃圾回收周期中，未完成压缩。\n- 在堆末端无可用块，或者堆末端可用块的大小小于所需的收缩量的 10%。\n- 在上一个垃圾回收周期中，GC 未收缩或压缩。\n\n\n\n#### 如果调整堆大小\n\n垃圾收集器会因以下原因调整堆大小以将占用率保持在 40% 到 70% 之间：\n\n- 堆占用率大于 70% 会导致更频繁的 GC 周期，致使性能降低。您可以通过设置 -Xminf  选项来变更此行为。\n- 堆占用率小于 40% 意味着不频繁的 GC 周期。但是，这些周期会超过必需时间而导致更长的暂停时间，致使性能降低。您可以通过设置  -Xmaxf  选项来变更此行为。\n\n在无负载但又具有压力的情况下运行应用程序时，您可以使用  -verbose:gc （垃圾收集时的信息打印 -XX:+PrintGC） 来帮助您设置初始堆大小 -Xms 和最大堆大小 -Xmx 。\n\n#### 堆溢出\n\nVM 参数：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError\n\n```java\npublic class HeapOOM {\n    static class OOMObjct {\n\n    }\n\n    public static void main(String[] args) {\n        List<OOMObjct> list = new ArrayList<>();\n        while (true) {\n            list.add(new OOMObjct());\n        }\n    }\n}\n```\n\n```\njava.lang.OutOfMemoryError: Java heap space\nDumping heap to java_pid39288.hprof ...\nHeap dump file created [28183701 bytes in 0.169 secs]\n```\n\n得到 Dump 文件，利用  jhat -J-Xmx1024m dump文件 命令分析，jhat 命令实际上会启动一个 JVM 来执行, 通过 -J 可以在启动 JVM 时传入一些启动参数，默认端口 7000。通过内存映像分析工具判断是内存溢出（系统没有足够的内存分配使用）还是内存泄露（程序分配的对象没有及时回收，或者永久不回收，无法释放已申请的内存空间，这些一般都是 GC 可达但是无用的对象）。内存泄露和内存溢出都会导致应用程序运行出现问题，性能下降或挂起。内存泄露是导致内存溢出的原因之一，内存泄露积累起来将导致内存溢出。内存泄露可以通过完善代码来避免，内存溢出可以通过调整配置来减少发生频率，但无法彻底避免。\n\n如果是内存泄露，通过工具查看泄露对象到 GC Roots 的引用链，分析出泄露对象是通过怎么样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收。掌握了泄露对象的类型信息及 GC Root 引用链信息，可以定位到泄露代码的位置。\n\n如果是内存溢出，那就说明对象可用，必须存活。应当检查 VM 的参数（-Xmx 与 -Xms），机器物理内存是否可以调大，代码检查是否存在某些对象生命周期过长，持有状态时间过长。\n\n\n\n#### 对象在堆区的生命周期\n\n对象优先在 Eden 区分配，当 Eden 区没有足够的空间进行分配时，VM 将发起一次 Minor GC。参考代码，设置 VM 参数  -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8\n\n -XX:+PrintGCDateStamps -Xloggc:gc.log\n\n- -XX:PrintGCTimeStamps：打印 GC 具体时间；\n- -XX:PrintGCDetails ：打印出 GC 详细日志；\n- -Xloggc: path：GC 日志生成路径。\n\n```java\nprivate static final int _1MB = 1024 * 1024;\npublic static void test() {\n    byte[] b1, b2, b3, b4;\n    b1 = new byte[2 * _1MB];\n    b2 = new byte[2 * _1MB];\n    b3 = new byte[2 * _1MB];\n    // 出现一次 Minor GC\n    b4 = new byte[4 * _1MB];\n}\n```\n\n配置新生代 10M（Eden 8M，From Survivor 1M，To Survivor 1M），老年代 10M，新生代总可用空间为 9M，\n\nEden区 + 1个 Survivor 区的总容量。三个 2M 的对象，1个 4M 的对象，当 Eden 区占用 6M 的时候无法分配 4M的内存给 b4，触发一次 Minor GC，而三个 2M 的对象无法放入 Survivor 空间，通过分配担保机制提前移动到老年代去。GC 结束后，Eden 占 4M，Survivor 空闲，老年代占 6M。\n\n![0bca81fb264d5dc53219946b5f1e9024.png](https://img.gejiba.com/images/0bca81fb264d5dc53219946b5f1e9024.png)\n\n\n\n通过配置 -XX:PretenureSizeThreshold 设置大对象的阀值，例如：-XX:PretenureSizeThreshold=3145728，当对象大于 3M 的时候直接分配到老年代，减少新生代的垃圾回收。\n\n通过配置 -XX:MaxTenuringThreshold 设置对象年龄计数器，当年龄到达设置的阀值，直接分配到老年代。（当 Eden 空间不足时，VM 触发 Minor GC，存活的对象转移到 Survivor区，对象年龄 +1，Survivor区的对象也会经历 Minor GC，对象年龄 +1）。\n\n为了能更好的适应不同程序的内存状况，VM 不是永远地要求对象的年龄必须达到设置的年龄值才能晋升老年代，如果在 Survivor 空间中的相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或者等于这些对象的对象将直接进入老年代。（动态对象年龄判断机制）\n\n#### 内存分配调优\n\n1. 压测工具进行压测（eg：ab 工具），分析请求接口吞吐量、并发连接数、响应时间等。\n\n2. 分析 GC 日志，通过设置 VM配置参数 -XX:+HeapDumpOnOutOfMemoryError ，或者通过 jmap 命令获取 dump文件 。频繁的 GC 将会引起线程的上下文切换，导致系统吞吐量下降，GC 的 持续时间也会影响请求的响应时间。通过合理分配堆的新生代、老年代内存大小，减少 Minor GC 及 Full GC 频率及时长。\n\n   说明：\n\n   - 在设置 Eden、Survivor 区比例的时候，如果开启 AdaptiveSizePolicy，则每次 GC 后都会重新计算 Eden、From Survivor 和 To Survivor 区的大小，依据 GC 过程中统计的 GC 时间、吞吐量、内存占用量。导致SurvivorRatio 默认设置的比例会失效。在 JDK1.8 中，默认是开启 AdaptiveSizePolicy 的，通过 -XX:-UseAdaptiveSizePolicy 关闭该项配置，或显示运行 -XX:SurvivorRatio=8 将 Eden、Survivor 的比例设置为 8:2。\n   - 一般先优化代码，减少大对象的数量及减少使用全局变量。\n\n### 方法区（永久代）\n\n用于存储已被 VM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了类的版本、字段、方法、接口等描述信息外，还有常量池，用于存放编译期生成的各种字面量和符号引用，在类加载后存放。\n\n#### 常量池溢出\n\nVM 参数：-XX:Permsize=10M -XX:MaxPermSize=10M\n\n使用 List 保持着常量池引用，避免 Full GC 回收。\n\n```java\npublic class RuntimeConstantPoolOOM {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>();\n        int i = 0;\n        while (true) {\n            list.add(String.valueOf(i++).intern());\n        }\n    }\n}\n```\n\n#### 方法区溢出\n\n运行时产生大量的类去填满方法区，直到溢出。eg：利用 CGLib 直接操作字节码运行时生成大量的动态类。当前很多主流的框架，在对类进行增强时，都会使用到 CGLib 这类字节码技术，增强的类越多，需要越大的方法区空间来保证动态生成的 Class 可以加载到内存。\n\n\n\n### 执行引擎（Execution Engine) \n\n主要有即时编译器（JITCompiler）和 垃圾收集（Garbage Collection）两部分组成。解释器和编译器都是将 Java 生成 .class 的字节码，解析成 cpu 所能执行的二进制指令。区别在于解释器是一行一行解释字节码指令（效率低），无需编译（编译需要很长时间），立刻执行。 jvm 启动的时候非常快，这时候用的是解释器，这样的话可以减少编译的时间，且不会出现较长的卡顿，并且随着程序运行的时间推移，即时编译时发生了作用，通过热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。\n\n\n\n垃圾回收名词解释：\n\n- 串行回收（Serial）：单线程回收，STW 暂停所有用户线程，独占式回收。\n- 并行回收（Parallel）：线程并行工作，STW，独占式回收。\n- 并发回收（CMS）：GC 线程和用户线程同时进行，用户线程停顿时间很短。\n\n\n\n#### Serial 收集器\n\n单线程，没有线程交互的开销，消耗内存少，STW 时间长。使用 -XX:+UseSerialGC 来开启。\n\n#### ParNew 收集器\n\n多线程版的 Serial 收集器，新生代采用复制算法（多线程执行），老年代采用标记整理算法（单线程），在收集算法、STW、对象分配规则、回收策略等都与 serial一样。使用 -XX:UseParNewGC 来开启，使用 \n\n-XX:ParallelGCThreads 指定线程数量，一般设置和CPU数量 一样。\n\n\n\n#### Parallel Scavenge收集器\n\nParNew 和 CMS 收集器关注的是如何缩短垃圾收集时用户线程的停顿时间。Parallel Scavenge 关注的是吞吐量。\n$$\n吞吐量 = \\frac {用户执行代码的时间}{用户执行代码的时间 + 垃圾收集的时间}\n$$\n\n#### CMS （Concurrent Mark Sweep）收集器\n\n最短停顿时间的垃圾收集器，基于标记清除算法实现的，包括四个过程\n\n- 初始标记：STW，速度快。\n- 并发标记 ：与用户线程并发执行。\n- 重新标记 ：STW，修正并发标记期间因用户继续运作而导致标记产生变动的那一部分对象的标记记录。\n- 并发清除 ：与用户线程并发执行。\n\n优点：并发收集器，STW 低停顿。\n缺点：CMS 对处理器资源十分敏感，无法处理浮动垃圾，导致 Full GC 出现，内存碎片严重，会给内存分配带来巨大压力。\n\n\n\n#### Garbage First 收集器\n\n包括四个过程:\n\n- 初始标记（Initial Marking）\n- 并发标记（Concurrent Marking）\n- 最终标记（Final Marking）\n- 筛选回收（Live Data Counting and Evacuation）\n\nG1 收集器的特定：\n\n- 并行与并发，缩短 STW 停顿时间。\n- 分代收集。\n- 空间整理，标记整理算法，复制算法，不会产生内存碎片。\n- 可预测的停顿。\n\n两个收集器之间如果存在连线，就说明它们可以搭配使用，根据具体应用选择最合适的收集器。\n\n![2f218fd75b0d81c901770faf2252bfc9.png](https://img.gejiba.com/images/2f218fd75b0d81c901770faf2252bfc9.png)\n\n\n\n### JDK 命令行工具\n\n- jps（JVM Process Status）: 类似 UNIX 的 ps 命令。用于查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；\n- jstat（JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据；\n- jinfo（Configuration Info for Java） : Configuration Info for Java，显示虚拟机配置信息；\n- jmap（Memory Map for Java）: 生成堆转储快照；\n- jhat（JVM Heap Dump Browser） : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果；\n- jstack（Stack Trace for Java）: 生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。\n\n\n\n\n\n\n\n","source":"_posts/JVM.md","raw":"---\ntitle: JVM\ndate: 2022-05-12 14:03:35\ntags: Java\n---\n\n### 运行时数据区域\n\nHotSpot 虚拟机\n\n![61739beeb3810e7c2ae5e30bb5980584.png](https://img.gejiba.com/images/61739beeb3810e7c2ae5e30bb5980584.png)\n\nJAVA 1.8 移除方法区，移到了本地内存的元空间。\n\n![5249b2be8bc23b68fc0b388a0fcd1485.png](https://img.gejiba.com/images/5249b2be8bc23b68fc0b388a0fcd1485.png)\n\n\n\n### 程序计数器\n\n程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令、分支、循环、\n\n跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。为什么需要程序计数器？程序一般都是多线程执行，JVM多线程是通过 CPU 时间片切换来实现，如果某个线程在执行的过程中挂起，当再次获取时间片时，字节码解释器需要从挂起的位置继续执行，程序计数器可以用来记录执行位置。\n\n特点：\n\n1. 线程隔离\n2. 内存小\n3. 不会造成 OOM\n4. 记录程序执行字节码的地址\n5. 执行 Native 本地方法，值为空。通过 JNI 调用本地 C++、C 库来实现。\n\n\n\n### 虚拟机栈\n\n每个方法执行都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。下图是运行时栈帧结构。\n\n![f333c830ac58ac1de49ccda5230081d5.png](https://img.gejiba.com/images/f333c830ac58ac1de49ccda5230081d5.png)\n\n\n\n#### 局部变量表\n\n局部变量表用于存放方法参数和方法内部定义的局部变量，包括各种基本数据类型（boolean、byte、char、short、int、float、long、double、对象引用 reference类型）。\n\n局部变量表 Slot 复用对垃圾收集的影响，参考代码，启动参数添加 -verbose:gc\n\n```java\npublic static void main(String[] args) {\n    {\n        byte[] placeholder = new byte[64 * 1024 * 1024];\n    }\n    // int a = 1; // 新加一个赋值操作\n    System.gc();\n}\n```\n\n发现并没有被回收，因为方法里面局部变量 placeholder 的 Slot 没有被其它变量复用，即使离开了方法的作用域，它仍然是一个 GC Root，取消上面注释能正常回收或者添加参数 -verbose:gc -Xcomp，在经过 JIT 编译优化后，上面代码可以正常回收，无需添加赋值操作。\n\n\n\n#### 操作数栈\n\n操作数栈的每一个元素可以是任意的 Java 数据类型。当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指令往操作数栈中写入和提取，也就是出站和入栈。通过 javap -c 命令可以查看 class 文件的反编译指令，可分析方法如果执行字节码指令。在程序编译完成生成 class 文件之后，可以确定局部变量表的大小，以及操作数栈的大小。\n\n\n\n#### 动态链接\n\n​        每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。Class 文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。\n\n\n\n#### 返回地址\n\n当一个方法开始执行后，只有两种方式可以退出这个方法。第一种是执行引擎遇到任意一个方法返回的字节码指令。另一种是方法执行过程中遇到异常，并且这个异常没有在方法体内得到处理。方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用栈帧的操作数栈中，调用 PC 计数器的值指向方法调用指令后的一条指令等。\n\n\n\n#### 虚拟机栈溢出\n\n如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 StackOverflowError 异常。\n\n```java\npublic class JavaVMStackSOF {\n    private int stackLength = 1;\n    public void stackLeak() {\n        stackLength++;\n        stackLeak();\n    }\n\n    public static void main(String[] args) {\n        JavaVMStackSOF oom = new JavaVMStackSOF();\n        try {\n            oom.stackLeak();\n        } catch (Throwable e) {\n            System.out.println(\"stack length: \" + oom.stackLength);\n            throw e;\n        }\n    }\n}\n```\n\n\n\nVM 参数分别设置  -Xms256m -Xmx256m -Xmn128m -Xss256k 和 设置 -Xms256m -Xmx256m -Xmn128m -Xss512k，查看运行结果（stack length 变大），随着线程栈的大小越大，能够支持越多的方法调用，也就是能够存储更多的栈帧，栈帧越多越耗内存。\n\n| 参数说明 | 含义           | 说明                                                         |\n| -------- | -------------- | ------------------------------------------------------------ |\n| -Xms     | 初始堆大小     | 默认（MinHeapFreeRatio / -Xminf 参数可以调整）空余堆内存小于40%时，JVM 就会增大堆直到 -Xmx 的最大限制。 |\n| -Xmx     | 最大堆大小     | 默认（MaxHeapFreeRatio / -Xmaxf 参数可以调整）空余堆内存大于 70% 时，JVM 会减少堆直到 -Xms的最小限制 |\n| -Xmn     | 年轻代大小     | Eden + 2 survivor space                                      |\n| -Xss     | 线程的堆栈大小 |                                                              |\n\n在 stackLeak 方法增加参数，栈帧中的本地变量表就会增加，对应的栈帧内存就越大，栈的深度反而变小。\n\n\n\n下面代码为创建线程导致内存溢出异常，\n\n```java\npublic class JavaVMStackOOM {\n    private static void notStop() {\n        while (true) {\n\n        }\n    }\n    public void stackLeakByThread() {\n        while (true) {\n            Thread thread = new Thread(JavaVMStackOOM::notStop);\n            thread.start();\n        }\n    }\n\n    public static void main(String[] args) {\n        JavaVMStackOOM oom = new JavaVMStackOOM();\n        oom.stackLeakByThread();\n    }\n}\n```\n\n这个异常是由于操作系统没有足够的资源来产生这个线程造成的，虚拟机提供了参数来控制 Java 堆（Xmx）和方法区（MaxPermSize）的内存最大值。程序计数器消耗内存非常小，如果不计算虚拟机本身耗费的内存，剩下的内存就由虚拟机栈和本地方法栈来瓜分，每个线程分配的栈容量越大，线程数量就越少，建立线程就很容易耗尽内存。考虑这种情况，\n\n- 可以重新设计系统减少线程数量\n\n- 减少最大堆和减少栈容量来换取更多的线程。\n\n### 堆\n\n堆是垃圾收集器管理的主要区域，也叫 GC 堆 （Garbage Collected Heap）。如果收集器采用的是分代垃圾收集算法，则堆可细分为：新生代（Eden、Survivor），老年代。在 JDK 7版本之前，还增加了永久代 （Permanent Generation），JDK 8 版本后 PermGen 已被元空间（Metaspace）取代，使用的是直接内存（不是 JVM 管控）\n\n![e9c92acf8383df44e7beedbe095877a5.png](https://img.gejiba.com/images/e9c92acf8383df44e7beedbe095877a5.png)\n\n\n\n#### 堆扩展\n\n如果以下三个条件之一为 true，那么堆的活动部分将扩展为最大值。\n\n- 垃圾收集器未释放足够的存储空间来满足分配请求。\n\n- 可用空间小于使用  -Xminf 参数设置的最小可用空间。缺省值为 30%。\n\n- 垃圾回收所用时间超过使用 -Xmaxt  参数设置的最大时间阈值。缺省值为 13%。\n\n  \n\n#### 堆压缩\n\n如果以下所有情况都为 true，那么在收缩前将发生压缩：\n\n- 在此垃圾回收周期中，未完成压缩。\n- 在堆末端无可用块，或者堆末端可用块的大小小于所需的收缩量的 10%。\n- 在上一个垃圾回收周期中，GC 未收缩或压缩。\n\n\n\n#### 如果调整堆大小\n\n垃圾收集器会因以下原因调整堆大小以将占用率保持在 40% 到 70% 之间：\n\n- 堆占用率大于 70% 会导致更频繁的 GC 周期，致使性能降低。您可以通过设置 -Xminf  选项来变更此行为。\n- 堆占用率小于 40% 意味着不频繁的 GC 周期。但是，这些周期会超过必需时间而导致更长的暂停时间，致使性能降低。您可以通过设置  -Xmaxf  选项来变更此行为。\n\n在无负载但又具有压力的情况下运行应用程序时，您可以使用  -verbose:gc （垃圾收集时的信息打印 -XX:+PrintGC） 来帮助您设置初始堆大小 -Xms 和最大堆大小 -Xmx 。\n\n#### 堆溢出\n\nVM 参数：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError\n\n```java\npublic class HeapOOM {\n    static class OOMObjct {\n\n    }\n\n    public static void main(String[] args) {\n        List<OOMObjct> list = new ArrayList<>();\n        while (true) {\n            list.add(new OOMObjct());\n        }\n    }\n}\n```\n\n```\njava.lang.OutOfMemoryError: Java heap space\nDumping heap to java_pid39288.hprof ...\nHeap dump file created [28183701 bytes in 0.169 secs]\n```\n\n得到 Dump 文件，利用  jhat -J-Xmx1024m dump文件 命令分析，jhat 命令实际上会启动一个 JVM 来执行, 通过 -J 可以在启动 JVM 时传入一些启动参数，默认端口 7000。通过内存映像分析工具判断是内存溢出（系统没有足够的内存分配使用）还是内存泄露（程序分配的对象没有及时回收，或者永久不回收，无法释放已申请的内存空间，这些一般都是 GC 可达但是无用的对象）。内存泄露和内存溢出都会导致应用程序运行出现问题，性能下降或挂起。内存泄露是导致内存溢出的原因之一，内存泄露积累起来将导致内存溢出。内存泄露可以通过完善代码来避免，内存溢出可以通过调整配置来减少发生频率，但无法彻底避免。\n\n如果是内存泄露，通过工具查看泄露对象到 GC Roots 的引用链，分析出泄露对象是通过怎么样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收。掌握了泄露对象的类型信息及 GC Root 引用链信息，可以定位到泄露代码的位置。\n\n如果是内存溢出，那就说明对象可用，必须存活。应当检查 VM 的参数（-Xmx 与 -Xms），机器物理内存是否可以调大，代码检查是否存在某些对象生命周期过长，持有状态时间过长。\n\n\n\n#### 对象在堆区的生命周期\n\n对象优先在 Eden 区分配，当 Eden 区没有足够的空间进行分配时，VM 将发起一次 Minor GC。参考代码，设置 VM 参数  -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8\n\n -XX:+PrintGCDateStamps -Xloggc:gc.log\n\n- -XX:PrintGCTimeStamps：打印 GC 具体时间；\n- -XX:PrintGCDetails ：打印出 GC 详细日志；\n- -Xloggc: path：GC 日志生成路径。\n\n```java\nprivate static final int _1MB = 1024 * 1024;\npublic static void test() {\n    byte[] b1, b2, b3, b4;\n    b1 = new byte[2 * _1MB];\n    b2 = new byte[2 * _1MB];\n    b3 = new byte[2 * _1MB];\n    // 出现一次 Minor GC\n    b4 = new byte[4 * _1MB];\n}\n```\n\n配置新生代 10M（Eden 8M，From Survivor 1M，To Survivor 1M），老年代 10M，新生代总可用空间为 9M，\n\nEden区 + 1个 Survivor 区的总容量。三个 2M 的对象，1个 4M 的对象，当 Eden 区占用 6M 的时候无法分配 4M的内存给 b4，触发一次 Minor GC，而三个 2M 的对象无法放入 Survivor 空间，通过分配担保机制提前移动到老年代去。GC 结束后，Eden 占 4M，Survivor 空闲，老年代占 6M。\n\n![0bca81fb264d5dc53219946b5f1e9024.png](https://img.gejiba.com/images/0bca81fb264d5dc53219946b5f1e9024.png)\n\n\n\n通过配置 -XX:PretenureSizeThreshold 设置大对象的阀值，例如：-XX:PretenureSizeThreshold=3145728，当对象大于 3M 的时候直接分配到老年代，减少新生代的垃圾回收。\n\n通过配置 -XX:MaxTenuringThreshold 设置对象年龄计数器，当年龄到达设置的阀值，直接分配到老年代。（当 Eden 空间不足时，VM 触发 Minor GC，存活的对象转移到 Survivor区，对象年龄 +1，Survivor区的对象也会经历 Minor GC，对象年龄 +1）。\n\n为了能更好的适应不同程序的内存状况，VM 不是永远地要求对象的年龄必须达到设置的年龄值才能晋升老年代，如果在 Survivor 空间中的相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或者等于这些对象的对象将直接进入老年代。（动态对象年龄判断机制）\n\n#### 内存分配调优\n\n1. 压测工具进行压测（eg：ab 工具），分析请求接口吞吐量、并发连接数、响应时间等。\n\n2. 分析 GC 日志，通过设置 VM配置参数 -XX:+HeapDumpOnOutOfMemoryError ，或者通过 jmap 命令获取 dump文件 。频繁的 GC 将会引起线程的上下文切换，导致系统吞吐量下降，GC 的 持续时间也会影响请求的响应时间。通过合理分配堆的新生代、老年代内存大小，减少 Minor GC 及 Full GC 频率及时长。\n\n   说明：\n\n   - 在设置 Eden、Survivor 区比例的时候，如果开启 AdaptiveSizePolicy，则每次 GC 后都会重新计算 Eden、From Survivor 和 To Survivor 区的大小，依据 GC 过程中统计的 GC 时间、吞吐量、内存占用量。导致SurvivorRatio 默认设置的比例会失效。在 JDK1.8 中，默认是开启 AdaptiveSizePolicy 的，通过 -XX:-UseAdaptiveSizePolicy 关闭该项配置，或显示运行 -XX:SurvivorRatio=8 将 Eden、Survivor 的比例设置为 8:2。\n   - 一般先优化代码，减少大对象的数量及减少使用全局变量。\n\n### 方法区（永久代）\n\n用于存储已被 VM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了类的版本、字段、方法、接口等描述信息外，还有常量池，用于存放编译期生成的各种字面量和符号引用，在类加载后存放。\n\n#### 常量池溢出\n\nVM 参数：-XX:Permsize=10M -XX:MaxPermSize=10M\n\n使用 List 保持着常量池引用，避免 Full GC 回收。\n\n```java\npublic class RuntimeConstantPoolOOM {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>();\n        int i = 0;\n        while (true) {\n            list.add(String.valueOf(i++).intern());\n        }\n    }\n}\n```\n\n#### 方法区溢出\n\n运行时产生大量的类去填满方法区，直到溢出。eg：利用 CGLib 直接操作字节码运行时生成大量的动态类。当前很多主流的框架，在对类进行增强时，都会使用到 CGLib 这类字节码技术，增强的类越多，需要越大的方法区空间来保证动态生成的 Class 可以加载到内存。\n\n\n\n### 执行引擎（Execution Engine) \n\n主要有即时编译器（JITCompiler）和 垃圾收集（Garbage Collection）两部分组成。解释器和编译器都是将 Java 生成 .class 的字节码，解析成 cpu 所能执行的二进制指令。区别在于解释器是一行一行解释字节码指令（效率低），无需编译（编译需要很长时间），立刻执行。 jvm 启动的时候非常快，这时候用的是解释器，这样的话可以减少编译的时间，且不会出现较长的卡顿，并且随着程序运行的时间推移，即时编译时发生了作用，通过热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。\n\n\n\n垃圾回收名词解释：\n\n- 串行回收（Serial）：单线程回收，STW 暂停所有用户线程，独占式回收。\n- 并行回收（Parallel）：线程并行工作，STW，独占式回收。\n- 并发回收（CMS）：GC 线程和用户线程同时进行，用户线程停顿时间很短。\n\n\n\n#### Serial 收集器\n\n单线程，没有线程交互的开销，消耗内存少，STW 时间长。使用 -XX:+UseSerialGC 来开启。\n\n#### ParNew 收集器\n\n多线程版的 Serial 收集器，新生代采用复制算法（多线程执行），老年代采用标记整理算法（单线程），在收集算法、STW、对象分配规则、回收策略等都与 serial一样。使用 -XX:UseParNewGC 来开启，使用 \n\n-XX:ParallelGCThreads 指定线程数量，一般设置和CPU数量 一样。\n\n\n\n#### Parallel Scavenge收集器\n\nParNew 和 CMS 收集器关注的是如何缩短垃圾收集时用户线程的停顿时间。Parallel Scavenge 关注的是吞吐量。\n$$\n吞吐量 = \\frac {用户执行代码的时间}{用户执行代码的时间 + 垃圾收集的时间}\n$$\n\n#### CMS （Concurrent Mark Sweep）收集器\n\n最短停顿时间的垃圾收集器，基于标记清除算法实现的，包括四个过程\n\n- 初始标记：STW，速度快。\n- 并发标记 ：与用户线程并发执行。\n- 重新标记 ：STW，修正并发标记期间因用户继续运作而导致标记产生变动的那一部分对象的标记记录。\n- 并发清除 ：与用户线程并发执行。\n\n优点：并发收集器，STW 低停顿。\n缺点：CMS 对处理器资源十分敏感，无法处理浮动垃圾，导致 Full GC 出现，内存碎片严重，会给内存分配带来巨大压力。\n\n\n\n#### Garbage First 收集器\n\n包括四个过程:\n\n- 初始标记（Initial Marking）\n- 并发标记（Concurrent Marking）\n- 最终标记（Final Marking）\n- 筛选回收（Live Data Counting and Evacuation）\n\nG1 收集器的特定：\n\n- 并行与并发，缩短 STW 停顿时间。\n- 分代收集。\n- 空间整理，标记整理算法，复制算法，不会产生内存碎片。\n- 可预测的停顿。\n\n两个收集器之间如果存在连线，就说明它们可以搭配使用，根据具体应用选择最合适的收集器。\n\n![2f218fd75b0d81c901770faf2252bfc9.png](https://img.gejiba.com/images/2f218fd75b0d81c901770faf2252bfc9.png)\n\n\n\n### JDK 命令行工具\n\n- jps（JVM Process Status）: 类似 UNIX 的 ps 命令。用于查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；\n- jstat（JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据；\n- jinfo（Configuration Info for Java） : Configuration Info for Java，显示虚拟机配置信息；\n- jmap（Memory Map for Java）: 生成堆转储快照；\n- jhat（JVM Heap Dump Browser） : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果；\n- jstack（Stack Trace for Java）: 生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。\n\n\n\n\n\n\n\n","slug":"JVM","published":1,"updated":"2022-05-13T08:35:31.292Z","_id":"cl32lvw8400007oln8h3h45ll","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"运行时数据区域\"><a href=\"#运行时数据区域\" class=\"headerlink\" title=\"运行时数据区域\"></a>运行时数据区域</h3><p>HotSpot 虚拟机</p>\n<p><img src=\"https://img.gejiba.com/images/61739beeb3810e7c2ae5e30bb5980584.png\" alt=\"61739beeb3810e7c2ae5e30bb5980584.png\"></p>\n<p>JAVA 1.8 移除方法区，移到了本地内存的元空间。</p>\n<p><img src=\"https://img.gejiba.com/images/5249b2be8bc23b68fc0b388a0fcd1485.png\" alt=\"5249b2be8bc23b68fc0b388a0fcd1485.png\"></p>\n<h3 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h3><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令、分支、循环、</p>\n<p>跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。为什么需要程序计数器？程序一般都是多线程执行，JVM多线程是通过 CPU 时间片切换来实现，如果某个线程在执行的过程中挂起，当再次获取时间片时，字节码解释器需要从挂起的位置继续执行，程序计数器可以用来记录执行位置。</p>\n<p>特点：</p>\n<ol>\n<li>线程隔离</li>\n<li>内存小</li>\n<li>不会造成 OOM</li>\n<li>记录程序执行字节码的地址</li>\n<li>执行 Native 本地方法，值为空。通过 JNI 调用本地 C++、C 库来实现。</li>\n</ol>\n<h3 id=\"虚拟机栈\"><a href=\"#虚拟机栈\" class=\"headerlink\" title=\"虚拟机栈\"></a>虚拟机栈</h3><p>每个方法执行都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。下图是运行时栈帧结构。</p>\n<p><img src=\"https://img.gejiba.com/images/f333c830ac58ac1de49ccda5230081d5.png\" alt=\"f333c830ac58ac1de49ccda5230081d5.png\"></p>\n<h4 id=\"局部变量表\"><a href=\"#局部变量表\" class=\"headerlink\" title=\"局部变量表\"></a>局部变量表</h4><p>局部变量表用于存放方法参数和方法内部定义的局部变量，包括各种基本数据类型（boolean、byte、char、short、int、float、long、double、对象引用 reference类型）。</p>\n<p>局部变量表 Slot 复用对垃圾收集的影响，参考代码，启动参数添加 -verbose:gc</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">byte</span>[] placeholder = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">64</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// int a = 1; // 新加一个赋值操作</span></span><br><span class=\"line\">    System.gc();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>发现并没有被回收，因为方法里面局部变量 placeholder 的 Slot 没有被其它变量复用，即使离开了方法的作用域，它仍然是一个 GC Root，取消上面注释能正常回收或者添加参数 -verbose:gc -Xcomp，在经过 JIT 编译优化后，上面代码可以正常回收，无需添加赋值操作。</p>\n<h4 id=\"操作数栈\"><a href=\"#操作数栈\" class=\"headerlink\" title=\"操作数栈\"></a>操作数栈</h4><p>操作数栈的每一个元素可以是任意的 Java 数据类型。当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指令往操作数栈中写入和提取，也就是出站和入栈。通过 javap -c 命令可以查看 class 文件的反编译指令，可分析方法如果执行字节码指令。在程序编译完成生成 class 文件之后，可以确定局部变量表的大小，以及操作数栈的大小。</p>\n<h4 id=\"动态链接\"><a href=\"#动态链接\" class=\"headerlink\" title=\"动态链接\"></a>动态链接</h4><p>​        每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。Class 文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。</p>\n<h4 id=\"返回地址\"><a href=\"#返回地址\" class=\"headerlink\" title=\"返回地址\"></a>返回地址</h4><p>当一个方法开始执行后，只有两种方式可以退出这个方法。第一种是执行引擎遇到任意一个方法返回的字节码指令。另一种是方法执行过程中遇到异常，并且这个异常没有在方法体内得到处理。方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用栈帧的操作数栈中，调用 PC 计数器的值指向方法调用指令后的一条指令等。</p>\n<h4 id=\"虚拟机栈溢出\"><a href=\"#虚拟机栈溢出\" class=\"headerlink\" title=\"虚拟机栈溢出\"></a>虚拟机栈溢出</h4><p>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 StackOverflowError 异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JavaVMStackSOF</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">stackLength</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">stackLeak</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        stackLength++;</span><br><span class=\"line\">        stackLeak();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">JavaVMStackSOF</span> <span class=\"variable\">oom</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JavaVMStackSOF</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            oom.stackLeak();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;stack length: &quot;</span> + oom.stackLength);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>VM 参数分别设置  -Xms256m -Xmx256m -Xmn128m -Xss256k 和 设置 -Xms256m -Xmx256m -Xmn128m -Xss512k，查看运行结果（stack length 变大），随着线程栈的大小越大，能够支持越多的方法调用，也就是能够存储更多的栈帧，栈帧越多越耗内存。</p>\n<table>\n<thead>\n<tr>\n<th>参数说明</th>\n<th>含义</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-Xms</td>\n<td>初始堆大小</td>\n<td>默认（MinHeapFreeRatio / -Xminf 参数可以调整）空余堆内存小于40%时，JVM 就会增大堆直到 -Xmx 的最大限制。</td>\n</tr>\n<tr>\n<td>-Xmx</td>\n<td>最大堆大小</td>\n<td>默认（MaxHeapFreeRatio / -Xmaxf 参数可以调整）空余堆内存大于 70% 时，JVM 会减少堆直到 -Xms的最小限制</td>\n</tr>\n<tr>\n<td>-Xmn</td>\n<td>年轻代大小</td>\n<td>Eden + 2 survivor space</td>\n</tr>\n<tr>\n<td>-Xss</td>\n<td>线程的堆栈大小</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>在 stackLeak 方法增加参数，栈帧中的本地变量表就会增加，对应的栈帧内存就越大，栈的深度反而变小。</p>\n<p>下面代码为创建线程导致内存溢出异常，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JavaVMStackOOM</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">notStop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">stackLeakByThread</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">thread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(JavaVMStackOOM::notStop);</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">JavaVMStackOOM</span> <span class=\"variable\">oom</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JavaVMStackOOM</span>();</span><br><span class=\"line\">        oom.stackLeakByThread();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个异常是由于操作系统没有足够的资源来产生这个线程造成的，虚拟机提供了参数来控制 Java 堆（Xmx）和方法区（MaxPermSize）的内存最大值。程序计数器消耗内存非常小，如果不计算虚拟机本身耗费的内存，剩下的内存就由虚拟机栈和本地方法栈来瓜分，每个线程分配的栈容量越大，线程数量就越少，建立线程就很容易耗尽内存。考虑这种情况，</p>\n<ul>\n<li><p>可以重新设计系统减少线程数量</p>\n</li>\n<li><p>减少最大堆和减少栈容量来换取更多的线程。</p>\n</li>\n</ul>\n<h3 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h3><p>堆是垃圾收集器管理的主要区域，也叫 GC 堆 （Garbage Collected Heap）。如果收集器采用的是分代垃圾收集算法，则堆可细分为：新生代（Eden、Survivor），老年代。在 JDK 7版本之前，还增加了永久代 （Permanent Generation），JDK 8 版本后 PermGen 已被元空间（Metaspace）取代，使用的是直接内存（不是 JVM 管控）</p>\n<p><img src=\"https://img.gejiba.com/images/e9c92acf8383df44e7beedbe095877a5.png\" alt=\"e9c92acf8383df44e7beedbe095877a5.png\"></p>\n<h4 id=\"堆扩展\"><a href=\"#堆扩展\" class=\"headerlink\" title=\"堆扩展\"></a>堆扩展</h4><p>如果以下三个条件之一为 true，那么堆的活动部分将扩展为最大值。</p>\n<ul>\n<li><p>垃圾收集器未释放足够的存储空间来满足分配请求。</p>\n</li>\n<li><p>可用空间小于使用  -Xminf 参数设置的最小可用空间。缺省值为 30%。</p>\n</li>\n<li><p>垃圾回收所用时间超过使用 -Xmaxt  参数设置的最大时间阈值。缺省值为 13%。</p>\n</li>\n</ul>\n<h4 id=\"堆压缩\"><a href=\"#堆压缩\" class=\"headerlink\" title=\"堆压缩\"></a>堆压缩</h4><p>如果以下所有情况都为 true，那么在收缩前将发生压缩：</p>\n<ul>\n<li>在此垃圾回收周期中，未完成压缩。</li>\n<li>在堆末端无可用块，或者堆末端可用块的大小小于所需的收缩量的 10%。</li>\n<li>在上一个垃圾回收周期中，GC 未收缩或压缩。</li>\n</ul>\n<h4 id=\"如果调整堆大小\"><a href=\"#如果调整堆大小\" class=\"headerlink\" title=\"如果调整堆大小\"></a>如果调整堆大小</h4><p>垃圾收集器会因以下原因调整堆大小以将占用率保持在 40% 到 70% 之间：</p>\n<ul>\n<li>堆占用率大于 70% 会导致更频繁的 GC 周期，致使性能降低。您可以通过设置 -Xminf  选项来变更此行为。</li>\n<li>堆占用率小于 40% 意味着不频繁的 GC 周期。但是，这些周期会超过必需时间而导致更长的暂停时间，致使性能降低。您可以通过设置  -Xmaxf  选项来变更此行为。</li>\n</ul>\n<p>在无负载但又具有压力的情况下运行应用程序时，您可以使用  -verbose:gc （垃圾收集时的信息打印 -XX:+PrintGC） 来帮助您设置初始堆大小 -Xms 和最大堆大小 -Xmx 。</p>\n<h4 id=\"堆溢出\"><a href=\"#堆溢出\" class=\"headerlink\" title=\"堆溢出\"></a>堆溢出</h4><p>VM 参数：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HeapOOM</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OOMObjct</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        List&lt;OOMObjct&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">OOMObjct</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.OutOfMemoryError: Java heap space</span><br><span class=\"line\">Dumping heap to java_pid39288.hprof ...</span><br><span class=\"line\">Heap dump file created [28183701 bytes in 0.169 secs]</span><br></pre></td></tr></table></figure>\n\n<p>得到 Dump 文件，利用  jhat -J-Xmx1024m dump文件 命令分析，jhat 命令实际上会启动一个 JVM 来执行, 通过 -J 可以在启动 JVM 时传入一些启动参数，默认端口 7000。通过内存映像分析工具判断是内存溢出（系统没有足够的内存分配使用）还是内存泄露（程序分配的对象没有及时回收，或者永久不回收，无法释放已申请的内存空间，这些一般都是 GC 可达但是无用的对象）。内存泄露和内存溢出都会导致应用程序运行出现问题，性能下降或挂起。内存泄露是导致内存溢出的原因之一，内存泄露积累起来将导致内存溢出。内存泄露可以通过完善代码来避免，内存溢出可以通过调整配置来减少发生频率，但无法彻底避免。</p>\n<p>如果是内存泄露，通过工具查看泄露对象到 GC Roots 的引用链，分析出泄露对象是通过怎么样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收。掌握了泄露对象的类型信息及 GC Root 引用链信息，可以定位到泄露代码的位置。</p>\n<p>如果是内存溢出，那就说明对象可用，必须存活。应当检查 VM 的参数（-Xmx 与 -Xms），机器物理内存是否可以调大，代码检查是否存在某些对象生命周期过长，持有状态时间过长。</p>\n<h4 id=\"对象在堆区的生命周期\"><a href=\"#对象在堆区的生命周期\" class=\"headerlink\" title=\"对象在堆区的生命周期\"></a>对象在堆区的生命周期</h4><p>对象优先在 Eden 区分配，当 Eden 区没有足够的空间进行分配时，VM 将发起一次 Minor GC。参考代码，设置 VM 参数  -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</p>\n<p> -XX:+PrintGCDateStamps -Xloggc:gc.log</p>\n<ul>\n<li>-XX:PrintGCTimeStamps：打印 GC 具体时间；</li>\n<li>-XX:PrintGCDetails ：打印出 GC 详细日志；</li>\n<li>-Xloggc: path：GC 日志生成路径。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">_1MB</span> <span class=\"operator\">=</span> <span class=\"number\">1024</span> * <span class=\"number\">1024</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">byte</span>[] b1, b2, b3, b4;</span><br><span class=\"line\">    b1 = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">2</span> * _1MB];</span><br><span class=\"line\">    b2 = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">2</span> * _1MB];</span><br><span class=\"line\">    b3 = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">2</span> * _1MB];</span><br><span class=\"line\">    <span class=\"comment\">// 出现一次 Minor GC</span></span><br><span class=\"line\">    b4 = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">4</span> * _1MB];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>配置新生代 10M（Eden 8M，From Survivor 1M，To Survivor 1M），老年代 10M，新生代总可用空间为 9M，</p>\n<p>Eden区 + 1个 Survivor 区的总容量。三个 2M 的对象，1个 4M 的对象，当 Eden 区占用 6M 的时候无法分配 4M的内存给 b4，触发一次 Minor GC，而三个 2M 的对象无法放入 Survivor 空间，通过分配担保机制提前移动到老年代去。GC 结束后，Eden 占 4M，Survivor 空闲，老年代占 6M。</p>\n<p><img src=\"https://img.gejiba.com/images/0bca81fb264d5dc53219946b5f1e9024.png\" alt=\"0bca81fb264d5dc53219946b5f1e9024.png\"></p>\n<p>通过配置 -XX:PretenureSizeThreshold 设置大对象的阀值，例如：-XX:PretenureSizeThreshold=3145728，当对象大于 3M 的时候直接分配到老年代，减少新生代的垃圾回收。</p>\n<p>通过配置 -XX:MaxTenuringThreshold 设置对象年龄计数器，当年龄到达设置的阀值，直接分配到老年代。（当 Eden 空间不足时，VM 触发 Minor GC，存活的对象转移到 Survivor区，对象年龄 +1，Survivor区的对象也会经历 Minor GC，对象年龄 +1）。</p>\n<p>为了能更好的适应不同程序的内存状况，VM 不是永远地要求对象的年龄必须达到设置的年龄值才能晋升老年代，如果在 Survivor 空间中的相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或者等于这些对象的对象将直接进入老年代。（动态对象年龄判断机制）</p>\n<h4 id=\"内存分配调优\"><a href=\"#内存分配调优\" class=\"headerlink\" title=\"内存分配调优\"></a>内存分配调优</h4><ol>\n<li><p>压测工具进行压测（eg：ab 工具），分析请求接口吞吐量、并发连接数、响应时间等。</p>\n</li>\n<li><p>分析 GC 日志，通过设置 VM配置参数 -XX:+HeapDumpOnOutOfMemoryError ，或者通过 jmap 命令获取 dump文件 。频繁的 GC 将会引起线程的上下文切换，导致系统吞吐量下降，GC 的 持续时间也会影响请求的响应时间。通过合理分配堆的新生代、老年代内存大小，减少 Minor GC 及 Full GC 频率及时长。</p>\n<p>说明：</p>\n<ul>\n<li>在设置 Eden、Survivor 区比例的时候，如果开启 AdaptiveSizePolicy，则每次 GC 后都会重新计算 Eden、From Survivor 和 To Survivor 区的大小，依据 GC 过程中统计的 GC 时间、吞吐量、内存占用量。导致SurvivorRatio 默认设置的比例会失效。在 JDK1.8 中，默认是开启 AdaptiveSizePolicy 的，通过 -XX:-UseAdaptiveSizePolicy 关闭该项配置，或显示运行 -XX:SurvivorRatio=8 将 Eden、Survivor 的比例设置为 8:2。</li>\n<li>一般先优化代码，减少大对象的数量及减少使用全局变量。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"方法区（永久代）\"><a href=\"#方法区（永久代）\" class=\"headerlink\" title=\"方法区（永久代）\"></a>方法区（永久代）</h3><p>用于存储已被 VM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了类的版本、字段、方法、接口等描述信息外，还有常量池，用于存放编译期生成的各种字面量和符号引用，在类加载后存放。</p>\n<h4 id=\"常量池溢出\"><a href=\"#常量池溢出\" class=\"headerlink\" title=\"常量池溢出\"></a>常量池溢出</h4><p>VM 参数：-XX:Permsize=10M -XX:MaxPermSize=10M</p>\n<p>使用 List 保持着常量池引用，避免 Full GC 回收。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuntimeConstantPoolOOM</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            list.add(String.valueOf(i++).intern());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法区溢出\"><a href=\"#方法区溢出\" class=\"headerlink\" title=\"方法区溢出\"></a>方法区溢出</h4><p>运行时产生大量的类去填满方法区，直到溢出。eg：利用 CGLib 直接操作字节码运行时生成大量的动态类。当前很多主流的框架，在对类进行增强时，都会使用到 CGLib 这类字节码技术，增强的类越多，需要越大的方法区空间来保证动态生成的 Class 可以加载到内存。</p>\n<h3 id=\"执行引擎（Execution-Engine\"><a href=\"#执行引擎（Execution-Engine\" class=\"headerlink\" title=\"执行引擎（Execution Engine)\"></a>执行引擎（Execution Engine)</h3><p>主要有即时编译器（JITCompiler）和 垃圾收集（Garbage Collection）两部分组成。解释器和编译器都是将 Java 生成 .class 的字节码，解析成 cpu 所能执行的二进制指令。区别在于解释器是一行一行解释字节码指令（效率低），无需编译（编译需要很长时间），立刻执行。 jvm 启动的时候非常快，这时候用的是解释器，这样的话可以减少编译的时间，且不会出现较长的卡顿，并且随着程序运行的时间推移，即时编译时发生了作用，通过热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。</p>\n<p>垃圾回收名词解释：</p>\n<ul>\n<li>串行回收（Serial）：单线程回收，STW 暂停所有用户线程，独占式回收。</li>\n<li>并行回收（Parallel）：线程并行工作，STW，独占式回收。</li>\n<li>并发回收（CMS）：GC 线程和用户线程同时进行，用户线程停顿时间很短。</li>\n</ul>\n<h4 id=\"Serial-收集器\"><a href=\"#Serial-收集器\" class=\"headerlink\" title=\"Serial 收集器\"></a>Serial 收集器</h4><p>单线程，没有线程交互的开销，消耗内存少，STW 时间长。使用 -XX:+UseSerialGC 来开启。</p>\n<h4 id=\"ParNew-收集器\"><a href=\"#ParNew-收集器\" class=\"headerlink\" title=\"ParNew 收集器\"></a>ParNew 收集器</h4><p>多线程版的 Serial 收集器，新生代采用复制算法（多线程执行），老年代采用标记整理算法（单线程），在收集算法、STW、对象分配规则、回收策略等都与 serial一样。使用 -XX:UseParNewGC 来开启，使用 </p>\n<p>-XX:ParallelGCThreads 指定线程数量，一般设置和CPU数量 一样。</p>\n<h4 id=\"Parallel-Scavenge收集器\"><a href=\"#Parallel-Scavenge收集器\" class=\"headerlink\" title=\"Parallel Scavenge收集器\"></a>Parallel Scavenge收集器</h4><p>ParNew 和 CMS 收集器关注的是如何缩短垃圾收集时用户线程的停顿时间。Parallel Scavenge 关注的是吞吐量。<br>$$<br>吞吐量 = \\frac {用户执行代码的时间}{用户执行代码的时间 + 垃圾收集的时间}<br>$$</p>\n<h4 id=\"CMS-（Concurrent-Mark-Sweep）收集器\"><a href=\"#CMS-（Concurrent-Mark-Sweep）收集器\" class=\"headerlink\" title=\"CMS （Concurrent Mark Sweep）收集器\"></a>CMS （Concurrent Mark Sweep）收集器</h4><p>最短停顿时间的垃圾收集器，基于标记清除算法实现的，包括四个过程</p>\n<ul>\n<li>初始标记：STW，速度快。</li>\n<li>并发标记 ：与用户线程并发执行。</li>\n<li>重新标记 ：STW，修正并发标记期间因用户继续运作而导致标记产生变动的那一部分对象的标记记录。</li>\n<li>并发清除 ：与用户线程并发执行。</li>\n</ul>\n<p>优点：并发收集器，STW 低停顿。<br>缺点：CMS 对处理器资源十分敏感，无法处理浮动垃圾，导致 Full GC 出现，内存碎片严重，会给内存分配带来巨大压力。</p>\n<h4 id=\"Garbage-First-收集器\"><a href=\"#Garbage-First-收集器\" class=\"headerlink\" title=\"Garbage First 收集器\"></a>Garbage First 收集器</h4><p>包括四个过程:</p>\n<ul>\n<li>初始标记（Initial Marking）</li>\n<li>并发标记（Concurrent Marking）</li>\n<li>最终标记（Final Marking）</li>\n<li>筛选回收（Live Data Counting and Evacuation）</li>\n</ul>\n<p>G1 收集器的特定：</p>\n<ul>\n<li>并行与并发，缩短 STW 停顿时间。</li>\n<li>分代收集。</li>\n<li>空间整理，标记整理算法，复制算法，不会产生内存碎片。</li>\n<li>可预测的停顿。</li>\n</ul>\n<p>两个收集器之间如果存在连线，就说明它们可以搭配使用，根据具体应用选择最合适的收集器。</p>\n<p><img src=\"https://img.gejiba.com/images/2f218fd75b0d81c901770faf2252bfc9.png\" alt=\"2f218fd75b0d81c901770faf2252bfc9.png\"></p>\n<h3 id=\"JDK-命令行工具\"><a href=\"#JDK-命令行工具\" class=\"headerlink\" title=\"JDK 命令行工具\"></a>JDK 命令行工具</h3><ul>\n<li>jps（JVM Process Status）: 类似 UNIX 的 ps 命令。用于查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；</li>\n<li>jstat（JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据；</li>\n<li>jinfo（Configuration Info for Java） : Configuration Info for Java，显示虚拟机配置信息；</li>\n<li>jmap（Memory Map for Java）: 生成堆转储快照；</li>\n<li>jhat（JVM Heap Dump Browser） : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果；</li>\n<li>jstack（Stack Trace for Java）: 生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"运行时数据区域\"><a href=\"#运行时数据区域\" class=\"headerlink\" title=\"运行时数据区域\"></a>运行时数据区域</h3><p>HotSpot 虚拟机</p>\n<p><img src=\"https://img.gejiba.com/images/61739beeb3810e7c2ae5e30bb5980584.png\" alt=\"61739beeb3810e7c2ae5e30bb5980584.png\"></p>\n<p>JAVA 1.8 移除方法区，移到了本地内存的元空间。</p>\n<p><img src=\"https://img.gejiba.com/images/5249b2be8bc23b68fc0b388a0fcd1485.png\" alt=\"5249b2be8bc23b68fc0b388a0fcd1485.png\"></p>\n<h3 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h3><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令、分支、循环、</p>\n<p>跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。为什么需要程序计数器？程序一般都是多线程执行，JVM多线程是通过 CPU 时间片切换来实现，如果某个线程在执行的过程中挂起，当再次获取时间片时，字节码解释器需要从挂起的位置继续执行，程序计数器可以用来记录执行位置。</p>\n<p>特点：</p>\n<ol>\n<li>线程隔离</li>\n<li>内存小</li>\n<li>不会造成 OOM</li>\n<li>记录程序执行字节码的地址</li>\n<li>执行 Native 本地方法，值为空。通过 JNI 调用本地 C++、C 库来实现。</li>\n</ol>\n<h3 id=\"虚拟机栈\"><a href=\"#虚拟机栈\" class=\"headerlink\" title=\"虚拟机栈\"></a>虚拟机栈</h3><p>每个方法执行都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。下图是运行时栈帧结构。</p>\n<p><img src=\"https://img.gejiba.com/images/f333c830ac58ac1de49ccda5230081d5.png\" alt=\"f333c830ac58ac1de49ccda5230081d5.png\"></p>\n<h4 id=\"局部变量表\"><a href=\"#局部变量表\" class=\"headerlink\" title=\"局部变量表\"></a>局部变量表</h4><p>局部变量表用于存放方法参数和方法内部定义的局部变量，包括各种基本数据类型（boolean、byte、char、short、int、float、long、double、对象引用 reference类型）。</p>\n<p>局部变量表 Slot 复用对垃圾收集的影响，参考代码，启动参数添加 -verbose:gc</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">byte</span>[] placeholder = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">64</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// int a = 1; // 新加一个赋值操作</span></span><br><span class=\"line\">    System.gc();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>发现并没有被回收，因为方法里面局部变量 placeholder 的 Slot 没有被其它变量复用，即使离开了方法的作用域，它仍然是一个 GC Root，取消上面注释能正常回收或者添加参数 -verbose:gc -Xcomp，在经过 JIT 编译优化后，上面代码可以正常回收，无需添加赋值操作。</p>\n<h4 id=\"操作数栈\"><a href=\"#操作数栈\" class=\"headerlink\" title=\"操作数栈\"></a>操作数栈</h4><p>操作数栈的每一个元素可以是任意的 Java 数据类型。当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指令往操作数栈中写入和提取，也就是出站和入栈。通过 javap -c 命令可以查看 class 文件的反编译指令，可分析方法如果执行字节码指令。在程序编译完成生成 class 文件之后，可以确定局部变量表的大小，以及操作数栈的大小。</p>\n<h4 id=\"动态链接\"><a href=\"#动态链接\" class=\"headerlink\" title=\"动态链接\"></a>动态链接</h4><p>​        每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。Class 文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。</p>\n<h4 id=\"返回地址\"><a href=\"#返回地址\" class=\"headerlink\" title=\"返回地址\"></a>返回地址</h4><p>当一个方法开始执行后，只有两种方式可以退出这个方法。第一种是执行引擎遇到任意一个方法返回的字节码指令。另一种是方法执行过程中遇到异常，并且这个异常没有在方法体内得到处理。方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用栈帧的操作数栈中，调用 PC 计数器的值指向方法调用指令后的一条指令等。</p>\n<h4 id=\"虚拟机栈溢出\"><a href=\"#虚拟机栈溢出\" class=\"headerlink\" title=\"虚拟机栈溢出\"></a>虚拟机栈溢出</h4><p>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 StackOverflowError 异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JavaVMStackSOF</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">stackLength</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">stackLeak</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        stackLength++;</span><br><span class=\"line\">        stackLeak();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">JavaVMStackSOF</span> <span class=\"variable\">oom</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JavaVMStackSOF</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            oom.stackLeak();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;stack length: &quot;</span> + oom.stackLength);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>VM 参数分别设置  -Xms256m -Xmx256m -Xmn128m -Xss256k 和 设置 -Xms256m -Xmx256m -Xmn128m -Xss512k，查看运行结果（stack length 变大），随着线程栈的大小越大，能够支持越多的方法调用，也就是能够存储更多的栈帧，栈帧越多越耗内存。</p>\n<table>\n<thead>\n<tr>\n<th>参数说明</th>\n<th>含义</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-Xms</td>\n<td>初始堆大小</td>\n<td>默认（MinHeapFreeRatio / -Xminf 参数可以调整）空余堆内存小于40%时，JVM 就会增大堆直到 -Xmx 的最大限制。</td>\n</tr>\n<tr>\n<td>-Xmx</td>\n<td>最大堆大小</td>\n<td>默认（MaxHeapFreeRatio / -Xmaxf 参数可以调整）空余堆内存大于 70% 时，JVM 会减少堆直到 -Xms的最小限制</td>\n</tr>\n<tr>\n<td>-Xmn</td>\n<td>年轻代大小</td>\n<td>Eden + 2 survivor space</td>\n</tr>\n<tr>\n<td>-Xss</td>\n<td>线程的堆栈大小</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>在 stackLeak 方法增加参数，栈帧中的本地变量表就会增加，对应的栈帧内存就越大，栈的深度反而变小。</p>\n<p>下面代码为创建线程导致内存溢出异常，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JavaVMStackOOM</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">notStop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">stackLeakByThread</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">thread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(JavaVMStackOOM::notStop);</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">JavaVMStackOOM</span> <span class=\"variable\">oom</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JavaVMStackOOM</span>();</span><br><span class=\"line\">        oom.stackLeakByThread();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个异常是由于操作系统没有足够的资源来产生这个线程造成的，虚拟机提供了参数来控制 Java 堆（Xmx）和方法区（MaxPermSize）的内存最大值。程序计数器消耗内存非常小，如果不计算虚拟机本身耗费的内存，剩下的内存就由虚拟机栈和本地方法栈来瓜分，每个线程分配的栈容量越大，线程数量就越少，建立线程就很容易耗尽内存。考虑这种情况，</p>\n<ul>\n<li><p>可以重新设计系统减少线程数量</p>\n</li>\n<li><p>减少最大堆和减少栈容量来换取更多的线程。</p>\n</li>\n</ul>\n<h3 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h3><p>堆是垃圾收集器管理的主要区域，也叫 GC 堆 （Garbage Collected Heap）。如果收集器采用的是分代垃圾收集算法，则堆可细分为：新生代（Eden、Survivor），老年代。在 JDK 7版本之前，还增加了永久代 （Permanent Generation），JDK 8 版本后 PermGen 已被元空间（Metaspace）取代，使用的是直接内存（不是 JVM 管控）</p>\n<p><img src=\"https://img.gejiba.com/images/e9c92acf8383df44e7beedbe095877a5.png\" alt=\"e9c92acf8383df44e7beedbe095877a5.png\"></p>\n<h4 id=\"堆扩展\"><a href=\"#堆扩展\" class=\"headerlink\" title=\"堆扩展\"></a>堆扩展</h4><p>如果以下三个条件之一为 true，那么堆的活动部分将扩展为最大值。</p>\n<ul>\n<li><p>垃圾收集器未释放足够的存储空间来满足分配请求。</p>\n</li>\n<li><p>可用空间小于使用  -Xminf 参数设置的最小可用空间。缺省值为 30%。</p>\n</li>\n<li><p>垃圾回收所用时间超过使用 -Xmaxt  参数设置的最大时间阈值。缺省值为 13%。</p>\n</li>\n</ul>\n<h4 id=\"堆压缩\"><a href=\"#堆压缩\" class=\"headerlink\" title=\"堆压缩\"></a>堆压缩</h4><p>如果以下所有情况都为 true，那么在收缩前将发生压缩：</p>\n<ul>\n<li>在此垃圾回收周期中，未完成压缩。</li>\n<li>在堆末端无可用块，或者堆末端可用块的大小小于所需的收缩量的 10%。</li>\n<li>在上一个垃圾回收周期中，GC 未收缩或压缩。</li>\n</ul>\n<h4 id=\"如果调整堆大小\"><a href=\"#如果调整堆大小\" class=\"headerlink\" title=\"如果调整堆大小\"></a>如果调整堆大小</h4><p>垃圾收集器会因以下原因调整堆大小以将占用率保持在 40% 到 70% 之间：</p>\n<ul>\n<li>堆占用率大于 70% 会导致更频繁的 GC 周期，致使性能降低。您可以通过设置 -Xminf  选项来变更此行为。</li>\n<li>堆占用率小于 40% 意味着不频繁的 GC 周期。但是，这些周期会超过必需时间而导致更长的暂停时间，致使性能降低。您可以通过设置  -Xmaxf  选项来变更此行为。</li>\n</ul>\n<p>在无负载但又具有压力的情况下运行应用程序时，您可以使用  -verbose:gc （垃圾收集时的信息打印 -XX:+PrintGC） 来帮助您设置初始堆大小 -Xms 和最大堆大小 -Xmx 。</p>\n<h4 id=\"堆溢出\"><a href=\"#堆溢出\" class=\"headerlink\" title=\"堆溢出\"></a>堆溢出</h4><p>VM 参数：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HeapOOM</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OOMObjct</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        List&lt;OOMObjct&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">OOMObjct</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.OutOfMemoryError: Java heap space</span><br><span class=\"line\">Dumping heap to java_pid39288.hprof ...</span><br><span class=\"line\">Heap dump file created [28183701 bytes in 0.169 secs]</span><br></pre></td></tr></table></figure>\n\n<p>得到 Dump 文件，利用  jhat -J-Xmx1024m dump文件 命令分析，jhat 命令实际上会启动一个 JVM 来执行, 通过 -J 可以在启动 JVM 时传入一些启动参数，默认端口 7000。通过内存映像分析工具判断是内存溢出（系统没有足够的内存分配使用）还是内存泄露（程序分配的对象没有及时回收，或者永久不回收，无法释放已申请的内存空间，这些一般都是 GC 可达但是无用的对象）。内存泄露和内存溢出都会导致应用程序运行出现问题，性能下降或挂起。内存泄露是导致内存溢出的原因之一，内存泄露积累起来将导致内存溢出。内存泄露可以通过完善代码来避免，内存溢出可以通过调整配置来减少发生频率，但无法彻底避免。</p>\n<p>如果是内存泄露，通过工具查看泄露对象到 GC Roots 的引用链，分析出泄露对象是通过怎么样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收。掌握了泄露对象的类型信息及 GC Root 引用链信息，可以定位到泄露代码的位置。</p>\n<p>如果是内存溢出，那就说明对象可用，必须存活。应当检查 VM 的参数（-Xmx 与 -Xms），机器物理内存是否可以调大，代码检查是否存在某些对象生命周期过长，持有状态时间过长。</p>\n<h4 id=\"对象在堆区的生命周期\"><a href=\"#对象在堆区的生命周期\" class=\"headerlink\" title=\"对象在堆区的生命周期\"></a>对象在堆区的生命周期</h4><p>对象优先在 Eden 区分配，当 Eden 区没有足够的空间进行分配时，VM 将发起一次 Minor GC。参考代码，设置 VM 参数  -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</p>\n<p> -XX:+PrintGCDateStamps -Xloggc:gc.log</p>\n<ul>\n<li>-XX:PrintGCTimeStamps：打印 GC 具体时间；</li>\n<li>-XX:PrintGCDetails ：打印出 GC 详细日志；</li>\n<li>-Xloggc: path：GC 日志生成路径。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">_1MB</span> <span class=\"operator\">=</span> <span class=\"number\">1024</span> * <span class=\"number\">1024</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">byte</span>[] b1, b2, b3, b4;</span><br><span class=\"line\">    b1 = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">2</span> * _1MB];</span><br><span class=\"line\">    b2 = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">2</span> * _1MB];</span><br><span class=\"line\">    b3 = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">2</span> * _1MB];</span><br><span class=\"line\">    <span class=\"comment\">// 出现一次 Minor GC</span></span><br><span class=\"line\">    b4 = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">4</span> * _1MB];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>配置新生代 10M（Eden 8M，From Survivor 1M，To Survivor 1M），老年代 10M，新生代总可用空间为 9M，</p>\n<p>Eden区 + 1个 Survivor 区的总容量。三个 2M 的对象，1个 4M 的对象，当 Eden 区占用 6M 的时候无法分配 4M的内存给 b4，触发一次 Minor GC，而三个 2M 的对象无法放入 Survivor 空间，通过分配担保机制提前移动到老年代去。GC 结束后，Eden 占 4M，Survivor 空闲，老年代占 6M。</p>\n<p><img src=\"https://img.gejiba.com/images/0bca81fb264d5dc53219946b5f1e9024.png\" alt=\"0bca81fb264d5dc53219946b5f1e9024.png\"></p>\n<p>通过配置 -XX:PretenureSizeThreshold 设置大对象的阀值，例如：-XX:PretenureSizeThreshold=3145728，当对象大于 3M 的时候直接分配到老年代，减少新生代的垃圾回收。</p>\n<p>通过配置 -XX:MaxTenuringThreshold 设置对象年龄计数器，当年龄到达设置的阀值，直接分配到老年代。（当 Eden 空间不足时，VM 触发 Minor GC，存活的对象转移到 Survivor区，对象年龄 +1，Survivor区的对象也会经历 Minor GC，对象年龄 +1）。</p>\n<p>为了能更好的适应不同程序的内存状况，VM 不是永远地要求对象的年龄必须达到设置的年龄值才能晋升老年代，如果在 Survivor 空间中的相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或者等于这些对象的对象将直接进入老年代。（动态对象年龄判断机制）</p>\n<h4 id=\"内存分配调优\"><a href=\"#内存分配调优\" class=\"headerlink\" title=\"内存分配调优\"></a>内存分配调优</h4><ol>\n<li><p>压测工具进行压测（eg：ab 工具），分析请求接口吞吐量、并发连接数、响应时间等。</p>\n</li>\n<li><p>分析 GC 日志，通过设置 VM配置参数 -XX:+HeapDumpOnOutOfMemoryError ，或者通过 jmap 命令获取 dump文件 。频繁的 GC 将会引起线程的上下文切换，导致系统吞吐量下降，GC 的 持续时间也会影响请求的响应时间。通过合理分配堆的新生代、老年代内存大小，减少 Minor GC 及 Full GC 频率及时长。</p>\n<p>说明：</p>\n<ul>\n<li>在设置 Eden、Survivor 区比例的时候，如果开启 AdaptiveSizePolicy，则每次 GC 后都会重新计算 Eden、From Survivor 和 To Survivor 区的大小，依据 GC 过程中统计的 GC 时间、吞吐量、内存占用量。导致SurvivorRatio 默认设置的比例会失效。在 JDK1.8 中，默认是开启 AdaptiveSizePolicy 的，通过 -XX:-UseAdaptiveSizePolicy 关闭该项配置，或显示运行 -XX:SurvivorRatio=8 将 Eden、Survivor 的比例设置为 8:2。</li>\n<li>一般先优化代码，减少大对象的数量及减少使用全局变量。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"方法区（永久代）\"><a href=\"#方法区（永久代）\" class=\"headerlink\" title=\"方法区（永久代）\"></a>方法区（永久代）</h3><p>用于存储已被 VM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了类的版本、字段、方法、接口等描述信息外，还有常量池，用于存放编译期生成的各种字面量和符号引用，在类加载后存放。</p>\n<h4 id=\"常量池溢出\"><a href=\"#常量池溢出\" class=\"headerlink\" title=\"常量池溢出\"></a>常量池溢出</h4><p>VM 参数：-XX:Permsize=10M -XX:MaxPermSize=10M</p>\n<p>使用 List 保持着常量池引用，避免 Full GC 回收。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RuntimeConstantPoolOOM</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            list.add(String.valueOf(i++).intern());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法区溢出\"><a href=\"#方法区溢出\" class=\"headerlink\" title=\"方法区溢出\"></a>方法区溢出</h4><p>运行时产生大量的类去填满方法区，直到溢出。eg：利用 CGLib 直接操作字节码运行时生成大量的动态类。当前很多主流的框架，在对类进行增强时，都会使用到 CGLib 这类字节码技术，增强的类越多，需要越大的方法区空间来保证动态生成的 Class 可以加载到内存。</p>\n<h3 id=\"执行引擎（Execution-Engine\"><a href=\"#执行引擎（Execution-Engine\" class=\"headerlink\" title=\"执行引擎（Execution Engine)\"></a>执行引擎（Execution Engine)</h3><p>主要有即时编译器（JITCompiler）和 垃圾收集（Garbage Collection）两部分组成。解释器和编译器都是将 Java 生成 .class 的字节码，解析成 cpu 所能执行的二进制指令。区别在于解释器是一行一行解释字节码指令（效率低），无需编译（编译需要很长时间），立刻执行。 jvm 启动的时候非常快，这时候用的是解释器，这样的话可以减少编译的时间，且不会出现较长的卡顿，并且随着程序运行的时间推移，即时编译时发生了作用，通过热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。</p>\n<p>垃圾回收名词解释：</p>\n<ul>\n<li>串行回收（Serial）：单线程回收，STW 暂停所有用户线程，独占式回收。</li>\n<li>并行回收（Parallel）：线程并行工作，STW，独占式回收。</li>\n<li>并发回收（CMS）：GC 线程和用户线程同时进行，用户线程停顿时间很短。</li>\n</ul>\n<h4 id=\"Serial-收集器\"><a href=\"#Serial-收集器\" class=\"headerlink\" title=\"Serial 收集器\"></a>Serial 收集器</h4><p>单线程，没有线程交互的开销，消耗内存少，STW 时间长。使用 -XX:+UseSerialGC 来开启。</p>\n<h4 id=\"ParNew-收集器\"><a href=\"#ParNew-收集器\" class=\"headerlink\" title=\"ParNew 收集器\"></a>ParNew 收集器</h4><p>多线程版的 Serial 收集器，新生代采用复制算法（多线程执行），老年代采用标记整理算法（单线程），在收集算法、STW、对象分配规则、回收策略等都与 serial一样。使用 -XX:UseParNewGC 来开启，使用 </p>\n<p>-XX:ParallelGCThreads 指定线程数量，一般设置和CPU数量 一样。</p>\n<h4 id=\"Parallel-Scavenge收集器\"><a href=\"#Parallel-Scavenge收集器\" class=\"headerlink\" title=\"Parallel Scavenge收集器\"></a>Parallel Scavenge收集器</h4><p>ParNew 和 CMS 收集器关注的是如何缩短垃圾收集时用户线程的停顿时间。Parallel Scavenge 关注的是吞吐量。<br>$$<br>吞吐量 = \\frac {用户执行代码的时间}{用户执行代码的时间 + 垃圾收集的时间}<br>$$</p>\n<h4 id=\"CMS-（Concurrent-Mark-Sweep）收集器\"><a href=\"#CMS-（Concurrent-Mark-Sweep）收集器\" class=\"headerlink\" title=\"CMS （Concurrent Mark Sweep）收集器\"></a>CMS （Concurrent Mark Sweep）收集器</h4><p>最短停顿时间的垃圾收集器，基于标记清除算法实现的，包括四个过程</p>\n<ul>\n<li>初始标记：STW，速度快。</li>\n<li>并发标记 ：与用户线程并发执行。</li>\n<li>重新标记 ：STW，修正并发标记期间因用户继续运作而导致标记产生变动的那一部分对象的标记记录。</li>\n<li>并发清除 ：与用户线程并发执行。</li>\n</ul>\n<p>优点：并发收集器，STW 低停顿。<br>缺点：CMS 对处理器资源十分敏感，无法处理浮动垃圾，导致 Full GC 出现，内存碎片严重，会给内存分配带来巨大压力。</p>\n<h4 id=\"Garbage-First-收集器\"><a href=\"#Garbage-First-收集器\" class=\"headerlink\" title=\"Garbage First 收集器\"></a>Garbage First 收集器</h4><p>包括四个过程:</p>\n<ul>\n<li>初始标记（Initial Marking）</li>\n<li>并发标记（Concurrent Marking）</li>\n<li>最终标记（Final Marking）</li>\n<li>筛选回收（Live Data Counting and Evacuation）</li>\n</ul>\n<p>G1 收集器的特定：</p>\n<ul>\n<li>并行与并发，缩短 STW 停顿时间。</li>\n<li>分代收集。</li>\n<li>空间整理，标记整理算法，复制算法，不会产生内存碎片。</li>\n<li>可预测的停顿。</li>\n</ul>\n<p>两个收集器之间如果存在连线，就说明它们可以搭配使用，根据具体应用选择最合适的收集器。</p>\n<p><img src=\"https://img.gejiba.com/images/2f218fd75b0d81c901770faf2252bfc9.png\" alt=\"2f218fd75b0d81c901770faf2252bfc9.png\"></p>\n<h3 id=\"JDK-命令行工具\"><a href=\"#JDK-命令行工具\" class=\"headerlink\" title=\"JDK 命令行工具\"></a>JDK 命令行工具</h3><ul>\n<li>jps（JVM Process Status）: 类似 UNIX 的 ps 命令。用于查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；</li>\n<li>jstat（JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据；</li>\n<li>jinfo（Configuration Info for Java） : Configuration Info for Java，显示虚拟机配置信息；</li>\n<li>jmap（Memory Map for Java）: 生成堆转储快照；</li>\n<li>jhat（JVM Heap Dump Browser） : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果；</li>\n<li>jstack（Stack Trace for Java）: 生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</li>\n</ul>\n"},{"title":"自我介绍","date":"2022-05-14T08:55:33.000Z","_content":"\n面试官，您好。我叫康盼，毕业于东华理工大学，软件工程学位。至今有5年多的互联网 Java开发工作经验，主要从事有软件服务咨询、制造等业务领域，在项目中使用的技术框架主要有 Spring、SpringClound、Mybatis、Oracle、Mysql 最近在项目中参与过较多设计，在设计方面有一定的优势。先简单介绍这里，谢谢。\n\n\n\n1. 面试的问题记录\n   1. 高并发\n   2. 设计模式 单例\n   3. 内存泄露\n   4. 中间件 保证消息不丢失\n   5. 分布式事务\n   6. 主键外键设计\n   7. SDD 拆分\n   8. 注册中心用的哪些，他们  的区别\n   9. 贫血模式 充血模式\n   10. JUC\n   11. Spring 单例属性安全\n   12. 集群，系统拆分\n   13. DTO BO DO\n   14. Spring 注解\n   15. Mysql 的 innodb myisam 区别\n   16. 序列化\n   17. CAP\n   18. 遇到最难解决的BUG，怎么解决的\n   19. 未来职业规划，职业发展\n   20. 你想要找一个什么样的工作\n   21. 多租户设计\n   22. SAAS\n   23. CSM 和 G1 \n   24. 高并发，多线程\n   25. Ribbon 负载均衡\n   26. Feign 框架\n   27. AOP 代理底层\n   28. Spring 自动装配\n   29. 消息中间件 kafaka\n   30. Spring 事务隔离级别\n   31. Spring Cloud 组件介绍\n   32. 服务注册与发现的原理\n   33. AOP @Around 和 @beforeAfter 的区别\n   34. MySQL 调用\n   35. Spring 怎么导致事务失效\n   36. Kafka数据可靠性\n   37. Spring 怎么保证事务的\n   38. MySQL #{} ${} 符号区别\n   39. 服务down机这种情况\n   40. Euraka 保护机制\n   41. 线程加入队列怎么执行\n   42. 数据库针对不同用户显示不同字段怎么做\n   43. 用户请求慢了怎么排查\n\n","source":"_posts/自我介绍.md","raw":"---\ntitle: 自我介绍\ndate: 2022-05-14 16:55:33\ntags: Other\n---\n\n面试官，您好。我叫康盼，毕业于东华理工大学，软件工程学位。至今有5年多的互联网 Java开发工作经验，主要从事有软件服务咨询、制造等业务领域，在项目中使用的技术框架主要有 Spring、SpringClound、Mybatis、Oracle、Mysql 最近在项目中参与过较多设计，在设计方面有一定的优势。先简单介绍这里，谢谢。\n\n\n\n1. 面试的问题记录\n   1. 高并发\n   2. 设计模式 单例\n   3. 内存泄露\n   4. 中间件 保证消息不丢失\n   5. 分布式事务\n   6. 主键外键设计\n   7. SDD 拆分\n   8. 注册中心用的哪些，他们  的区别\n   9. 贫血模式 充血模式\n   10. JUC\n   11. Spring 单例属性安全\n   12. 集群，系统拆分\n   13. DTO BO DO\n   14. Spring 注解\n   15. Mysql 的 innodb myisam 区别\n   16. 序列化\n   17. CAP\n   18. 遇到最难解决的BUG，怎么解决的\n   19. 未来职业规划，职业发展\n   20. 你想要找一个什么样的工作\n   21. 多租户设计\n   22. SAAS\n   23. CSM 和 G1 \n   24. 高并发，多线程\n   25. Ribbon 负载均衡\n   26. Feign 框架\n   27. AOP 代理底层\n   28. Spring 自动装配\n   29. 消息中间件 kafaka\n   30. Spring 事务隔离级别\n   31. Spring Cloud 组件介绍\n   32. 服务注册与发现的原理\n   33. AOP @Around 和 @beforeAfter 的区别\n   34. MySQL 调用\n   35. Spring 怎么导致事务失效\n   36. Kafka数据可靠性\n   37. Spring 怎么保证事务的\n   38. MySQL #{} ${} 符号区别\n   39. 服务down机这种情况\n   40. Euraka 保护机制\n   41. 线程加入队列怎么执行\n   42. 数据库针对不同用户显示不同字段怎么做\n   43. 用户请求慢了怎么排查\n\n","slug":"自我介绍","published":1,"updated":"2022-05-24T23:44:29.999Z","_id":"cl35pld2w00002klngjm1ffw3","comments":1,"layout":"post","photos":[],"link":"","content":"<p>面试官，您好。我叫康盼，毕业于东华理工大学，软件工程学位。至今有5年多的互联网 Java开发工作经验，主要从事有软件服务咨询、制造等业务领域，在项目中使用的技术框架主要有 Spring、SpringClound、Mybatis、Oracle、Mysql 最近在项目中参与过较多设计，在设计方面有一定的优势。先简单介绍这里，谢谢。</p>\n<ol>\n<li>面试的问题记录<ol>\n<li>高并发</li>\n<li>设计模式 单例</li>\n<li>内存泄露</li>\n<li>中间件 保证消息不丢失</li>\n<li>分布式事务</li>\n<li>主键外键设计</li>\n<li>SDD 拆分</li>\n<li>注册中心用的哪些，他们  的区别</li>\n<li>贫血模式 充血模式</li>\n<li>JUC</li>\n<li>Spring 单例属性安全</li>\n<li>集群，系统拆分</li>\n<li>DTO BO DO</li>\n<li>Spring 注解</li>\n<li>Mysql 的 innodb myisam 区别</li>\n<li>序列化</li>\n<li>CAP</li>\n<li>遇到最难解决的BUG，怎么解决的</li>\n<li>未来职业规划，职业发展</li>\n<li>你想要找一个什么样的工作</li>\n<li>多租户设计</li>\n<li>SAAS</li>\n<li>CSM 和 G1 </li>\n<li>高并发，多线程</li>\n<li>Ribbon 负载均衡</li>\n<li>Feign 框架</li>\n<li>AOP 代理底层</li>\n<li>Spring 自动装配</li>\n<li>消息中间件 kafaka</li>\n<li>Spring 事务隔离级别</li>\n<li>Spring Cloud 组件介绍</li>\n<li>服务注册与发现的原理</li>\n<li>AOP @Around 和 @beforeAfter 的区别</li>\n<li>MySQL 调用</li>\n<li>Spring 怎么导致事务失效</li>\n<li>Kafka数据可靠性</li>\n<li>Spring 怎么保证事务的</li>\n<li>MySQL #{} ${} 符号区别</li>\n<li>服务down机这种情况</li>\n<li>Euraka 保护机制</li>\n<li>线程加入队列怎么执行</li>\n<li>数据库针对不同用户显示不同字段怎么做</li>\n<li>用户请求慢了怎么排查</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>面试官，您好。我叫康盼，毕业于东华理工大学，软件工程学位。至今有5年多的互联网 Java开发工作经验，主要从事有软件服务咨询、制造等业务领域，在项目中使用的技术框架主要有 Spring、SpringClound、Mybatis、Oracle、Mysql 最近在项目中参与过较多设计，在设计方面有一定的优势。先简单介绍这里，谢谢。</p>\n<ol>\n<li>面试的问题记录<ol>\n<li>高并发</li>\n<li>设计模式 单例</li>\n<li>内存泄露</li>\n<li>中间件 保证消息不丢失</li>\n<li>分布式事务</li>\n<li>主键外键设计</li>\n<li>SDD 拆分</li>\n<li>注册中心用的哪些，他们  的区别</li>\n<li>贫血模式 充血模式</li>\n<li>JUC</li>\n<li>Spring 单例属性安全</li>\n<li>集群，系统拆分</li>\n<li>DTO BO DO</li>\n<li>Spring 注解</li>\n<li>Mysql 的 innodb myisam 区别</li>\n<li>序列化</li>\n<li>CAP</li>\n<li>遇到最难解决的BUG，怎么解决的</li>\n<li>未来职业规划，职业发展</li>\n<li>你想要找一个什么样的工作</li>\n<li>多租户设计</li>\n<li>SAAS</li>\n<li>CSM 和 G1 </li>\n<li>高并发，多线程</li>\n<li>Ribbon 负载均衡</li>\n<li>Feign 框架</li>\n<li>AOP 代理底层</li>\n<li>Spring 自动装配</li>\n<li>消息中间件 kafaka</li>\n<li>Spring 事务隔离级别</li>\n<li>Spring Cloud 组件介绍</li>\n<li>服务注册与发现的原理</li>\n<li>AOP @Around 和 @beforeAfter 的区别</li>\n<li>MySQL 调用</li>\n<li>Spring 怎么导致事务失效</li>\n<li>Kafka数据可靠性</li>\n<li>Spring 怎么保证事务的</li>\n<li>MySQL #{} ${} 符号区别</li>\n<li>服务down机这种情况</li>\n<li>Euraka 保护机制</li>\n<li>线程加入队列怎么执行</li>\n<li>数据库针对不同用户显示不同字段怎么做</li>\n<li>用户请求慢了怎么排查</li>\n</ol>\n</li>\n</ol>\n"},{"title":"PostProcess","date":"2022-05-14T10:31:18.000Z","_content":"\n\n\n方法中有处理主要业务场景的代码，还有调用其它业务场景的方法，这部分业务场景的代码相当于主流程的后置流程。后置流程越来越多的时候，主方法的代码就越来越繁重，越来越大。而且当主流程不需要某些后置流程的时候，或者修改某个后置流程执行的先后顺序，或者某些后置流程需要链式顺序执行还是并发执行，或者它执行失败后的一个异常补偿机制，补偿之后是进行执行下一个流程还是中断。这些后置流程也有可能被其它方法调用。\n\n为了解决这些问题，基于工作流的设计理论，工作流就是对业务的流程化抽象，用工作流的方式来规划和编排代码运行方式。当然市场上有很多开源的流程引擎，例如 activiti、flowable 等。为了更好的定制化及满足不同业务场景，实现了一套自己的工作流。\n\n\n\n怎么设计的？\n\n之前是在主流程方法里面去一个个调用后置流程的方法，现在把这部分方法改成一个个类。后置流程把它比作是一个个节点，节点包括类名，执行顺序，事务控制，异步还是同步，是否链式执行等信息。数据库我们是这样设计的，我们把这些信息存放到一张表里面，然后另一张表维护了主流程的信息，同时有个字段关联了节点信息。\n\n代码层方法，利用 Spring AOP，当主流程执行完后，查询出主流程有哪些后置流程节点，通过节点的类名，反射实例化对应的类，通过数据库配置的执行顺序去执行类里面的方法，利用 Spring 监听事件去做同步还是异步。 \n\n\n\n为什么要这么设计？\n\n当主流程不需要某些后置流程的时候，可以灵活的添加和删除。可以让主流程快速响应，后置流程异步调用等优势。\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/PostProcess.md","raw":"---\ntitle: PostProcess\ndate: 2022-05-14 18:31:18\ntags: Design\n---\n\n\n\n方法中有处理主要业务场景的代码，还有调用其它业务场景的方法，这部分业务场景的代码相当于主流程的后置流程。后置流程越来越多的时候，主方法的代码就越来越繁重，越来越大。而且当主流程不需要某些后置流程的时候，或者修改某个后置流程执行的先后顺序，或者某些后置流程需要链式顺序执行还是并发执行，或者它执行失败后的一个异常补偿机制，补偿之后是进行执行下一个流程还是中断。这些后置流程也有可能被其它方法调用。\n\n为了解决这些问题，基于工作流的设计理论，工作流就是对业务的流程化抽象，用工作流的方式来规划和编排代码运行方式。当然市场上有很多开源的流程引擎，例如 activiti、flowable 等。为了更好的定制化及满足不同业务场景，实现了一套自己的工作流。\n\n\n\n怎么设计的？\n\n之前是在主流程方法里面去一个个调用后置流程的方法，现在把这部分方法改成一个个类。后置流程把它比作是一个个节点，节点包括类名，执行顺序，事务控制，异步还是同步，是否链式执行等信息。数据库我们是这样设计的，我们把这些信息存放到一张表里面，然后另一张表维护了主流程的信息，同时有个字段关联了节点信息。\n\n代码层方法，利用 Spring AOP，当主流程执行完后，查询出主流程有哪些后置流程节点，通过节点的类名，反射实例化对应的类，通过数据库配置的执行顺序去执行类里面的方法，利用 Spring 监听事件去做同步还是异步。 \n\n\n\n为什么要这么设计？\n\n当主流程不需要某些后置流程的时候，可以灵活的添加和删除。可以让主流程快速响应，后置流程异步调用等优势。\n\n\n\n\n\n\n\n\n\n\n\n","slug":"PostProcess","published":1,"updated":"2022-05-24T23:50:26.495Z","_id":"cl3707ohw0000fslnbdmygyfu","comments":1,"layout":"post","photos":[],"link":"","content":"<p>方法中有处理主要业务场景的代码，还有调用其它业务场景的方法，这部分业务场景的代码相当于主流程的后置流程。后置流程越来越多的时候，主方法的代码就越来越繁重，越来越大。而且当主流程不需要某些后置流程的时候，或者修改某个后置流程执行的先后顺序，或者某些后置流程需要链式顺序执行还是并发执行，或者它执行失败后的一个异常补偿机制，补偿之后是进行执行下一个流程还是中断。这些后置流程也有可能被其它方法调用。</p>\n<p>为了解决这些问题，基于工作流的设计理论，工作流就是对业务的流程化抽象，用工作流的方式来规划和编排代码运行方式。当然市场上有很多开源的流程引擎，例如 activiti、flowable 等。为了更好的定制化及满足不同业务场景，实现了一套自己的工作流。</p>\n<p>怎么设计的？</p>\n<p>之前是在主流程方法里面去一个个调用后置流程的方法，现在把这部分方法改成一个个类。后置流程把它比作是一个个节点，节点包括类名，执行顺序，事务控制，异步还是同步，是否链式执行等信息。数据库我们是这样设计的，我们把这些信息存放到一张表里面，然后另一张表维护了主流程的信息，同时有个字段关联了节点信息。</p>\n<p>代码层方法，利用 Spring AOP，当主流程执行完后，查询出主流程有哪些后置流程节点，通过节点的类名，反射实例化对应的类，通过数据库配置的执行顺序去执行类里面的方法，利用 Spring 监听事件去做同步还是异步。 </p>\n<p>为什么要这么设计？</p>\n<p>当主流程不需要某些后置流程的时候，可以灵活的添加和删除。可以让主流程快速响应，后置流程异步调用等优势。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>方法中有处理主要业务场景的代码，还有调用其它业务场景的方法，这部分业务场景的代码相当于主流程的后置流程。后置流程越来越多的时候，主方法的代码就越来越繁重，越来越大。而且当主流程不需要某些后置流程的时候，或者修改某个后置流程执行的先后顺序，或者某些后置流程需要链式顺序执行还是并发执行，或者它执行失败后的一个异常补偿机制，补偿之后是进行执行下一个流程还是中断。这些后置流程也有可能被其它方法调用。</p>\n<p>为了解决这些问题，基于工作流的设计理论，工作流就是对业务的流程化抽象，用工作流的方式来规划和编排代码运行方式。当然市场上有很多开源的流程引擎，例如 activiti、flowable 等。为了更好的定制化及满足不同业务场景，实现了一套自己的工作流。</p>\n<p>怎么设计的？</p>\n<p>之前是在主流程方法里面去一个个调用后置流程的方法，现在把这部分方法改成一个个类。后置流程把它比作是一个个节点，节点包括类名，执行顺序，事务控制，异步还是同步，是否链式执行等信息。数据库我们是这样设计的，我们把这些信息存放到一张表里面，然后另一张表维护了主流程的信息，同时有个字段关联了节点信息。</p>\n<p>代码层方法，利用 Spring AOP，当主流程执行完后，查询出主流程有哪些后置流程节点，通过节点的类名，反射实例化对应的类，通过数据库配置的执行顺序去执行类里面的方法，利用 Spring 监听事件去做同步还是异步。 </p>\n<p>为什么要这么设计？</p>\n<p>当主流程不需要某些后置流程的时候，可以灵活的添加和删除。可以让主流程快速响应，后置流程异步调用等优势。</p>\n"},{"title":"Spring循环依赖","date":"2022-05-15T03:17:04.000Z","_content":"\n\n\n1. 什么是循环依赖，怎么判断是循环依赖？\n2. 有哪些循环依赖？\n3. 哪些可以解决，哪些不可以解决？\n4. 怎么解决？\n\n带着这几个问题，先想一想。\n\n\n\n以下是个人理解的答案。\n\n1. 什么是循环依赖？\n\n   回答这个问题之前，先简单介绍下 Bean 的生命周期。\n\n   ![6717ac3791eb6adb2c803bf036dec58d.png](https://img.gejiba.com/images/6717ac3791eb6adb2c803bf036dec58d.png)\n\n   \n\n如果对象与对象在属性填充的时候互相依赖，称之为循环依赖。那么 Spring 是怎么判断对象之间是循环依赖的呢？\n\n这里举个例子，\n\n```Java\n@Service\npublic class AService {\n\n    @Autowired\n    private BService bService;\n\n    public void fun() {\n    }\n}\n\n@Service\npublic class BService {\n\n    @Autowired\n    private AService aService;\n\n    public void fun() {\n    }\n}\n```\n\nAService 在实例化的时候会用一个 Set 集合标识该 Bean 是在创建中，Set 的 key 就是 Bean Name。当进行 BService 属性填充的时候，如果 BService 的属性（AService）存在这个 Set 集合中，说明它们之间存在依赖关系。\n\n\n\n2. 有哪些循环依赖？\n\n   - 普通的循环依赖，参考上面代码\n\n   - 多例的循环依赖\n\n     ```java\n     @Service\n     @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\n     public class AService {\n     \n         @Autowired\n         private BService bService;\n     \n         public void fun() {\n         }\n     }\n     \n     @Service\n     @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\n     public class BService {\n     \n         @Autowired\n         private AService aService;\n     \n         public void fun() {\n         }\n     }\n     ```\n\n     \n\n   - 构造的循环依赖\n\n     ```\n     @Service\n     public class AService {\n     \n         @Autowired\n         private AService(BService bSerivce){...}\n     \n         public void fun() {\n         }\n     }\n     \n     @Service\n     \n     public class BService {\n     \n         @Autowired\n         private BService(AService aSerivce){...}\n     \n         public void fun() {\n         }\n     }\n     ```\n\n   - 代理对象的循环依赖， @Async 注解 @Transactional 注解会产生代理对象，还有一些自己写的 AOP，对原始对象进行了增强。\n\n     ```java\n     @Service\n     public class AService {\n     \n         @Autowired\n         private BService bService;\n     \n         public void fun() {\n         }\n     }\n     \n     @Service\n     public class BService {\n     \n         @Autowired\n         private AService aService;\n     \n     \t@Async\n         public void fun() {\n         }\n     }\n     ```\n\n   - 指定加载顺序的循环依赖，AService 加上 @DependsOn 注解，指定 BSerivce 先加载，而 BService 又指定 AService 先加载。\n   \n     ```java\n     @Service\n     @DependsOn(value = \"BService\")\n     public class AService {\n     \n         @Autowired\n         private BService bService;\n     \n         public void fun() {\n         }\n     }\n     \n     @Service\n     @DependsOn(value = \"AService\")\n     public class BService {\n     \n         @Autowired\n         private AService aService;\n     \n         public void fun() {\n         }\n     }\n     ```\n\n3. 哪些可以解决？哪些不可以解决？\n\n   普通循环依赖、代理循环依赖及多例循环依赖、指定加载顺序的依赖可以解决。而构造循环依赖无法解决，因为两个对象都是有参构造，构造前都必须先实例化，存在构造依赖都无法先提前实例化（除非其中一个有无参构造）。\n\n4. 怎么解决？\n\n   - 普通对象依赖和代理对象依赖 ，Spring 框架使用三级缓存解决。\n\n   ![7ae02888247955b4e552a7761fd246b4.png](https://img.gejiba.com/images/7ae02888247955b4e552a7761fd246b4.png)\n\n   AService \n\n   1. 实例化对象：当获取 AService Bean 的时候先去一级缓存中查找，没有则实例化该对象，然后将获取 Bean 对象的 Lambda 方法存储到三级缓存中（代理对象依赖情况，属性填充的时候根据原始对象获取代理对象，提前进行 AOP），使用 Lambda 表达式是延迟处理，后期需要使用的时候才去处理。\n\n   2. 填充属性：填充 BService 属性。\n\n      BService\n\n      2.1 先去一级缓存中查找，没有则实例化该对象，同 AService 第一步。\n\n      2.2 填充属性：填充 AService 属性，先去二级缓存中查找，没有则从三级缓存创建对象，再把创建的对象放入二级缓存，删除三级缓存（Lambda 只需要执行一次，保持单例）。\n\n      2.3 其它属性填充\n\n      2.4 初始化操作\n\n      2.5 放入一级缓存\n\n      2.6 把 BService 从 Set 集合（标识正常创建中的 ）中移除。\n\n   3. 其它属性填充\n   4. 初始化操作\n   5. 放入一级缓存\n   6. 把 AService 从 Set 集合（标识正常创建中的 ）中移除。\n\n   \n\n   二级缓存是为了解决循环依赖的问题，也是为了满足对象单例。而三级缓存是为了解决代理循环依赖问题，虽然可以在对象实例化后进行代理，但是破坏了 Spring 的设计原则，将 AOP 设计在初始化阶段进行。而代理依赖需要在属性填充的时候进行 AOP，所以在实例化后创建了三级缓存，方便提前创建代理对象。\n\n   \n\n   虽然二级缓存是半成品，例如 BService 填充完 AService 的时候，AService 还没有执行其它属性填充等操作。但是当 AService 执行  3 和 4 步的时候，BService 里面的 AService 已经是成品了（对象引用）。\n\n   \n\n   当然有些代理循环依赖需要代码层修改，例如 @Async 注释的代理类需要在类上加上 @Lazy 注解解决，否则报错。\n\n   \n\n   - 多例循环依赖的修改单例可以解决，@DependsOn 注解的打破它不循环依赖可以解决。\n\n   \n","source":"_posts/Spring循环依赖.md","raw":"---\ntitle: Spring循环依赖\ndate: 2022-05-15 11:17:04\ntags: Spring\n---\n\n\n\n1. 什么是循环依赖，怎么判断是循环依赖？\n2. 有哪些循环依赖？\n3. 哪些可以解决，哪些不可以解决？\n4. 怎么解决？\n\n带着这几个问题，先想一想。\n\n\n\n以下是个人理解的答案。\n\n1. 什么是循环依赖？\n\n   回答这个问题之前，先简单介绍下 Bean 的生命周期。\n\n   ![6717ac3791eb6adb2c803bf036dec58d.png](https://img.gejiba.com/images/6717ac3791eb6adb2c803bf036dec58d.png)\n\n   \n\n如果对象与对象在属性填充的时候互相依赖，称之为循环依赖。那么 Spring 是怎么判断对象之间是循环依赖的呢？\n\n这里举个例子，\n\n```Java\n@Service\npublic class AService {\n\n    @Autowired\n    private BService bService;\n\n    public void fun() {\n    }\n}\n\n@Service\npublic class BService {\n\n    @Autowired\n    private AService aService;\n\n    public void fun() {\n    }\n}\n```\n\nAService 在实例化的时候会用一个 Set 集合标识该 Bean 是在创建中，Set 的 key 就是 Bean Name。当进行 BService 属性填充的时候，如果 BService 的属性（AService）存在这个 Set 集合中，说明它们之间存在依赖关系。\n\n\n\n2. 有哪些循环依赖？\n\n   - 普通的循环依赖，参考上面代码\n\n   - 多例的循环依赖\n\n     ```java\n     @Service\n     @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\n     public class AService {\n     \n         @Autowired\n         private BService bService;\n     \n         public void fun() {\n         }\n     }\n     \n     @Service\n     @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\n     public class BService {\n     \n         @Autowired\n         private AService aService;\n     \n         public void fun() {\n         }\n     }\n     ```\n\n     \n\n   - 构造的循环依赖\n\n     ```\n     @Service\n     public class AService {\n     \n         @Autowired\n         private AService(BService bSerivce){...}\n     \n         public void fun() {\n         }\n     }\n     \n     @Service\n     \n     public class BService {\n     \n         @Autowired\n         private BService(AService aSerivce){...}\n     \n         public void fun() {\n         }\n     }\n     ```\n\n   - 代理对象的循环依赖， @Async 注解 @Transactional 注解会产生代理对象，还有一些自己写的 AOP，对原始对象进行了增强。\n\n     ```java\n     @Service\n     public class AService {\n     \n         @Autowired\n         private BService bService;\n     \n         public void fun() {\n         }\n     }\n     \n     @Service\n     public class BService {\n     \n         @Autowired\n         private AService aService;\n     \n     \t@Async\n         public void fun() {\n         }\n     }\n     ```\n\n   - 指定加载顺序的循环依赖，AService 加上 @DependsOn 注解，指定 BSerivce 先加载，而 BService 又指定 AService 先加载。\n   \n     ```java\n     @Service\n     @DependsOn(value = \"BService\")\n     public class AService {\n     \n         @Autowired\n         private BService bService;\n     \n         public void fun() {\n         }\n     }\n     \n     @Service\n     @DependsOn(value = \"AService\")\n     public class BService {\n     \n         @Autowired\n         private AService aService;\n     \n         public void fun() {\n         }\n     }\n     ```\n\n3. 哪些可以解决？哪些不可以解决？\n\n   普通循环依赖、代理循环依赖及多例循环依赖、指定加载顺序的依赖可以解决。而构造循环依赖无法解决，因为两个对象都是有参构造，构造前都必须先实例化，存在构造依赖都无法先提前实例化（除非其中一个有无参构造）。\n\n4. 怎么解决？\n\n   - 普通对象依赖和代理对象依赖 ，Spring 框架使用三级缓存解决。\n\n   ![7ae02888247955b4e552a7761fd246b4.png](https://img.gejiba.com/images/7ae02888247955b4e552a7761fd246b4.png)\n\n   AService \n\n   1. 实例化对象：当获取 AService Bean 的时候先去一级缓存中查找，没有则实例化该对象，然后将获取 Bean 对象的 Lambda 方法存储到三级缓存中（代理对象依赖情况，属性填充的时候根据原始对象获取代理对象，提前进行 AOP），使用 Lambda 表达式是延迟处理，后期需要使用的时候才去处理。\n\n   2. 填充属性：填充 BService 属性。\n\n      BService\n\n      2.1 先去一级缓存中查找，没有则实例化该对象，同 AService 第一步。\n\n      2.2 填充属性：填充 AService 属性，先去二级缓存中查找，没有则从三级缓存创建对象，再把创建的对象放入二级缓存，删除三级缓存（Lambda 只需要执行一次，保持单例）。\n\n      2.3 其它属性填充\n\n      2.4 初始化操作\n\n      2.5 放入一级缓存\n\n      2.6 把 BService 从 Set 集合（标识正常创建中的 ）中移除。\n\n   3. 其它属性填充\n   4. 初始化操作\n   5. 放入一级缓存\n   6. 把 AService 从 Set 集合（标识正常创建中的 ）中移除。\n\n   \n\n   二级缓存是为了解决循环依赖的问题，也是为了满足对象单例。而三级缓存是为了解决代理循环依赖问题，虽然可以在对象实例化后进行代理，但是破坏了 Spring 的设计原则，将 AOP 设计在初始化阶段进行。而代理依赖需要在属性填充的时候进行 AOP，所以在实例化后创建了三级缓存，方便提前创建代理对象。\n\n   \n\n   虽然二级缓存是半成品，例如 BService 填充完 AService 的时候，AService 还没有执行其它属性填充等操作。但是当 AService 执行  3 和 4 步的时候，BService 里面的 AService 已经是成品了（对象引用）。\n\n   \n\n   当然有些代理循环依赖需要代码层修改，例如 @Async 注释的代理类需要在类上加上 @Lazy 注解解决，否则报错。\n\n   \n\n   - 多例循环依赖的修改单例可以解决，@DependsOn 注解的打破它不循环依赖可以解决。\n\n   \n","slug":"Spring循环依赖","published":1,"updated":"2022-05-15T08:07:09.613Z","_id":"cl3707oia0001fslngtf27czs","comments":1,"layout":"post","photos":[],"link":"","content":"<ol>\n<li>什么是循环依赖，怎么判断是循环依赖？</li>\n<li>有哪些循环依赖？</li>\n<li>哪些可以解决，哪些不可以解决？</li>\n<li>怎么解决？</li>\n</ol>\n<p>带着这几个问题，先想一想。</p>\n<p>以下是个人理解的答案。</p>\n<ol>\n<li><p>什么是循环依赖？</p>\n<p>回答这个问题之前，先简单介绍下 Bean 的生命周期。</p>\n<p><img src=\"https://img.gejiba.com/images/6717ac3791eb6adb2c803bf036dec58d.png\" alt=\"6717ac3791eb6adb2c803bf036dec58d.png\"></p>\n</li>\n</ol>\n<p>如果对象与对象在属性填充的时候互相依赖，称之为循环依赖。那么 Spring 是怎么判断对象之间是循环依赖的呢？</p>\n<p>这里举个例子，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> BService bService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fun</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AService aService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fun</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>AService 在实例化的时候会用一个 Set 集合标识该 Bean 是在创建中，Set 的 key 就是 Bean Name。当进行 BService 属性填充的时候，如果 BService 的属性（AService）存在这个 Set 集合中，说明它们之间存在依赖关系。</p>\n<ol start=\"2\">\n<li><p>有哪些循环依赖？</p>\n<ul>\n<li><p>普通的循环依赖，参考上面代码</p>\n</li>\n<li><p>多例的循环依赖</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> BService bService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fun</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AService aService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fun</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>构造的循环依赖</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Service</span><br><span class=\"line\">public class AService &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private AService(BService bSerivce)&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void fun() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Service</span><br><span class=\"line\"></span><br><span class=\"line\">public class BService &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private BService(AService aSerivce)&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void fun() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>代理对象的循环依赖， @Async 注解 @Transactional 注解会产生代理对象，还有一些自己写的 AOP，对原始对象进行了增强。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> BService bService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fun</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AService aService;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Async</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fun</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>指定加载顺序的循环依赖，AService 加上 @DependsOn 注解，指定 BSerivce 先加载，而 BService 又指定 AService 先加载。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@DependsOn(value = &quot;BService&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> BService bService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fun</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@DependsOn(value = &quot;AService&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AService aService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fun</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>哪些可以解决？哪些不可以解决？</p>\n<p>普通循环依赖、代理循环依赖及多例循环依赖、指定加载顺序的依赖可以解决。而构造循环依赖无法解决，因为两个对象都是有参构造，构造前都必须先实例化，存在构造依赖都无法先提前实例化（除非其中一个有无参构造）。</p>\n</li>\n<li><p>怎么解决？</p>\n<ul>\n<li>普通对象依赖和代理对象依赖 ，Spring 框架使用三级缓存解决。</li>\n</ul>\n<p><img src=\"https://img.gejiba.com/images/7ae02888247955b4e552a7761fd246b4.png\" alt=\"7ae02888247955b4e552a7761fd246b4.png\"></p>\n<p>AService </p>\n<ol>\n<li><p>实例化对象：当获取 AService Bean 的时候先去一级缓存中查找，没有则实例化该对象，然后将获取 Bean 对象的 Lambda 方法存储到三级缓存中（代理对象依赖情况，属性填充的时候根据原始对象获取代理对象，提前进行 AOP），使用 Lambda 表达式是延迟处理，后期需要使用的时候才去处理。</p>\n</li>\n<li><p>填充属性：填充 BService 属性。</p>\n<p>BService</p>\n<p>2.1 先去一级缓存中查找，没有则实例化该对象，同 AService 第一步。</p>\n<p>2.2 填充属性：填充 AService 属性，先去二级缓存中查找，没有则从三级缓存创建对象，再把创建的对象放入二级缓存，删除三级缓存（Lambda 只需要执行一次，保持单例）。</p>\n<p>2.3 其它属性填充</p>\n<p>2.4 初始化操作</p>\n<p>2.5 放入一级缓存</p>\n<p>2.6 把 BService 从 Set 集合（标识正常创建中的 ）中移除。</p>\n</li>\n<li><p>其它属性填充</p>\n</li>\n<li><p>初始化操作</p>\n</li>\n<li><p>放入一级缓存</p>\n</li>\n<li><p>把 AService 从 Set 集合（标识正常创建中的 ）中移除。</p>\n</li>\n</ol>\n<p>二级缓存是为了解决循环依赖的问题，也是为了满足对象单例。而三级缓存是为了解决代理循环依赖问题，虽然可以在对象实例化后进行代理，但是破坏了 Spring 的设计原则，将 AOP 设计在初始化阶段进行。而代理依赖需要在属性填充的时候进行 AOP，所以在实例化后创建了三级缓存，方便提前创建代理对象。</p>\n<p>虽然二级缓存是半成品，例如 BService 填充完 AService 的时候，AService 还没有执行其它属性填充等操作。但是当 AService 执行  3 和 4 步的时候，BService 里面的 AService 已经是成品了（对象引用）。</p>\n<p>当然有些代理循环依赖需要代码层修改，例如 @Async 注释的代理类需要在类上加上 @Lazy 注解解决，否则报错。</p>\n<ul>\n<li>多例循环依赖的修改单例可以解决，@DependsOn 注解的打破它不循环依赖可以解决。</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>什么是循环依赖，怎么判断是循环依赖？</li>\n<li>有哪些循环依赖？</li>\n<li>哪些可以解决，哪些不可以解决？</li>\n<li>怎么解决？</li>\n</ol>\n<p>带着这几个问题，先想一想。</p>\n<p>以下是个人理解的答案。</p>\n<ol>\n<li><p>什么是循环依赖？</p>\n<p>回答这个问题之前，先简单介绍下 Bean 的生命周期。</p>\n<p><img src=\"https://img.gejiba.com/images/6717ac3791eb6adb2c803bf036dec58d.png\" alt=\"6717ac3791eb6adb2c803bf036dec58d.png\"></p>\n</li>\n</ol>\n<p>如果对象与对象在属性填充的时候互相依赖，称之为循环依赖。那么 Spring 是怎么判断对象之间是循环依赖的呢？</p>\n<p>这里举个例子，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> BService bService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fun</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AService aService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fun</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>AService 在实例化的时候会用一个 Set 集合标识该 Bean 是在创建中，Set 的 key 就是 Bean Name。当进行 BService 属性填充的时候，如果 BService 的属性（AService）存在这个 Set 集合中，说明它们之间存在依赖关系。</p>\n<ol start=\"2\">\n<li><p>有哪些循环依赖？</p>\n<ul>\n<li><p>普通的循环依赖，参考上面代码</p>\n</li>\n<li><p>多例的循环依赖</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> BService bService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fun</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AService aService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fun</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>构造的循环依赖</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Service</span><br><span class=\"line\">public class AService &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private AService(BService bSerivce)&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void fun() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Service</span><br><span class=\"line\"></span><br><span class=\"line\">public class BService &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private BService(AService aSerivce)&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void fun() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>代理对象的循环依赖， @Async 注解 @Transactional 注解会产生代理对象，还有一些自己写的 AOP，对原始对象进行了增强。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> BService bService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fun</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AService aService;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Async</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fun</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>指定加载顺序的循环依赖，AService 加上 @DependsOn 注解，指定 BSerivce 先加载，而 BService 又指定 AService 先加载。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@DependsOn(value = &quot;BService&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> BService bService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fun</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@DependsOn(value = &quot;AService&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AService aService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fun</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>哪些可以解决？哪些不可以解决？</p>\n<p>普通循环依赖、代理循环依赖及多例循环依赖、指定加载顺序的依赖可以解决。而构造循环依赖无法解决，因为两个对象都是有参构造，构造前都必须先实例化，存在构造依赖都无法先提前实例化（除非其中一个有无参构造）。</p>\n</li>\n<li><p>怎么解决？</p>\n<ul>\n<li>普通对象依赖和代理对象依赖 ，Spring 框架使用三级缓存解决。</li>\n</ul>\n<p><img src=\"https://img.gejiba.com/images/7ae02888247955b4e552a7761fd246b4.png\" alt=\"7ae02888247955b4e552a7761fd246b4.png\"></p>\n<p>AService </p>\n<ol>\n<li><p>实例化对象：当获取 AService Bean 的时候先去一级缓存中查找，没有则实例化该对象，然后将获取 Bean 对象的 Lambda 方法存储到三级缓存中（代理对象依赖情况，属性填充的时候根据原始对象获取代理对象，提前进行 AOP），使用 Lambda 表达式是延迟处理，后期需要使用的时候才去处理。</p>\n</li>\n<li><p>填充属性：填充 BService 属性。</p>\n<p>BService</p>\n<p>2.1 先去一级缓存中查找，没有则实例化该对象，同 AService 第一步。</p>\n<p>2.2 填充属性：填充 AService 属性，先去二级缓存中查找，没有则从三级缓存创建对象，再把创建的对象放入二级缓存，删除三级缓存（Lambda 只需要执行一次，保持单例）。</p>\n<p>2.3 其它属性填充</p>\n<p>2.4 初始化操作</p>\n<p>2.5 放入一级缓存</p>\n<p>2.6 把 BService 从 Set 集合（标识正常创建中的 ）中移除。</p>\n</li>\n<li><p>其它属性填充</p>\n</li>\n<li><p>初始化操作</p>\n</li>\n<li><p>放入一级缓存</p>\n</li>\n<li><p>把 AService 从 Set 集合（标识正常创建中的 ）中移除。</p>\n</li>\n</ol>\n<p>二级缓存是为了解决循环依赖的问题，也是为了满足对象单例。而三级缓存是为了解决代理循环依赖问题，虽然可以在对象实例化后进行代理，但是破坏了 Spring 的设计原则，将 AOP 设计在初始化阶段进行。而代理依赖需要在属性填充的时候进行 AOP，所以在实例化后创建了三级缓存，方便提前创建代理对象。</p>\n<p>虽然二级缓存是半成品，例如 BService 填充完 AService 的时候，AService 还没有执行其它属性填充等操作。但是当 AService 执行  3 和 4 步的时候，BService 里面的 AService 已经是成品了（对象引用）。</p>\n<p>当然有些代理循环依赖需要代码层修改，例如 @Async 注释的代理类需要在类上加上 @Lazy 注解解决，否则报错。</p>\n<ul>\n<li>多例循环依赖的修改单例可以解决，@DependsOn 注解的打破它不循环依赖可以解决。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"DDD","date":"2022-05-18T01:34:08.000Z","_content":"\n以下是个人对 DDD 设计理论的理解，及工作中怎么实践。\n\n\n\nWhat? （什么是 DDD）\n\nDDD 领域驱动设计（Domain-Driven Design），是埃里克·埃文斯于 2004 年提出的一种软件设计方法和理念。主要思想是利用业务模型来指导业务与应用的设计和实现。\n\n\n\nWhy？（为什么要这么做）\n\n我之前参与的工作项目都是基于业务建模，数据层提供基于模型的原子操作，有些 SQL 厉害的开发可能会将某些业务嵌入其中，但这样不易维护和识别。建模之后进行分层架构，业务层基于模型开发去组织业务，有些可能会直接操作数据层，有些可能需要调用其它业务代码进行编排去实现一个完整的业务场景，可能这个完整的业务场景又会被其它业务场景调用，但是只是需要其中某些代码逻辑，可能直接加 if else，更优雅的可能会利用设计模式。总之这种分层不是很友好，因为程序员需要将模型和业务进行衔接。\n\n\n\nHow？（怎么做）\n\n针对复杂的业务场景，如何让开发更专注自己的业务模块，核心领域。我们先将数据层这块抽出来，因为数据层仅仅是数据，没有任何行为，也称之贫血模式。数据层有专门的团队进行维护，利用面向过程的方式，将数据耦合行为（充血模式），提供对应业务领域的接口，这些接口实现类不仅是数据的载体，还有很多颗粒度非常小的行为。（BO 层），这一层屏蔽了数据的CRUD操作，对外只是一个个行为。中间有一层将这些行为组装成一个个功能（Method 层）。而业务层就是调用这些功能来实现对应业务领域（Service 层）。\n\n\n\n这样做导致更偏向设计，怎么设计好行为，功能，因为这些是支撑业务的关键点，如果这些实现非常好，那么业务层可以更灵活的编排，开发就能更关注自己的业务。\n\n\n\n以上是我对 DDD 的理解及实践。\n\n","source":"_posts/DDD.md","raw":"---\ntitle: DDD\ndate: 2022-05-18 09:34:08\ntags: Design\n---\n\n以下是个人对 DDD 设计理论的理解，及工作中怎么实践。\n\n\n\nWhat? （什么是 DDD）\n\nDDD 领域驱动设计（Domain-Driven Design），是埃里克·埃文斯于 2004 年提出的一种软件设计方法和理念。主要思想是利用业务模型来指导业务与应用的设计和实现。\n\n\n\nWhy？（为什么要这么做）\n\n我之前参与的工作项目都是基于业务建模，数据层提供基于模型的原子操作，有些 SQL 厉害的开发可能会将某些业务嵌入其中，但这样不易维护和识别。建模之后进行分层架构，业务层基于模型开发去组织业务，有些可能会直接操作数据层，有些可能需要调用其它业务代码进行编排去实现一个完整的业务场景，可能这个完整的业务场景又会被其它业务场景调用，但是只是需要其中某些代码逻辑，可能直接加 if else，更优雅的可能会利用设计模式。总之这种分层不是很友好，因为程序员需要将模型和业务进行衔接。\n\n\n\nHow？（怎么做）\n\n针对复杂的业务场景，如何让开发更专注自己的业务模块，核心领域。我们先将数据层这块抽出来，因为数据层仅仅是数据，没有任何行为，也称之贫血模式。数据层有专门的团队进行维护，利用面向过程的方式，将数据耦合行为（充血模式），提供对应业务领域的接口，这些接口实现类不仅是数据的载体，还有很多颗粒度非常小的行为。（BO 层），这一层屏蔽了数据的CRUD操作，对外只是一个个行为。中间有一层将这些行为组装成一个个功能（Method 层）。而业务层就是调用这些功能来实现对应业务领域（Service 层）。\n\n\n\n这样做导致更偏向设计，怎么设计好行为，功能，因为这些是支撑业务的关键点，如果这些实现非常好，那么业务层可以更灵活的编排，开发就能更关注自己的业务。\n\n\n\n以上是我对 DDD 的理解及实践。\n\n","slug":"DDD","published":1,"updated":"2022-05-18T05:50:23.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3kt6val0000v4lnas1404tf","content":"<p>以下是个人对 DDD 设计理论的理解，及工作中怎么实践。</p>\n<p>What? （什么是 DDD）</p>\n<p>DDD 领域驱动设计（Domain-Driven Design），是埃里克·埃文斯于 2004 年提出的一种软件设计方法和理念。主要思想是利用业务模型来指导业务与应用的设计和实现。</p>\n<p>Why？（为什么要这么做）</p>\n<p>我之前参与的工作项目都是基于业务建模，数据层提供基于模型的原子操作，有些 SQL 厉害的开发可能会将某些业务嵌入其中，但这样不易维护和识别。建模之后进行分层架构，业务层基于模型开发去组织业务，有些可能会直接操作数据层，有些可能需要调用其它业务代码进行编排去实现一个完整的业务场景，可能这个完整的业务场景又会被其它业务场景调用，但是只是需要其中某些代码逻辑，可能直接加 if else，更优雅的可能会利用设计模式。总之这种分层不是很友好，因为程序员需要将模型和业务进行衔接。</p>\n<p>How？（怎么做）</p>\n<p>针对复杂的业务场景，如何让开发更专注自己的业务模块，核心领域。我们先将数据层这块抽出来，因为数据层仅仅是数据，没有任何行为，也称之贫血模式。数据层有专门的团队进行维护，利用面向过程的方式，将数据耦合行为（充血模式），提供对应业务领域的接口，这些接口实现类不仅是数据的载体，还有很多颗粒度非常小的行为。（BO 层），这一层屏蔽了数据的CRUD操作，对外只是一个个行为。中间有一层将这些行为组装成一个个功能（Method 层）。而业务层就是调用这些功能来实现对应业务领域（Service 层）。</p>\n<p>这样做导致更偏向设计，怎么设计好行为，功能，因为这些是支撑业务的关键点，如果这些实现非常好，那么业务层可以更灵活的编排，开发就能更关注自己的业务。</p>\n<p>以上是我对 DDD 的理解及实践。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>以下是个人对 DDD 设计理论的理解，及工作中怎么实践。</p>\n<p>What? （什么是 DDD）</p>\n<p>DDD 领域驱动设计（Domain-Driven Design），是埃里克·埃文斯于 2004 年提出的一种软件设计方法和理念。主要思想是利用业务模型来指导业务与应用的设计和实现。</p>\n<p>Why？（为什么要这么做）</p>\n<p>我之前参与的工作项目都是基于业务建模，数据层提供基于模型的原子操作，有些 SQL 厉害的开发可能会将某些业务嵌入其中，但这样不易维护和识别。建模之后进行分层架构，业务层基于模型开发去组织业务，有些可能会直接操作数据层，有些可能需要调用其它业务代码进行编排去实现一个完整的业务场景，可能这个完整的业务场景又会被其它业务场景调用，但是只是需要其中某些代码逻辑，可能直接加 if else，更优雅的可能会利用设计模式。总之这种分层不是很友好，因为程序员需要将模型和业务进行衔接。</p>\n<p>How？（怎么做）</p>\n<p>针对复杂的业务场景，如何让开发更专注自己的业务模块，核心领域。我们先将数据层这块抽出来，因为数据层仅仅是数据，没有任何行为，也称之贫血模式。数据层有专门的团队进行维护，利用面向过程的方式，将数据耦合行为（充血模式），提供对应业务领域的接口，这些接口实现类不仅是数据的载体，还有很多颗粒度非常小的行为。（BO 层），这一层屏蔽了数据的CRUD操作，对外只是一个个行为。中间有一层将这些行为组装成一个个功能（Method 层）。而业务层就是调用这些功能来实现对应业务领域（Service 层）。</p>\n<p>这样做导致更偏向设计，怎么设计好行为，功能，因为这些是支撑业务的关键点，如果这些实现非常好，那么业务层可以更灵活的编排，开发就能更关注自己的业务。</p>\n<p>以上是我对 DDD 的理解及实践。</p>\n"},{"title":"HexoEditor","date":"2022-07-19T10:27:55.000Z","_content":"\n### 配置 HexoEditor\n\n1. gitHub 地址：https://github.com/zhuzhuyule/HexoEditor\n2. 安装 git nodejs npm\n3. 下载 HexoEditor\n    ```\n    git clone https://github.com/zhuzhuyule/HexoEditor.git\n    ```\n    \n4. electron\n  \n  electron 是由 Github 开发，是一个用 Html、css、JavaScript 来构建桌面应用程序的开源库，可以打包为 Mac、Windows、Linux 系统下的应用。electron 是一个运行时环境，包含 Node 和 Chromium，可以理解成把 web 应用运行在 node 环境中，先登录 http://electronjs.org/releases/stable 查看版本号\n  \n  ```\n  npm install -g electron@19.0.0\n  ```\n \n\n\n\n","source":"_posts/HexoEditor.md","raw":"---\ntitle: HexoEditor\ndate: 2022-07-19 18:27:55\ntags: Hexo\n---\n\n### 配置 HexoEditor\n\n1. gitHub 地址：https://github.com/zhuzhuyule/HexoEditor\n2. 安装 git nodejs npm\n3. 下载 HexoEditor\n    ```\n    git clone https://github.com/zhuzhuyule/HexoEditor.git\n    ```\n    \n4. electron\n  \n  electron 是由 Github 开发，是一个用 Html、css、JavaScript 来构建桌面应用程序的开源库，可以打包为 Mac、Windows、Linux 系统下的应用。electron 是一个运行时环境，包含 Node 和 Chromium，可以理解成把 web 应用运行在 node 环境中，先登录 http://electronjs.org/releases/stable 查看版本号\n  \n  ```\n  npm install -g electron@19.0.0\n  ```\n \n\n\n\n","slug":"HexoEditor","published":1,"updated":"2022-07-19T10:53:44.772Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5s266j70000lcln7q3scn95","content":"<h3 id=\"配置-HexoEditor\"><a href=\"#配置-HexoEditor\" class=\"headerlink\" title=\"配置 HexoEditor\"></a>配置 HexoEditor</h3><ol>\n<li>gitHub 地址：<a href=\"https://github.com/zhuzhuyule/HexoEditor\">https://github.com/zhuzhuyule/HexoEditor</a></li>\n<li>安装 git nodejs npm</li>\n<li>下载 HexoEditor <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/zhuzhuyule/HexoEditor.git</span><br></pre></td></tr></table></figure>\n</li>\n<li>electron</li>\n</ol>\n<p>  electron 是由 Github 开发，是一个用 Html、css、JavaScript 来构建桌面应用程序的开源库，可以打包为 Mac、Windows、Linux 系统下的应用。electron 是一个运行时环境，包含 Node 和 Chromium，可以理解成把 web 应用运行在 node 环境中，先登录 <a href=\"http://electronjs.org/releases/stable\">http://electronjs.org/releases/stable</a> 查看版本号</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g electron@19.0.0</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"配置-HexoEditor\"><a href=\"#配置-HexoEditor\" class=\"headerlink\" title=\"配置 HexoEditor\"></a>配置 HexoEditor</h3><ol>\n<li>gitHub 地址：<a href=\"https://github.com/zhuzhuyule/HexoEditor\">https://github.com/zhuzhuyule/HexoEditor</a></li>\n<li>安装 git nodejs npm</li>\n<li>下载 HexoEditor <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/zhuzhuyule/HexoEditor.git</span><br></pre></td></tr></table></figure>\n</li>\n<li>electron</li>\n</ol>\n<p>  electron 是由 Github 开发，是一个用 Html、css、JavaScript 来构建桌面应用程序的开源库，可以打包为 Mac、Windows、Linux 系统下的应用。electron 是一个运行时环境，包含 Node 和 Chromium，可以理解成把 web 应用运行在 node 环境中，先登录 <a href=\"http://electronjs.org/releases/stable\">http://electronjs.org/releases/stable</a> 查看版本号</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g electron@19.0.0</span><br></pre></td></tr></table></figure>\n"},{"title":"申请售后和取消申请的逻辑","date":"2022-07-20T01:39:35.000Z","_content":"\n\n\n### 申请售后\n\n#### 待发货状态\n\n- 同步（主逻辑）：\n\n    1. 退款\n    2. 创建售后记录\n    3. 获取商品，更新状态\n    4. 更新拆分表\n\n- 异步(拆单)：\n\n    1. 如果是一个，直接更新订单主状态\n\n    2. 如果是多个，复制一个售后的订单，记录订单主键和复制订单主键关系\n\n    3. 复制拆分的商品，挂载副订单\n\n    4. 维护副商品和商品的关系（Id:复制的，Parent Id :真的的商品主键）\n\n    5. 当全部拆单，删除副订单挂载的商品，主订单状态变更，删除副订单，删除订单主键和复制订单主键关系\n    6.  删除副商品和商品的关系。\n\n- 异步(订单历史)：\n\n    1. 当全部跑到售后的时候，如果是待发货触发，则更新待发货 -> 售后；如果是待收货触发，则更新待收货- >售后\n\n       注意，这里的异步必须先执行，拿到当前订单的状态，不然执行异步拆单，状态会变。\n\n- 异步（订单商品历史）\n\n \t1. 记录当前商品售后记录，状态待处理\n\n#### 待收货状态\n\n同上逻辑，售后增加换货，退货退款，退款逻辑\n\n\n### 取消申请\n- 同步（主逻辑）：\n\n    1. 取消的商品状态回退，回退订单主状态\n    2. 更新售后表，商品状态取消售后\n    3. 拆分表更新\n    4. 传参加入是取消申请的操作标识\n    5. 不管是单个还是多个，只要主订单状态已经是售后，查询订单历史状态，主订单状态回退取消前状态（异步订单历史：这里记录历史变更）\n\n- 异步（合单）：\n\n \t1. 复制主订单，更新复制订单的状态为售后\n \t2. 更新拆分表的主订单和副订单主键关系\n \t3. 拿到当前未取消的售后商品主键，查询这些商品\n \t4. 复制这些商品，挂载副订单\n \t5. 售后商品的主键在拆分表数量为0，则说明全部取消申请了，删除副订单的商品，删除副商品和商品关系表，删除副订单，更新拆分表的订单主键和副订单主键的关系。\n\n\n- 异步(订单历史)：\n\n    1. 当售后的商品全部取消，订单主状态记录历史，先执行异步合单逻辑，回退之前状态，记录开始状态：售后状态 -> 回退的状态\n\n    2. 这里有问题，可能主状态是待发货，其中一个在售后，这个时候取消，历史不变。（改成同步的主逻辑）\n\n\n- 异步（订单商品历史）\n\n \t1. 记录当前商品售后记录，状态待处理\n\n\n\n### 表结构设计\n\n```sql\n-- chh_mmplanet_order.chh_order_combination_split definition\n\nCREATE TABLE `chh_order_combination_split` (\n  `id` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '主键',\n  `order_id` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '订单主键',\n  `order_split_sale_id` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '拆分订单主键',\n  `order_code` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '订单编码',\n  `combination_count` int DEFAULT NULL COMMENT '组合数量',\n  `wait_send_id` varchar(3000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '待发货的商品主键',\n  `wait_send_count` int DEFAULT '0' COMMENT '待发货的数量',\n  `wait_receive_id` varchar(3000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '待收货的商品主键',\n  `wait_receive_count` int DEFAULT '0' COMMENT '待收货的商品数量',\n  `after_sale_id` varchar(3000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '售后的商品主键',\n  `after_sale_count` int DEFAULT '0' COMMENT '售后的商品数量',\n  `cancel_id` varchar(3000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '取消的商品主键',\n  `cancel_count` int DEFAULT '0' COMMENT '取消的商品数量',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='订单状态组合拆分明细表';\n```","source":"_posts/申请售后和取消申请的逻辑.md","raw":"---\ntitle: 申请售后和取消申请的逻辑\ndate: 2022-07-20 09:39:35\ntags: Design\n---\n\n\n\n### 申请售后\n\n#### 待发货状态\n\n- 同步（主逻辑）：\n\n    1. 退款\n    2. 创建售后记录\n    3. 获取商品，更新状态\n    4. 更新拆分表\n\n- 异步(拆单)：\n\n    1. 如果是一个，直接更新订单主状态\n\n    2. 如果是多个，复制一个售后的订单，记录订单主键和复制订单主键关系\n\n    3. 复制拆分的商品，挂载副订单\n\n    4. 维护副商品和商品的关系（Id:复制的，Parent Id :真的的商品主键）\n\n    5. 当全部拆单，删除副订单挂载的商品，主订单状态变更，删除副订单，删除订单主键和复制订单主键关系\n    6.  删除副商品和商品的关系。\n\n- 异步(订单历史)：\n\n    1. 当全部跑到售后的时候，如果是待发货触发，则更新待发货 -> 售后；如果是待收货触发，则更新待收货- >售后\n\n       注意，这里的异步必须先执行，拿到当前订单的状态，不然执行异步拆单，状态会变。\n\n- 异步（订单商品历史）\n\n \t1. 记录当前商品售后记录，状态待处理\n\n#### 待收货状态\n\n同上逻辑，售后增加换货，退货退款，退款逻辑\n\n\n### 取消申请\n- 同步（主逻辑）：\n\n    1. 取消的商品状态回退，回退订单主状态\n    2. 更新售后表，商品状态取消售后\n    3. 拆分表更新\n    4. 传参加入是取消申请的操作标识\n    5. 不管是单个还是多个，只要主订单状态已经是售后，查询订单历史状态，主订单状态回退取消前状态（异步订单历史：这里记录历史变更）\n\n- 异步（合单）：\n\n \t1. 复制主订单，更新复制订单的状态为售后\n \t2. 更新拆分表的主订单和副订单主键关系\n \t3. 拿到当前未取消的售后商品主键，查询这些商品\n \t4. 复制这些商品，挂载副订单\n \t5. 售后商品的主键在拆分表数量为0，则说明全部取消申请了，删除副订单的商品，删除副商品和商品关系表，删除副订单，更新拆分表的订单主键和副订单主键的关系。\n\n\n- 异步(订单历史)：\n\n    1. 当售后的商品全部取消，订单主状态记录历史，先执行异步合单逻辑，回退之前状态，记录开始状态：售后状态 -> 回退的状态\n\n    2. 这里有问题，可能主状态是待发货，其中一个在售后，这个时候取消，历史不变。（改成同步的主逻辑）\n\n\n- 异步（订单商品历史）\n\n \t1. 记录当前商品售后记录，状态待处理\n\n\n\n### 表结构设计\n\n```sql\n-- chh_mmplanet_order.chh_order_combination_split definition\n\nCREATE TABLE `chh_order_combination_split` (\n  `id` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '主键',\n  `order_id` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '订单主键',\n  `order_split_sale_id` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '拆分订单主键',\n  `order_code` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '订单编码',\n  `combination_count` int DEFAULT NULL COMMENT '组合数量',\n  `wait_send_id` varchar(3000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '待发货的商品主键',\n  `wait_send_count` int DEFAULT '0' COMMENT '待发货的数量',\n  `wait_receive_id` varchar(3000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '待收货的商品主键',\n  `wait_receive_count` int DEFAULT '0' COMMENT '待收货的商品数量',\n  `after_sale_id` varchar(3000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '售后的商品主键',\n  `after_sale_count` int DEFAULT '0' COMMENT '售后的商品数量',\n  `cancel_id` varchar(3000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '取消的商品主键',\n  `cancel_count` int DEFAULT '0' COMMENT '取消的商品数量',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='订单状态组合拆分明细表';\n```","slug":"申请售后和取消申请的逻辑","published":1,"updated":"2022-07-20T01:44:16.877Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sygbtt0000x0ln4236hi5o","content":"<h3 id=\"申请售后\"><a href=\"#申请售后\" class=\"headerlink\" title=\"申请售后\"></a>申请售后</h3><h4 id=\"待发货状态\"><a href=\"#待发货状态\" class=\"headerlink\" title=\"待发货状态\"></a>待发货状态</h4><ul>\n<li><p>同步（主逻辑）：</p>\n<ol>\n<li>退款</li>\n<li>创建售后记录</li>\n<li>获取商品，更新状态</li>\n<li>更新拆分表</li>\n</ol>\n</li>\n<li><p>异步(拆单)：</p>\n<ol>\n<li><p>如果是一个，直接更新订单主状态</p>\n</li>\n<li><p>如果是多个，复制一个售后的订单，记录订单主键和复制订单主键关系</p>\n</li>\n<li><p>复制拆分的商品，挂载副订单</p>\n</li>\n<li><p>维护副商品和商品的关系（Id:复制的，Parent Id :真的的商品主键）</p>\n</li>\n<li><p>当全部拆单，删除副订单挂载的商品，主订单状态变更，删除副订单，删除订单主键和复制订单主键关系</p>\n</li>\n<li><p> 删除副商品和商品的关系。</p>\n</li>\n</ol>\n</li>\n<li><p>异步(订单历史)：</p>\n<ol>\n<li><p>当全部跑到售后的时候，如果是待发货触发，则更新待发货 -&gt; 售后；如果是待收货触发，则更新待收货- &gt;售后</p>\n<p>注意，这里的异步必须先执行，拿到当前订单的状态，不然执行异步拆单，状态会变。</p>\n</li>\n</ol>\n</li>\n<li><p>异步（订单商品历史）</p>\n<ol>\n<li>记录当前商品售后记录，状态待处理</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"待收货状态\"><a href=\"#待收货状态\" class=\"headerlink\" title=\"待收货状态\"></a>待收货状态</h4><p>同上逻辑，售后增加换货，退货退款，退款逻辑</p>\n<h3 id=\"取消申请\"><a href=\"#取消申请\" class=\"headerlink\" title=\"取消申请\"></a>取消申请</h3><ul>\n<li><p>同步（主逻辑）：</p>\n<ol>\n<li>取消的商品状态回退，回退订单主状态</li>\n<li>更新售后表，商品状态取消售后</li>\n<li>拆分表更新</li>\n<li>传参加入是取消申请的操作标识</li>\n<li>不管是单个还是多个，只要主订单状态已经是售后，查询订单历史状态，主订单状态回退取消前状态（异步订单历史：这里记录历史变更）</li>\n</ol>\n</li>\n<li><p>异步（合单）：</p>\n<ol>\n<li>复制主订单，更新复制订单的状态为售后</li>\n<li>更新拆分表的主订单和副订单主键关系</li>\n<li>拿到当前未取消的售后商品主键，查询这些商品</li>\n<li>复制这些商品，挂载副订单</li>\n<li>售后商品的主键在拆分表数量为0，则说明全部取消申请了，删除副订单的商品，删除副商品和商品关系表，删除副订单，更新拆分表的订单主键和副订单主键的关系。</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><p>异步(订单历史)：</p>\n<ol>\n<li><p>当售后的商品全部取消，订单主状态记录历史，先执行异步合单逻辑，回退之前状态，记录开始状态：售后状态 -&gt; 回退的状态</p>\n</li>\n<li><p>这里有问题，可能主状态是待发货，其中一个在售后，这个时候取消，历史不变。（改成同步的主逻辑）</p>\n</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><p>异步（订单商品历史）</p>\n<ol>\n<li>记录当前商品售后记录，状态待处理</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"表结构设计\"><a href=\"#表结构设计\" class=\"headerlink\" title=\"表结构设计\"></a>表结构设计</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- chh_mmplanet_order.chh_order_combination_split definition</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> `chh_order_combination_split` (</span><br><span class=\"line\">  `id` <span class=\"type\">varchar</span>(<span class=\"number\">32</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_general_ci <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;主键&#x27;</span>,</span><br><span class=\"line\">  `order_id` <span class=\"type\">varchar</span>(<span class=\"number\">32</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_general_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;订单主键&#x27;</span>,</span><br><span class=\"line\">  `order_split_sale_id` <span class=\"type\">varchar</span>(<span class=\"number\">32</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_general_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;拆分订单主键&#x27;</span>,</span><br><span class=\"line\">  `order_code` <span class=\"type\">varchar</span>(<span class=\"number\">32</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_general_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;订单编码&#x27;</span>,</span><br><span class=\"line\">  `combination_count` <span class=\"type\">int</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;组合数量&#x27;</span>,</span><br><span class=\"line\">  `wait_send_id` <span class=\"type\">varchar</span>(<span class=\"number\">3000</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_general_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;待发货的商品主键&#x27;</span>,</span><br><span class=\"line\">  `wait_send_count` <span class=\"type\">int</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;0&#x27;</span> COMMENT <span class=\"string\">&#x27;待发货的数量&#x27;</span>,</span><br><span class=\"line\">  `wait_receive_id` <span class=\"type\">varchar</span>(<span class=\"number\">3000</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_general_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;待收货的商品主键&#x27;</span>,</span><br><span class=\"line\">  `wait_receive_count` <span class=\"type\">int</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;0&#x27;</span> COMMENT <span class=\"string\">&#x27;待收货的商品数量&#x27;</span>,</span><br><span class=\"line\">  `after_sale_id` <span class=\"type\">varchar</span>(<span class=\"number\">3000</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_general_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;售后的商品主键&#x27;</span>,</span><br><span class=\"line\">  `after_sale_count` <span class=\"type\">int</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;0&#x27;</span> COMMENT <span class=\"string\">&#x27;售后的商品数量&#x27;</span>,</span><br><span class=\"line\">  `cancel_id` <span class=\"type\">varchar</span>(<span class=\"number\">3000</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_general_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;取消的商品主键&#x27;</span>,</span><br><span class=\"line\">  `cancel_count` <span class=\"type\">int</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;0&#x27;</span> COMMENT <span class=\"string\">&#x27;取消的商品数量&#x27;</span>,</span><br><span class=\"line\">  <span class=\"keyword\">PRIMARY</span> KEY (`id`)</span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB <span class=\"keyword\">DEFAULT</span> CHARSET<span class=\"operator\">=</span>utf8mb4 <span class=\"keyword\">COLLATE</span><span class=\"operator\">=</span>utf8mb4_general_ci COMMENT<span class=\"operator\">=</span><span class=\"string\">&#x27;订单状态组合拆分明细表&#x27;</span>;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"申请售后\"><a href=\"#申请售后\" class=\"headerlink\" title=\"申请售后\"></a>申请售后</h3><h4 id=\"待发货状态\"><a href=\"#待发货状态\" class=\"headerlink\" title=\"待发货状态\"></a>待发货状态</h4><ul>\n<li><p>同步（主逻辑）：</p>\n<ol>\n<li>退款</li>\n<li>创建售后记录</li>\n<li>获取商品，更新状态</li>\n<li>更新拆分表</li>\n</ol>\n</li>\n<li><p>异步(拆单)：</p>\n<ol>\n<li><p>如果是一个，直接更新订单主状态</p>\n</li>\n<li><p>如果是多个，复制一个售后的订单，记录订单主键和复制订单主键关系</p>\n</li>\n<li><p>复制拆分的商品，挂载副订单</p>\n</li>\n<li><p>维护副商品和商品的关系（Id:复制的，Parent Id :真的的商品主键）</p>\n</li>\n<li><p>当全部拆单，删除副订单挂载的商品，主订单状态变更，删除副订单，删除订单主键和复制订单主键关系</p>\n</li>\n<li><p> 删除副商品和商品的关系。</p>\n</li>\n</ol>\n</li>\n<li><p>异步(订单历史)：</p>\n<ol>\n<li><p>当全部跑到售后的时候，如果是待发货触发，则更新待发货 -&gt; 售后；如果是待收货触发，则更新待收货- &gt;售后</p>\n<p>注意，这里的异步必须先执行，拿到当前订单的状态，不然执行异步拆单，状态会变。</p>\n</li>\n</ol>\n</li>\n<li><p>异步（订单商品历史）</p>\n<ol>\n<li>记录当前商品售后记录，状态待处理</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"待收货状态\"><a href=\"#待收货状态\" class=\"headerlink\" title=\"待收货状态\"></a>待收货状态</h4><p>同上逻辑，售后增加换货，退货退款，退款逻辑</p>\n<h3 id=\"取消申请\"><a href=\"#取消申请\" class=\"headerlink\" title=\"取消申请\"></a>取消申请</h3><ul>\n<li><p>同步（主逻辑）：</p>\n<ol>\n<li>取消的商品状态回退，回退订单主状态</li>\n<li>更新售后表，商品状态取消售后</li>\n<li>拆分表更新</li>\n<li>传参加入是取消申请的操作标识</li>\n<li>不管是单个还是多个，只要主订单状态已经是售后，查询订单历史状态，主订单状态回退取消前状态（异步订单历史：这里记录历史变更）</li>\n</ol>\n</li>\n<li><p>异步（合单）：</p>\n<ol>\n<li>复制主订单，更新复制订单的状态为售后</li>\n<li>更新拆分表的主订单和副订单主键关系</li>\n<li>拿到当前未取消的售后商品主键，查询这些商品</li>\n<li>复制这些商品，挂载副订单</li>\n<li>售后商品的主键在拆分表数量为0，则说明全部取消申请了，删除副订单的商品，删除副商品和商品关系表，删除副订单，更新拆分表的订单主键和副订单主键的关系。</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><p>异步(订单历史)：</p>\n<ol>\n<li><p>当售后的商品全部取消，订单主状态记录历史，先执行异步合单逻辑，回退之前状态，记录开始状态：售后状态 -&gt; 回退的状态</p>\n</li>\n<li><p>这里有问题，可能主状态是待发货，其中一个在售后，这个时候取消，历史不变。（改成同步的主逻辑）</p>\n</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><p>异步（订单商品历史）</p>\n<ol>\n<li>记录当前商品售后记录，状态待处理</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"表结构设计\"><a href=\"#表结构设计\" class=\"headerlink\" title=\"表结构设计\"></a>表结构设计</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- chh_mmplanet_order.chh_order_combination_split definition</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> `chh_order_combination_split` (</span><br><span class=\"line\">  `id` <span class=\"type\">varchar</span>(<span class=\"number\">32</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_general_ci <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;主键&#x27;</span>,</span><br><span class=\"line\">  `order_id` <span class=\"type\">varchar</span>(<span class=\"number\">32</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_general_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;订单主键&#x27;</span>,</span><br><span class=\"line\">  `order_split_sale_id` <span class=\"type\">varchar</span>(<span class=\"number\">32</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_general_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;拆分订单主键&#x27;</span>,</span><br><span class=\"line\">  `order_code` <span class=\"type\">varchar</span>(<span class=\"number\">32</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_general_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;订单编码&#x27;</span>,</span><br><span class=\"line\">  `combination_count` <span class=\"type\">int</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;组合数量&#x27;</span>,</span><br><span class=\"line\">  `wait_send_id` <span class=\"type\">varchar</span>(<span class=\"number\">3000</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_general_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;待发货的商品主键&#x27;</span>,</span><br><span class=\"line\">  `wait_send_count` <span class=\"type\">int</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;0&#x27;</span> COMMENT <span class=\"string\">&#x27;待发货的数量&#x27;</span>,</span><br><span class=\"line\">  `wait_receive_id` <span class=\"type\">varchar</span>(<span class=\"number\">3000</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_general_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;待收货的商品主键&#x27;</span>,</span><br><span class=\"line\">  `wait_receive_count` <span class=\"type\">int</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;0&#x27;</span> COMMENT <span class=\"string\">&#x27;待收货的商品数量&#x27;</span>,</span><br><span class=\"line\">  `after_sale_id` <span class=\"type\">varchar</span>(<span class=\"number\">3000</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_general_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;售后的商品主键&#x27;</span>,</span><br><span class=\"line\">  `after_sale_count` <span class=\"type\">int</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;0&#x27;</span> COMMENT <span class=\"string\">&#x27;售后的商品数量&#x27;</span>,</span><br><span class=\"line\">  `cancel_id` <span class=\"type\">varchar</span>(<span class=\"number\">3000</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_general_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;取消的商品主键&#x27;</span>,</span><br><span class=\"line\">  `cancel_count` <span class=\"type\">int</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;0&#x27;</span> COMMENT <span class=\"string\">&#x27;取消的商品数量&#x27;</span>,</span><br><span class=\"line\">  <span class=\"keyword\">PRIMARY</span> KEY (`id`)</span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB <span class=\"keyword\">DEFAULT</span> CHARSET<span class=\"operator\">=</span>utf8mb4 <span class=\"keyword\">COLLATE</span><span class=\"operator\">=</span>utf8mb4_general_ci COMMENT<span class=\"operator\">=</span><span class=\"string\">&#x27;订单状态组合拆分明细表&#x27;</span>;</span><br></pre></td></tr></table></figure>"},{"title":"绵绵星球工作笔记","date":"2022-07-20T01:48:06.000Z","_content":"\n- 服务器地址：47.110.127.82 / 47.100.230.246\n- 密码：mmxq220424@#$  /  mmplanetnginx0701123!@#\n- 命令：ssh root@47.110.127.82\n- `cd /mnt/server/logs/`\n- `cd /mnt/data/server/logs/`\n- 日志\n    ```\n    grep -A 20 \"NoticeAspect\" /mnt/server/logs/mmplanet-app-order-service-1.0.0-SNAPSHOT.out\n    ```\n\n    ```\n    tail -f -n 100 mmplanet-app-order-service-1.0.0-SNAPSHOT.out\n    ```\n- 书签\n    1. [代码仓库] http://47.110.127.82:8801/users/sign_in\n    2. [测试服老头子] http://47.110.127.82:8803/\n    3. [正试服老头子] https://jenkins.mmplanet.cn/\n    4. [蓝湖] https://lanhuapp.com/web/#/\n    5. [绵绵星球测试 web] https://webtest.mmplanet.cn/#/mnt/app\n    6. [绵绵星球正试 web] https://web.mmplanet.cn/#/monitor/server/online","source":"_posts/绵绵星球工作笔记.md","raw":"---\ntitle: 绵绵星球工作笔记\ndate: 2022-07-20 09:48:06\ntags: Other\n---\n\n- 服务器地址：47.110.127.82 / 47.100.230.246\n- 密码：mmxq220424@#$  /  mmplanetnginx0701123!@#\n- 命令：ssh root@47.110.127.82\n- `cd /mnt/server/logs/`\n- `cd /mnt/data/server/logs/`\n- 日志\n    ```\n    grep -A 20 \"NoticeAspect\" /mnt/server/logs/mmplanet-app-order-service-1.0.0-SNAPSHOT.out\n    ```\n\n    ```\n    tail -f -n 100 mmplanet-app-order-service-1.0.0-SNAPSHOT.out\n    ```\n- 书签\n    1. [代码仓库] http://47.110.127.82:8801/users/sign_in\n    2. [测试服老头子] http://47.110.127.82:8803/\n    3. [正试服老头子] https://jenkins.mmplanet.cn/\n    4. [蓝湖] https://lanhuapp.com/web/#/\n    5. [绵绵星球测试 web] https://webtest.mmplanet.cn/#/mnt/app\n    6. [绵绵星球正试 web] https://web.mmplanet.cn/#/monitor/server/online","slug":"绵绵星球工作笔记","published":1,"updated":"2022-07-20T01:56:56.682Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sygbtz0001x0ln4ngfbyyg","content":"<ul>\n<li><p>服务器地址：47.110.127.82 / 47.100.230.246</p>\n</li>\n<li><p>密码：mmxq220424@#$  /  mmplanetnginx0701123!@#</p>\n</li>\n<li><p>命令：ssh <a href=\"mailto:&#114;&#111;&#x6f;&#116;&#64;&#52;&#x37;&#46;&#x31;&#49;&#x30;&#46;&#x31;&#50;&#x37;&#x2e;&#56;&#x32;\">&#114;&#111;&#x6f;&#116;&#64;&#52;&#x37;&#46;&#x31;&#49;&#x30;&#46;&#x31;&#50;&#x37;&#x2e;&#56;&#x32;</a></p>\n</li>\n<li><p><code>cd /mnt/server/logs/</code></p>\n</li>\n<li><p><code>cd /mnt/data/server/logs/</code></p>\n</li>\n<li><p>日志</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep -A 20 &quot;NoticeAspect&quot; /mnt/server/logs/mmplanet-app-order-service-1.0.0-SNAPSHOT.out</span><br></pre></td></tr></table></figure>\n\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tail -f -n 100 mmplanet-app-order-service-1.0.0-SNAPSHOT.out</span><br></pre></td></tr></table></figure></li>\n<li><p>书签</p>\n<ol>\n<li>[代码仓库] <a href=\"http://47.110.127.82:8801/users/sign_in\">http://47.110.127.82:8801/users/sign_in</a></li>\n<li>[测试服老头子] <a href=\"http://47.110.127.82:8803/\">http://47.110.127.82:8803/</a></li>\n<li>[正试服老头子] <a href=\"https://jenkins.mmplanet.cn/\">https://jenkins.mmplanet.cn/</a></li>\n<li>[蓝湖] <a href=\"https://lanhuapp.com/web/#/\">https://lanhuapp.com/web/#/</a></li>\n<li>[绵绵星球测试 web] <a href=\"https://webtest.mmplanet.cn/#/mnt/app\">https://webtest.mmplanet.cn/#/mnt/app</a></li>\n<li>[绵绵星球正试 web] <a href=\"https://web.mmplanet.cn/#/monitor/server/online\">https://web.mmplanet.cn/#/monitor/server/online</a></li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>服务器地址：47.110.127.82 / 47.100.230.246</p>\n</li>\n<li><p>密码：mmxq220424@#$  /  mmplanetnginx0701123!@#</p>\n</li>\n<li><p>命令：ssh <a href=\"mailto:&#114;&#111;&#x6f;&#116;&#64;&#52;&#x37;&#46;&#x31;&#49;&#x30;&#46;&#x31;&#50;&#x37;&#x2e;&#56;&#x32;\">&#114;&#111;&#x6f;&#116;&#64;&#52;&#x37;&#46;&#x31;&#49;&#x30;&#46;&#x31;&#50;&#x37;&#x2e;&#56;&#x32;</a></p>\n</li>\n<li><p><code>cd /mnt/server/logs/</code></p>\n</li>\n<li><p><code>cd /mnt/data/server/logs/</code></p>\n</li>\n<li><p>日志</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep -A 20 &quot;NoticeAspect&quot; /mnt/server/logs/mmplanet-app-order-service-1.0.0-SNAPSHOT.out</span><br></pre></td></tr></table></figure>\n\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tail -f -n 100 mmplanet-app-order-service-1.0.0-SNAPSHOT.out</span><br></pre></td></tr></table></figure></li>\n<li><p>书签</p>\n<ol>\n<li>[代码仓库] <a href=\"http://47.110.127.82:8801/users/sign_in\">http://47.110.127.82:8801/users/sign_in</a></li>\n<li>[测试服老头子] <a href=\"http://47.110.127.82:8803/\">http://47.110.127.82:8803/</a></li>\n<li>[正试服老头子] <a href=\"https://jenkins.mmplanet.cn/\">https://jenkins.mmplanet.cn/</a></li>\n<li>[蓝湖] <a href=\"https://lanhuapp.com/web/#/\">https://lanhuapp.com/web/#/</a></li>\n<li>[绵绵星球测试 web] <a href=\"https://webtest.mmplanet.cn/#/mnt/app\">https://webtest.mmplanet.cn/#/mnt/app</a></li>\n<li>[绵绵星球正试 web] <a href=\"https://web.mmplanet.cn/#/monitor/server/online\">https://web.mmplanet.cn/#/monitor/server/online</a></li>\n</ol>\n</li>\n</ul>\n"},{"title":"订单售后按钮及文案设计","date":"2022-07-20T01:17:34.000Z","_content":"\n\n### 退款退货\n\n- 买家\n\n|   文案  |     状态    |   按钮   | 备注|\n| :--: | :--: | :--: |:--: |\n|  已提交退款退货申请 等待卖家处理    |   待处理   |  取消申请    | 无|\n|  卖家已同意退款退货申请     |  待寄回    |   寄回   | 无 |\n|   卖家已同意退款退货申请    |   退款退货确认中   |    无  | 买家寄回之后显示|\n|   卖家已同意退款退货申请    |   退款退货确认中   |    无  |无|\n|   无    |   退款退货成功   |    无  | 无|\n|   无    |   退款退货失败    |    再次申请  | 无|\n\n- 卖家\n\n|   文案  |     状态    |   按钮   |\n| :--: | :--: | :--: |\n|  买家申请退货退款 |   待处理   |  同意 拒绝    |\n|  您已经同意买家的退款退货申请     |  待寄回    |   取消订单   查看物流   确认寄回   |\n|   无    |   退款退货确认中   |    取消订单  查看物流   退款  |\n|   无    |   退款退货成功   |    查看物流  |\n|   无    |   退款退货失败    |    无  |\n\n\n### 退款\n\n- 买家\n\n|   文案  |     状态    |   按钮   |\n| :--: | :--: | :--: |\n|  已提交退款申请 等待卖家处理    |   待处理   |  取消申请    |\n|  无     |  已取消    |   无   |\n|   无    |   退款成功   |    无  |\n|   无    |   退款失败    |    再次申请  |\n\n- 卖家\n\n|   文案  |     状态    |   按钮   |\n| :--: | :--: | :--: |\n|  买家申请退款  |   待处理   |  同意 拒绝    |\n|  无     |  已取消    |   无   |\n|   无    |   退款成功   |    无  |\n|   无    |   退款失败    |    无  |\n\n\n\n### 换货\n\n- 买家\n\n|   文案  |     状态    |   按钮   | 备注 |\n| :--: | :--: | :--: |:--: |\n|  已提交换货申请 等待卖家处理    |   待处理   |  取消申请    |无|\n|  卖家已同意换货申请     |  待寄回    |   寄回   | 无|\n|   卖家已同意换货申请    |   换货确认中   |    无  | 买家寄回之后显示|\n|   卖家已同意换货申请    |   换货确认中   |   确认换货  |买家确认换货变成换货成功|\n|   无    |   换货成功    |    继续换货  | 无|\n|   无    |   换货失败    |    再次申请  | 无|\n\n- 卖家\n\n|   文案  |     状态    |   按钮   | \n| :--: | :--: | :--: |\n|  买家申请换货   |   待处理   |  同意 拒绝   |\n|  您已同意买家的换货申请     |  待寄回    |       |\n|  您已同意买家的换货申请     |  买家已寄回    |    取消订单  查看物流  确认换货   |\n|   无    |   换货确认中   |   无  | \n|   无    |   换货成功    |    查看物流  | \n|   无    |   换货失败    |    无  | \n\n\n### 回收\n\n经销商\n\n|   文案  |     状态    |   按钮   | \n| :--: | :--: | :--: |\n|  打样商品回收寄回     |    回收中  |   查看物流    确认回收   |\n|   打样商品回收寄回    |   回收成功   |   查看物流   |\n\n\n### 表数据\n|id|type|attribute|attribute_1|attribute_values|description|\n|--|----|---------|-----------|----------------|-----------|\n|1|productionProcess|baby||[{\"step\":\"0\",\"stepName\":\"配色中\"},{\"step\":\"1\",\"stepName\":\"精雕细琢中\"},{\"step\":\"2\",\"stepName\":\"车缝中\"},{\"step\":\"3\",\"stepName\":\"邮寄中\"},{\"step\":\"4\",\"stepName\":\"审核中\"},{\"step\":\"5\",\"stepName\":\"定样\"}]|娃娃的生产进度|\n|10|seller|待寄回 |BGM|您已经同意买家的退款退货申请|6;7;8|\n|11|seller|退款退货确认中|BGM||6;7;9|\n|12|seller|退款退货成功|BGM||7|\n|13|seller|退款退货失败|BGM|||\n|14|buyer|待处理|BM|已提交退款申请 等待卖家处理|1|\n|15|buyer|已取消|BM|||\n|16|buyer|退款成功|BM|||\n|17|buyer|退款失败|BM||10|\n|18|seller|待处理|BM|买家申请退款|4;5|\n|19|seller|已取消|BM|||\n|2|productionProcess|clothes||[{\"step\":\"0\",\"stepName\":\"配采开中\"},{\"step\":\"1\",\"stepName\":\"精雕细琢中\"},{\"step\":\"2\",\"stepName\":\"车缝中\"},{\"step\":\"3\",\"stepName\":\"邮寄中\"},{\"step\":\"4\",\"stepName\":\"审核中\"},{\"step\":\"5\",\"stepName\":\"定样\"}]|娃衣的生产进度|\n|20|seller|退款成功|BM|||\n|21|seller|退款失败|BM|||\n|22|buyer|待处理|SG|已提交换货申请 等待卖家处理|1|\n|23|buyer|待寄回|SG|卖家已同意换货申请 |2|\n|24|buyer|换货确认中|SG|卖家已同意换货申请 |12|\n|25|buyer|换货成功|SG||11|\n|26|buyer|换货失败|SG||3|\n|27|seller|待处理|SG|买家申请换货|4;5|\n|28|seller|待寄回|SG|您已同意买家的换货申请 |6;7;8|\n|29|seller|换货确认中|SG|||\n|3|afterSales|operation||[{\"identify\":\"1\",\"operation\":\"取消申请\"},{\"identify\":\"2\",\"operation\":\"寄回\"},{\"identify\":\"3\",\"operation\":\"再次申请\"},{\"identify\":\"4\",\"operation\":\"同意\"},{\"identify\":\"5\",\"operation\":\"拒绝\"},{\"identify\":\"6\",\"operation\":\"取消订单\"},{\"identify\":\"7\",\"operation\":\"查看物流\"},{\"identify\":\"8\",\"operation\":\"确认寄回\"},{\"identify\":\"9\",\"operation\":\"退款\"},{\"identify\":\"10\",\"operation\":\"再次申请\"},{\"identify\":\"11\",\"operation\":\"继续换货\"},{\"identify\":\"12\",\"operation\":\"确认换货\"},{\"identify\":\"13\",\"operation\":\"确认回收\"}]|售后操作|\n|30|seller|换货成功|SG||7|\n|31|seller|换货失败|SG|||\n|32|switch|orderCodeSplitSwitch||1|1开，0关|\n|33|seller|回收中|RG|打样商品回收寄回|7;13|\n|34|seller|回收成功|RG||7|\n|35|buyer|回收中|RG|打样商品回收寄回||\n|36|message|BGM|同意|{\"actionDesc\":\"去处理\",\"content\":\"您的订单#商品名称#卖家已同意退款退货\",\"title\":\"卖家同意退款退货申请通知\"}||\n|37|message|BGM|拒绝|{\"actionDesc\":\"快去看看\",\"content\":\"您的商品#商品名称#卖家拒绝退款退货\",\"title\":\"退款退货失败通知\"}||\n|38|message|SG|同意|{\"actionDesc\":\"去处理\",\"content\":\"您的订单#商品名称#卖家已同意换货\",\"title\":\"卖家同意换货申请通知\"}||\n|39|message|SG|拒绝|{\"actionDesc\":\"快去看看\",\"content\":\"您的商品#商品名称#卖家拒绝换货\",\"title\":\"换货失败通知\"}||\n|4|buyer|待处理|BGM|已提交退款退货申请 等待卖家处理|1|\n|40|message|BM|同意|{\"actionDesc\":\"去看看\",\"content\":\"您的商品#商品名称#已成功退款\",\"title\":\"退款成功通知\"}||\n|41|message|BM|拒绝|{\"actionDesc\":\"快去看看\",\"content\":\"您的商品#商品名称#卖家拒绝退款\",\"title\":\"退款失败通知\"}||\n|42|productionProcess|presales||[{\"step\":\"0\",\"stepName\":\"未开始\"},{\"step\":\"1\",\"stepName\":\"寄样中\"},{\"step\":\"2\",\"stepName\":\"生产中\"},{\"step\":\"3\",\"stepName\":\"已完成\"}]|saas大货生产进度|\n|43|message|SAAS||{\"actionDesc\":\"快去看看\",\"content\":\"您的商品%s生产进度更新\",\"title\":\"进度通知\"}||\n|44|message|SYNC_LOGISTICS||{\"actionDesc\":\"快去看看\",\"content\":\"您有一个订单已发货\",\"title\":\"发货通知\"}||\n|5|buyer|待寄回|BGM|卖家已同意退款退货申请 |2|\n|6|buyer|退款退货失败|BGM||10|\n|7|buyer|退款退货成功|BGM|||\n|8|buyer|退款退货确认中|BGM|卖家已同意退款退货申请||\n|9|seller|待处理|BGM|买家申请退货退款|4;5|\n\n\n### 表结构\n\n``` sql\n-- chh_mmplanet_order.chh_object_attribute_values definition\n\nCREATE TABLE `chh_object_attribute_values` (\n  `id` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '主键',\n  `type` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '对象类型',\n  `attribute` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '对象属性',\n  `attribute_1` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL,\n  `attribute_values` varchar(1000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '对象属性值',\n  `description` varchar(300) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '属性描述',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='object_attribute_values（非常重要，请勿删除任何数据）';\n```\n\n\n```sql\nINSERT INTO chh_mmplanet_order.chh_object_attribute_values (id,`type`,`attribute`,attribute_1,attribute_values,description) VALUES \n('1','productionProcess','baby',NULL,'[{\"step\":\"0\",\"stepName\":\"配色中\"},{\"step\":\"1\",\"stepName\":\"精雕细琢中\"},{\"step\":\"2\",\"stepName\":\"车缝中\"},{\"step\":\"3\",\"stepName\":\"邮寄中\"},{\"step\":\"4\",\"stepName\":\"审核中\"},{\"step\":\"5\",\"stepName\":\"定样\"}]','娃娃的生产进度')\n,('10','seller','待寄回 ','BGM','您已经同意买家的退款退货申请','6;7;8')\n,('11','seller','退款退货确认中','BGM',NULL,'6;7;9')\n,('12','seller','退款退货成功','BGM',NULL,'7')\n,('13','seller','退款退货失败','BGM',NULL,NULL)\n,('14','buyer','待处理','BM','已提交退款申请 等待卖家处理','1')\n,('15','buyer','已取消','BM','','')\n,('16','buyer','退款成功','BM',NULL,'')\n,('17','buyer','退款失败','BM',NULL,'10')\n,('18','seller','待处理','BM','买家申请退款','4;5')\n;\nINSERT INTO chh_mmplanet_order.chh_object_attribute_values (id,`type`,`attribute`,attribute_1,attribute_values,description) VALUES \n('19','seller','已取消','BM','','')\n,('2','productionProcess','clothes',NULL,'[{\"step\":\"0\",\"stepName\":\"配采开中\"},{\"step\":\"1\",\"stepName\":\"精雕细琢中\"},{\"step\":\"2\",\"stepName\":\"车缝中\"},{\"step\":\"3\",\"stepName\":\"邮寄中\"},{\"step\":\"4\",\"stepName\":\"审核中\"},{\"step\":\"5\",\"stepName\":\"定样\"}]','娃衣的生产进度')\n,('20','seller','退款成功','BM',NULL,'')\n,('21','seller','退款失败','BM',NULL,'')\n,('22','buyer','待处理','SG','已提交换货申请 等待卖家处理','1')\n,('23','buyer','待寄回','SG','卖家已同意换货申请 ','2')\n,('24','buyer','换货确认中','SG','卖家已同意换货申请 ','12')\n,('25','buyer','换货成功','SG','','11')\n,('26','buyer','换货失败','SG','','3')\n,('27','seller','待处理','SG','买家申请换货','4;5')\n;\nINSERT INTO chh_mmplanet_order.chh_object_attribute_values (id,`type`,`attribute`,attribute_1,attribute_values,description) VALUES \n('28','seller','待寄回','SG','您已同意买家的换货申请 ','6;7;8')\n,('29','seller','换货确认中','SG','','')\n,('3','afterSales','operation',NULL,'[{\"identify\":\"1\",\"operation\":\"取消申请\"},{\"identify\":\"2\",\"operation\":\"寄回\"},{\"identify\":\"3\",\"operation\":\"再次申请\"},{\"identify\":\"4\",\"operation\":\"同意\"},{\"identify\":\"5\",\"operation\":\"拒绝\"},{\"identify\":\"6\",\"operation\":\"取消订单\"},{\"identify\":\"7\",\"operation\":\"查看物流\"},{\"identify\":\"8\",\"operation\":\"确认寄回\"},{\"identify\":\"9\",\"operation\":\"退款\"},{\"identify\":\"10\",\"operation\":\"再次申请\"},{\"identify\":\"11\",\"operation\":\"继续换货\"},{\"identify\":\"12\",\"operation\":\"确认换货\"},{\"identify\":\"13\",\"operation\":\"确认回收\"}]','售后操作')\n,('30','seller','换货成功','SG','','7')\n,('31','seller','换货失败','SG','','')\n,('32','switch','orderCodeSplitSwitch',NULL,'1','1开，0关')\n,('33','seller','回收中','RG','打样商品回收寄回','7;13')\n,('34','seller','回收成功','RG','','7')\n,('35','buyer','回收中','RG','打样商品回收寄回',NULL)\n,('36','message','BGM','同意','{\"actionDesc\":\"去处理\",\"content\":\"您的订单#商品名称#卖家已同意退款退货\",\"title\":\"卖家同意退款退货申请通知\"}','')\n;\nINSERT INTO chh_mmplanet_order.chh_object_attribute_values (id,`type`,`attribute`,attribute_1,attribute_values,description) VALUES \n('37','message','BGM','拒绝','{\"actionDesc\":\"快去看看\",\"content\":\"您的商品#商品名称#卖家拒绝退款退货\",\"title\":\"退款退货失败通知\"}','')\n,('38','message','SG','同意','{\"actionDesc\":\"去处理\",\"content\":\"您的订单#商品名称#卖家已同意换货\",\"title\":\"卖家同意换货申请通知\"}','')\n,('39','message','SG','拒绝','{\"actionDesc\":\"快去看看\",\"content\":\"您的商品#商品名称#卖家拒绝换货\",\"title\":\"换货失败通知\"}','')\n,('4','buyer','待处理','BGM','已提交退款退货申请 等待卖家处理','1')\n,('40','message','BM','同意','{\"actionDesc\":\"去看看\",\"content\":\"您的商品#商品名称#已成功退款\",\"title\":\"退款成功通知\"}','')\n,('41','message','BM','拒绝','{\"actionDesc\":\"快去看看\",\"content\":\"您的商品#商品名称#卖家拒绝退款\",\"title\":\"退款失败通知\"}','')\n,('42','productionProcess','presales',NULL,'[{\"step\":\"0\",\"stepName\":\"未开始\"},{\"step\":\"1\",\"stepName\":\"寄样中\"},{\"step\":\"2\",\"stepName\":\"生产中\"},{\"step\":\"3\",\"stepName\":\"已完成\"}]','saas大货生产进度')\n,('43','message','SAAS',NULL,'{\"actionDesc\":\"快去看看\",\"content\":\"您的商品%s生产进度更新\",\"title\":\"进度通知\"}',NULL)\n,('44','message','SYNC_LOGISTICS',NULL,'{\"actionDesc\":\"快去看看\",\"content\":\"您有一个订单已发货\",\"title\":\"发货通知\"}',NULL)\n,('5','buyer','待寄回','BGM','卖家已同意退款退货申请 ','2')\n;\nINSERT INTO chh_mmplanet_order.chh_object_attribute_values (id,`type`,`attribute`,attribute_1,attribute_values,description) VALUES \n('6','buyer','退款退货失败','BGM','','10')\n,('7','buyer','退款退货成功','BGM','','')\n,('8','buyer','退款退货确认中','BGM','卖家已同意退款退货申请',NULL)\n,('9','seller','待处理','BGM','买家申请退货退款','4;5')\n;\n```\n\n","source":"_posts/订单售后按钮及文案设计.md","raw":"---\ntitle: 订单售后按钮及文案设计\ndate: 2022-07-20 09:17:34\ntags: Design\n---\n\n\n### 退款退货\n\n- 买家\n\n|   文案  |     状态    |   按钮   | 备注|\n| :--: | :--: | :--: |:--: |\n|  已提交退款退货申请 等待卖家处理    |   待处理   |  取消申请    | 无|\n|  卖家已同意退款退货申请     |  待寄回    |   寄回   | 无 |\n|   卖家已同意退款退货申请    |   退款退货确认中   |    无  | 买家寄回之后显示|\n|   卖家已同意退款退货申请    |   退款退货确认中   |    无  |无|\n|   无    |   退款退货成功   |    无  | 无|\n|   无    |   退款退货失败    |    再次申请  | 无|\n\n- 卖家\n\n|   文案  |     状态    |   按钮   |\n| :--: | :--: | :--: |\n|  买家申请退货退款 |   待处理   |  同意 拒绝    |\n|  您已经同意买家的退款退货申请     |  待寄回    |   取消订单   查看物流   确认寄回   |\n|   无    |   退款退货确认中   |    取消订单  查看物流   退款  |\n|   无    |   退款退货成功   |    查看物流  |\n|   无    |   退款退货失败    |    无  |\n\n\n### 退款\n\n- 买家\n\n|   文案  |     状态    |   按钮   |\n| :--: | :--: | :--: |\n|  已提交退款申请 等待卖家处理    |   待处理   |  取消申请    |\n|  无     |  已取消    |   无   |\n|   无    |   退款成功   |    无  |\n|   无    |   退款失败    |    再次申请  |\n\n- 卖家\n\n|   文案  |     状态    |   按钮   |\n| :--: | :--: | :--: |\n|  买家申请退款  |   待处理   |  同意 拒绝    |\n|  无     |  已取消    |   无   |\n|   无    |   退款成功   |    无  |\n|   无    |   退款失败    |    无  |\n\n\n\n### 换货\n\n- 买家\n\n|   文案  |     状态    |   按钮   | 备注 |\n| :--: | :--: | :--: |:--: |\n|  已提交换货申请 等待卖家处理    |   待处理   |  取消申请    |无|\n|  卖家已同意换货申请     |  待寄回    |   寄回   | 无|\n|   卖家已同意换货申请    |   换货确认中   |    无  | 买家寄回之后显示|\n|   卖家已同意换货申请    |   换货确认中   |   确认换货  |买家确认换货变成换货成功|\n|   无    |   换货成功    |    继续换货  | 无|\n|   无    |   换货失败    |    再次申请  | 无|\n\n- 卖家\n\n|   文案  |     状态    |   按钮   | \n| :--: | :--: | :--: |\n|  买家申请换货   |   待处理   |  同意 拒绝   |\n|  您已同意买家的换货申请     |  待寄回    |       |\n|  您已同意买家的换货申请     |  买家已寄回    |    取消订单  查看物流  确认换货   |\n|   无    |   换货确认中   |   无  | \n|   无    |   换货成功    |    查看物流  | \n|   无    |   换货失败    |    无  | \n\n\n### 回收\n\n经销商\n\n|   文案  |     状态    |   按钮   | \n| :--: | :--: | :--: |\n|  打样商品回收寄回     |    回收中  |   查看物流    确认回收   |\n|   打样商品回收寄回    |   回收成功   |   查看物流   |\n\n\n### 表数据\n|id|type|attribute|attribute_1|attribute_values|description|\n|--|----|---------|-----------|----------------|-----------|\n|1|productionProcess|baby||[{\"step\":\"0\",\"stepName\":\"配色中\"},{\"step\":\"1\",\"stepName\":\"精雕细琢中\"},{\"step\":\"2\",\"stepName\":\"车缝中\"},{\"step\":\"3\",\"stepName\":\"邮寄中\"},{\"step\":\"4\",\"stepName\":\"审核中\"},{\"step\":\"5\",\"stepName\":\"定样\"}]|娃娃的生产进度|\n|10|seller|待寄回 |BGM|您已经同意买家的退款退货申请|6;7;8|\n|11|seller|退款退货确认中|BGM||6;7;9|\n|12|seller|退款退货成功|BGM||7|\n|13|seller|退款退货失败|BGM|||\n|14|buyer|待处理|BM|已提交退款申请 等待卖家处理|1|\n|15|buyer|已取消|BM|||\n|16|buyer|退款成功|BM|||\n|17|buyer|退款失败|BM||10|\n|18|seller|待处理|BM|买家申请退款|4;5|\n|19|seller|已取消|BM|||\n|2|productionProcess|clothes||[{\"step\":\"0\",\"stepName\":\"配采开中\"},{\"step\":\"1\",\"stepName\":\"精雕细琢中\"},{\"step\":\"2\",\"stepName\":\"车缝中\"},{\"step\":\"3\",\"stepName\":\"邮寄中\"},{\"step\":\"4\",\"stepName\":\"审核中\"},{\"step\":\"5\",\"stepName\":\"定样\"}]|娃衣的生产进度|\n|20|seller|退款成功|BM|||\n|21|seller|退款失败|BM|||\n|22|buyer|待处理|SG|已提交换货申请 等待卖家处理|1|\n|23|buyer|待寄回|SG|卖家已同意换货申请 |2|\n|24|buyer|换货确认中|SG|卖家已同意换货申请 |12|\n|25|buyer|换货成功|SG||11|\n|26|buyer|换货失败|SG||3|\n|27|seller|待处理|SG|买家申请换货|4;5|\n|28|seller|待寄回|SG|您已同意买家的换货申请 |6;7;8|\n|29|seller|换货确认中|SG|||\n|3|afterSales|operation||[{\"identify\":\"1\",\"operation\":\"取消申请\"},{\"identify\":\"2\",\"operation\":\"寄回\"},{\"identify\":\"3\",\"operation\":\"再次申请\"},{\"identify\":\"4\",\"operation\":\"同意\"},{\"identify\":\"5\",\"operation\":\"拒绝\"},{\"identify\":\"6\",\"operation\":\"取消订单\"},{\"identify\":\"7\",\"operation\":\"查看物流\"},{\"identify\":\"8\",\"operation\":\"确认寄回\"},{\"identify\":\"9\",\"operation\":\"退款\"},{\"identify\":\"10\",\"operation\":\"再次申请\"},{\"identify\":\"11\",\"operation\":\"继续换货\"},{\"identify\":\"12\",\"operation\":\"确认换货\"},{\"identify\":\"13\",\"operation\":\"确认回收\"}]|售后操作|\n|30|seller|换货成功|SG||7|\n|31|seller|换货失败|SG|||\n|32|switch|orderCodeSplitSwitch||1|1开，0关|\n|33|seller|回收中|RG|打样商品回收寄回|7;13|\n|34|seller|回收成功|RG||7|\n|35|buyer|回收中|RG|打样商品回收寄回||\n|36|message|BGM|同意|{\"actionDesc\":\"去处理\",\"content\":\"您的订单#商品名称#卖家已同意退款退货\",\"title\":\"卖家同意退款退货申请通知\"}||\n|37|message|BGM|拒绝|{\"actionDesc\":\"快去看看\",\"content\":\"您的商品#商品名称#卖家拒绝退款退货\",\"title\":\"退款退货失败通知\"}||\n|38|message|SG|同意|{\"actionDesc\":\"去处理\",\"content\":\"您的订单#商品名称#卖家已同意换货\",\"title\":\"卖家同意换货申请通知\"}||\n|39|message|SG|拒绝|{\"actionDesc\":\"快去看看\",\"content\":\"您的商品#商品名称#卖家拒绝换货\",\"title\":\"换货失败通知\"}||\n|4|buyer|待处理|BGM|已提交退款退货申请 等待卖家处理|1|\n|40|message|BM|同意|{\"actionDesc\":\"去看看\",\"content\":\"您的商品#商品名称#已成功退款\",\"title\":\"退款成功通知\"}||\n|41|message|BM|拒绝|{\"actionDesc\":\"快去看看\",\"content\":\"您的商品#商品名称#卖家拒绝退款\",\"title\":\"退款失败通知\"}||\n|42|productionProcess|presales||[{\"step\":\"0\",\"stepName\":\"未开始\"},{\"step\":\"1\",\"stepName\":\"寄样中\"},{\"step\":\"2\",\"stepName\":\"生产中\"},{\"step\":\"3\",\"stepName\":\"已完成\"}]|saas大货生产进度|\n|43|message|SAAS||{\"actionDesc\":\"快去看看\",\"content\":\"您的商品%s生产进度更新\",\"title\":\"进度通知\"}||\n|44|message|SYNC_LOGISTICS||{\"actionDesc\":\"快去看看\",\"content\":\"您有一个订单已发货\",\"title\":\"发货通知\"}||\n|5|buyer|待寄回|BGM|卖家已同意退款退货申请 |2|\n|6|buyer|退款退货失败|BGM||10|\n|7|buyer|退款退货成功|BGM|||\n|8|buyer|退款退货确认中|BGM|卖家已同意退款退货申请||\n|9|seller|待处理|BGM|买家申请退货退款|4;5|\n\n\n### 表结构\n\n``` sql\n-- chh_mmplanet_order.chh_object_attribute_values definition\n\nCREATE TABLE `chh_object_attribute_values` (\n  `id` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '主键',\n  `type` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '对象类型',\n  `attribute` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '对象属性',\n  `attribute_1` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL,\n  `attribute_values` varchar(1000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '对象属性值',\n  `description` varchar(300) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '属性描述',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='object_attribute_values（非常重要，请勿删除任何数据）';\n```\n\n\n```sql\nINSERT INTO chh_mmplanet_order.chh_object_attribute_values (id,`type`,`attribute`,attribute_1,attribute_values,description) VALUES \n('1','productionProcess','baby',NULL,'[{\"step\":\"0\",\"stepName\":\"配色中\"},{\"step\":\"1\",\"stepName\":\"精雕细琢中\"},{\"step\":\"2\",\"stepName\":\"车缝中\"},{\"step\":\"3\",\"stepName\":\"邮寄中\"},{\"step\":\"4\",\"stepName\":\"审核中\"},{\"step\":\"5\",\"stepName\":\"定样\"}]','娃娃的生产进度')\n,('10','seller','待寄回 ','BGM','您已经同意买家的退款退货申请','6;7;8')\n,('11','seller','退款退货确认中','BGM',NULL,'6;7;9')\n,('12','seller','退款退货成功','BGM',NULL,'7')\n,('13','seller','退款退货失败','BGM',NULL,NULL)\n,('14','buyer','待处理','BM','已提交退款申请 等待卖家处理','1')\n,('15','buyer','已取消','BM','','')\n,('16','buyer','退款成功','BM',NULL,'')\n,('17','buyer','退款失败','BM',NULL,'10')\n,('18','seller','待处理','BM','买家申请退款','4;5')\n;\nINSERT INTO chh_mmplanet_order.chh_object_attribute_values (id,`type`,`attribute`,attribute_1,attribute_values,description) VALUES \n('19','seller','已取消','BM','','')\n,('2','productionProcess','clothes',NULL,'[{\"step\":\"0\",\"stepName\":\"配采开中\"},{\"step\":\"1\",\"stepName\":\"精雕细琢中\"},{\"step\":\"2\",\"stepName\":\"车缝中\"},{\"step\":\"3\",\"stepName\":\"邮寄中\"},{\"step\":\"4\",\"stepName\":\"审核中\"},{\"step\":\"5\",\"stepName\":\"定样\"}]','娃衣的生产进度')\n,('20','seller','退款成功','BM',NULL,'')\n,('21','seller','退款失败','BM',NULL,'')\n,('22','buyer','待处理','SG','已提交换货申请 等待卖家处理','1')\n,('23','buyer','待寄回','SG','卖家已同意换货申请 ','2')\n,('24','buyer','换货确认中','SG','卖家已同意换货申请 ','12')\n,('25','buyer','换货成功','SG','','11')\n,('26','buyer','换货失败','SG','','3')\n,('27','seller','待处理','SG','买家申请换货','4;5')\n;\nINSERT INTO chh_mmplanet_order.chh_object_attribute_values (id,`type`,`attribute`,attribute_1,attribute_values,description) VALUES \n('28','seller','待寄回','SG','您已同意买家的换货申请 ','6;7;8')\n,('29','seller','换货确认中','SG','','')\n,('3','afterSales','operation',NULL,'[{\"identify\":\"1\",\"operation\":\"取消申请\"},{\"identify\":\"2\",\"operation\":\"寄回\"},{\"identify\":\"3\",\"operation\":\"再次申请\"},{\"identify\":\"4\",\"operation\":\"同意\"},{\"identify\":\"5\",\"operation\":\"拒绝\"},{\"identify\":\"6\",\"operation\":\"取消订单\"},{\"identify\":\"7\",\"operation\":\"查看物流\"},{\"identify\":\"8\",\"operation\":\"确认寄回\"},{\"identify\":\"9\",\"operation\":\"退款\"},{\"identify\":\"10\",\"operation\":\"再次申请\"},{\"identify\":\"11\",\"operation\":\"继续换货\"},{\"identify\":\"12\",\"operation\":\"确认换货\"},{\"identify\":\"13\",\"operation\":\"确认回收\"}]','售后操作')\n,('30','seller','换货成功','SG','','7')\n,('31','seller','换货失败','SG','','')\n,('32','switch','orderCodeSplitSwitch',NULL,'1','1开，0关')\n,('33','seller','回收中','RG','打样商品回收寄回','7;13')\n,('34','seller','回收成功','RG','','7')\n,('35','buyer','回收中','RG','打样商品回收寄回',NULL)\n,('36','message','BGM','同意','{\"actionDesc\":\"去处理\",\"content\":\"您的订单#商品名称#卖家已同意退款退货\",\"title\":\"卖家同意退款退货申请通知\"}','')\n;\nINSERT INTO chh_mmplanet_order.chh_object_attribute_values (id,`type`,`attribute`,attribute_1,attribute_values,description) VALUES \n('37','message','BGM','拒绝','{\"actionDesc\":\"快去看看\",\"content\":\"您的商品#商品名称#卖家拒绝退款退货\",\"title\":\"退款退货失败通知\"}','')\n,('38','message','SG','同意','{\"actionDesc\":\"去处理\",\"content\":\"您的订单#商品名称#卖家已同意换货\",\"title\":\"卖家同意换货申请通知\"}','')\n,('39','message','SG','拒绝','{\"actionDesc\":\"快去看看\",\"content\":\"您的商品#商品名称#卖家拒绝换货\",\"title\":\"换货失败通知\"}','')\n,('4','buyer','待处理','BGM','已提交退款退货申请 等待卖家处理','1')\n,('40','message','BM','同意','{\"actionDesc\":\"去看看\",\"content\":\"您的商品#商品名称#已成功退款\",\"title\":\"退款成功通知\"}','')\n,('41','message','BM','拒绝','{\"actionDesc\":\"快去看看\",\"content\":\"您的商品#商品名称#卖家拒绝退款\",\"title\":\"退款失败通知\"}','')\n,('42','productionProcess','presales',NULL,'[{\"step\":\"0\",\"stepName\":\"未开始\"},{\"step\":\"1\",\"stepName\":\"寄样中\"},{\"step\":\"2\",\"stepName\":\"生产中\"},{\"step\":\"3\",\"stepName\":\"已完成\"}]','saas大货生产进度')\n,('43','message','SAAS',NULL,'{\"actionDesc\":\"快去看看\",\"content\":\"您的商品%s生产进度更新\",\"title\":\"进度通知\"}',NULL)\n,('44','message','SYNC_LOGISTICS',NULL,'{\"actionDesc\":\"快去看看\",\"content\":\"您有一个订单已发货\",\"title\":\"发货通知\"}',NULL)\n,('5','buyer','待寄回','BGM','卖家已同意退款退货申请 ','2')\n;\nINSERT INTO chh_mmplanet_order.chh_object_attribute_values (id,`type`,`attribute`,attribute_1,attribute_values,description) VALUES \n('6','buyer','退款退货失败','BGM','','10')\n,('7','buyer','退款退货成功','BGM','','')\n,('8','buyer','退款退货确认中','BGM','卖家已同意退款退货申请',NULL)\n,('9','seller','待处理','BGM','买家申请退货退款','4;5')\n;\n```\n\n","slug":"订单售后按钮及文案设计","published":1,"updated":"2022-07-20T23:50:20.448Z","_id":"cl5sygbu20003x0ln7vz1f09z","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"退款退货\"><a href=\"#退款退货\" class=\"headerlink\" title=\"退款退货\"></a>退款退货</h3><ul>\n<li>买家</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">文案</th>\n<th align=\"center\">状态</th>\n<th align=\"center\">按钮</th>\n<th align=\"center\">备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">已提交退款退货申请 等待卖家处理</td>\n<td align=\"center\">待处理</td>\n<td align=\"center\">取消申请</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">卖家已同意退款退货申请</td>\n<td align=\"center\">待寄回</td>\n<td align=\"center\">寄回</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">卖家已同意退款退货申请</td>\n<td align=\"center\">退款退货确认中</td>\n<td align=\"center\">无</td>\n<td align=\"center\">买家寄回之后显示</td>\n</tr>\n<tr>\n<td align=\"center\">卖家已同意退款退货申请</td>\n<td align=\"center\">退款退货确认中</td>\n<td align=\"center\">无</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">退款退货成功</td>\n<td align=\"center\">无</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">退款退货失败</td>\n<td align=\"center\">再次申请</td>\n<td align=\"center\">无</td>\n</tr>\n</tbody></table>\n<ul>\n<li>卖家</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">文案</th>\n<th align=\"center\">状态</th>\n<th align=\"center\">按钮</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">买家申请退货退款</td>\n<td align=\"center\">待处理</td>\n<td align=\"center\">同意 拒绝</td>\n</tr>\n<tr>\n<td align=\"center\">您已经同意买家的退款退货申请</td>\n<td align=\"center\">待寄回</td>\n<td align=\"center\">取消订单   查看物流   确认寄回</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">退款退货确认中</td>\n<td align=\"center\">取消订单  查看物流   退款</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">退款退货成功</td>\n<td align=\"center\">查看物流</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">退款退货失败</td>\n<td align=\"center\">无</td>\n</tr>\n</tbody></table>\n<h3 id=\"退款\"><a href=\"#退款\" class=\"headerlink\" title=\"退款\"></a>退款</h3><ul>\n<li>买家</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">文案</th>\n<th align=\"center\">状态</th>\n<th align=\"center\">按钮</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">已提交退款申请 等待卖家处理</td>\n<td align=\"center\">待处理</td>\n<td align=\"center\">取消申请</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">已取消</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">退款成功</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">退款失败</td>\n<td align=\"center\">再次申请</td>\n</tr>\n</tbody></table>\n<ul>\n<li>卖家</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">文案</th>\n<th align=\"center\">状态</th>\n<th align=\"center\">按钮</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">买家申请退款</td>\n<td align=\"center\">待处理</td>\n<td align=\"center\">同意 拒绝</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">已取消</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">退款成功</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">退款失败</td>\n<td align=\"center\">无</td>\n</tr>\n</tbody></table>\n<h3 id=\"换货\"><a href=\"#换货\" class=\"headerlink\" title=\"换货\"></a>换货</h3><ul>\n<li>买家</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">文案</th>\n<th align=\"center\">状态</th>\n<th align=\"center\">按钮</th>\n<th align=\"center\">备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">已提交换货申请 等待卖家处理</td>\n<td align=\"center\">待处理</td>\n<td align=\"center\">取消申请</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">卖家已同意换货申请</td>\n<td align=\"center\">待寄回</td>\n<td align=\"center\">寄回</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">卖家已同意换货申请</td>\n<td align=\"center\">换货确认中</td>\n<td align=\"center\">无</td>\n<td align=\"center\">买家寄回之后显示</td>\n</tr>\n<tr>\n<td align=\"center\">卖家已同意换货申请</td>\n<td align=\"center\">换货确认中</td>\n<td align=\"center\">确认换货</td>\n<td align=\"center\">买家确认换货变成换货成功</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">换货成功</td>\n<td align=\"center\">继续换货</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">换货失败</td>\n<td align=\"center\">再次申请</td>\n<td align=\"center\">无</td>\n</tr>\n</tbody></table>\n<ul>\n<li>卖家</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">文案</th>\n<th align=\"center\">状态</th>\n<th align=\"center\">按钮</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">买家申请换货</td>\n<td align=\"center\">待处理</td>\n<td align=\"center\">同意 拒绝</td>\n</tr>\n<tr>\n<td align=\"center\">您已同意买家的换货申请</td>\n<td align=\"center\">待寄回</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">您已同意买家的换货申请</td>\n<td align=\"center\">买家已寄回</td>\n<td align=\"center\">取消订单  查看物流  确认换货</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">换货确认中</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">换货成功</td>\n<td align=\"center\">查看物流</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">换货失败</td>\n<td align=\"center\">无</td>\n</tr>\n</tbody></table>\n<h3 id=\"回收\"><a href=\"#回收\" class=\"headerlink\" title=\"回收\"></a>回收</h3><p>经销商</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">文案</th>\n<th align=\"center\">状态</th>\n<th align=\"center\">按钮</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">打样商品回收寄回</td>\n<td align=\"center\">回收中</td>\n<td align=\"center\">查看物流    确认回收</td>\n</tr>\n<tr>\n<td align=\"center\">打样商品回收寄回</td>\n<td align=\"center\">回收成功</td>\n<td align=\"center\">查看物流</td>\n</tr>\n</tbody></table>\n<h3 id=\"表数据\"><a href=\"#表数据\" class=\"headerlink\" title=\"表数据\"></a>表数据</h3><table>\n<thead>\n<tr>\n<th>id</th>\n<th>type</th>\n<th>attribute</th>\n<th>attribute_1</th>\n<th>attribute_values</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>productionProcess</td>\n<td>baby</td>\n<td></td>\n<td>[{“step”:”0”,”stepName”:”配色中”},{“step”:”1”,”stepName”:”精雕细琢中”},{“step”:”2”,”stepName”:”车缝中”},{“step”:”3”,”stepName”:”邮寄中”},{“step”:”4”,”stepName”:”审核中”},{“step”:”5”,”stepName”:”定样”}]</td>\n<td>娃娃的生产进度</td>\n</tr>\n<tr>\n<td>10</td>\n<td>seller</td>\n<td>待寄回</td>\n<td>BGM</td>\n<td>您已经同意买家的退款退货申请</td>\n<td>6;7;8</td>\n</tr>\n<tr>\n<td>11</td>\n<td>seller</td>\n<td>退款退货确认中</td>\n<td>BGM</td>\n<td></td>\n<td>6;7;9</td>\n</tr>\n<tr>\n<td>12</td>\n<td>seller</td>\n<td>退款退货成功</td>\n<td>BGM</td>\n<td></td>\n<td>7</td>\n</tr>\n<tr>\n<td>13</td>\n<td>seller</td>\n<td>退款退货失败</td>\n<td>BGM</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>buyer</td>\n<td>待处理</td>\n<td>BM</td>\n<td>已提交退款申请 等待卖家处理</td>\n<td>1</td>\n</tr>\n<tr>\n<td>15</td>\n<td>buyer</td>\n<td>已取消</td>\n<td>BM</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>buyer</td>\n<td>退款成功</td>\n<td>BM</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td>buyer</td>\n<td>退款失败</td>\n<td>BM</td>\n<td></td>\n<td>10</td>\n</tr>\n<tr>\n<td>18</td>\n<td>seller</td>\n<td>待处理</td>\n<td>BM</td>\n<td>买家申请退款</td>\n<td>4;5</td>\n</tr>\n<tr>\n<td>19</td>\n<td>seller</td>\n<td>已取消</td>\n<td>BM</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>productionProcess</td>\n<td>clothes</td>\n<td></td>\n<td>[{“step”:”0”,”stepName”:”配采开中”},{“step”:”1”,”stepName”:”精雕细琢中”},{“step”:”2”,”stepName”:”车缝中”},{“step”:”3”,”stepName”:”邮寄中”},{“step”:”4”,”stepName”:”审核中”},{“step”:”5”,”stepName”:”定样”}]</td>\n<td>娃衣的生产进度</td>\n</tr>\n<tr>\n<td>20</td>\n<td>seller</td>\n<td>退款成功</td>\n<td>BM</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td>seller</td>\n<td>退款失败</td>\n<td>BM</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td>buyer</td>\n<td>待处理</td>\n<td>SG</td>\n<td>已提交换货申请 等待卖家处理</td>\n<td>1</td>\n</tr>\n<tr>\n<td>23</td>\n<td>buyer</td>\n<td>待寄回</td>\n<td>SG</td>\n<td>卖家已同意换货申请</td>\n<td>2</td>\n</tr>\n<tr>\n<td>24</td>\n<td>buyer</td>\n<td>换货确认中</td>\n<td>SG</td>\n<td>卖家已同意换货申请</td>\n<td>12</td>\n</tr>\n<tr>\n<td>25</td>\n<td>buyer</td>\n<td>换货成功</td>\n<td>SG</td>\n<td></td>\n<td>11</td>\n</tr>\n<tr>\n<td>26</td>\n<td>buyer</td>\n<td>换货失败</td>\n<td>SG</td>\n<td></td>\n<td>3</td>\n</tr>\n<tr>\n<td>27</td>\n<td>seller</td>\n<td>待处理</td>\n<td>SG</td>\n<td>买家申请换货</td>\n<td>4;5</td>\n</tr>\n<tr>\n<td>28</td>\n<td>seller</td>\n<td>待寄回</td>\n<td>SG</td>\n<td>您已同意买家的换货申请</td>\n<td>6;7;8</td>\n</tr>\n<tr>\n<td>29</td>\n<td>seller</td>\n<td>换货确认中</td>\n<td>SG</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>afterSales</td>\n<td>operation</td>\n<td></td>\n<td>[{“identify”:”1”,”operation”:”取消申请”},{“identify”:”2”,”operation”:”寄回”},{“identify”:”3”,”operation”:”再次申请”},{“identify”:”4”,”operation”:”同意”},{“identify”:”5”,”operation”:”拒绝”},{“identify”:”6”,”operation”:”取消订单”},{“identify”:”7”,”operation”:”查看物流”},{“identify”:”8”,”operation”:”确认寄回”},{“identify”:”9”,”operation”:”退款”},{“identify”:”10”,”operation”:”再次申请”},{“identify”:”11”,”operation”:”继续换货”},{“identify”:”12”,”operation”:”确认换货”},{“identify”:”13”,”operation”:”确认回收”}]</td>\n<td>售后操作</td>\n</tr>\n<tr>\n<td>30</td>\n<td>seller</td>\n<td>换货成功</td>\n<td>SG</td>\n<td></td>\n<td>7</td>\n</tr>\n<tr>\n<td>31</td>\n<td>seller</td>\n<td>换货失败</td>\n<td>SG</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>32</td>\n<td>switch</td>\n<td>orderCodeSplitSwitch</td>\n<td></td>\n<td>1</td>\n<td>1开，0关</td>\n</tr>\n<tr>\n<td>33</td>\n<td>seller</td>\n<td>回收中</td>\n<td>RG</td>\n<td>打样商品回收寄回</td>\n<td>7;13</td>\n</tr>\n<tr>\n<td>34</td>\n<td>seller</td>\n<td>回收成功</td>\n<td>RG</td>\n<td></td>\n<td>7</td>\n</tr>\n<tr>\n<td>35</td>\n<td>buyer</td>\n<td>回收中</td>\n<td>RG</td>\n<td>打样商品回收寄回</td>\n<td></td>\n</tr>\n<tr>\n<td>36</td>\n<td>message</td>\n<td>BGM</td>\n<td>同意</td>\n<td>{“actionDesc”:”去处理”,”content”:”您的订单#商品名称#卖家已同意退款退货”,”title”:”卖家同意退款退货申请通知”}</td>\n<td></td>\n</tr>\n<tr>\n<td>37</td>\n<td>message</td>\n<td>BGM</td>\n<td>拒绝</td>\n<td>{“actionDesc”:”快去看看”,”content”:”您的商品#商品名称#卖家拒绝退款退货”,”title”:”退款退货失败通知”}</td>\n<td></td>\n</tr>\n<tr>\n<td>38</td>\n<td>message</td>\n<td>SG</td>\n<td>同意</td>\n<td>{“actionDesc”:”去处理”,”content”:”您的订单#商品名称#卖家已同意换货”,”title”:”卖家同意换货申请通知”}</td>\n<td></td>\n</tr>\n<tr>\n<td>39</td>\n<td>message</td>\n<td>SG</td>\n<td>拒绝</td>\n<td>{“actionDesc”:”快去看看”,”content”:”您的商品#商品名称#卖家拒绝换货”,”title”:”换货失败通知”}</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>buyer</td>\n<td>待处理</td>\n<td>BGM</td>\n<td>已提交退款退货申请 等待卖家处理</td>\n<td>1</td>\n</tr>\n<tr>\n<td>40</td>\n<td>message</td>\n<td>BM</td>\n<td>同意</td>\n<td>{“actionDesc”:”去看看”,”content”:”您的商品#商品名称#已成功退款”,”title”:”退款成功通知”}</td>\n<td></td>\n</tr>\n<tr>\n<td>41</td>\n<td>message</td>\n<td>BM</td>\n<td>拒绝</td>\n<td>{“actionDesc”:”快去看看”,”content”:”您的商品#商品名称#卖家拒绝退款”,”title”:”退款失败通知”}</td>\n<td></td>\n</tr>\n<tr>\n<td>42</td>\n<td>productionProcess</td>\n<td>presales</td>\n<td></td>\n<td>[{“step”:”0”,”stepName”:”未开始”},{“step”:”1”,”stepName”:”寄样中”},{“step”:”2”,”stepName”:”生产中”},{“step”:”3”,”stepName”:”已完成”}]</td>\n<td>saas大货生产进度</td>\n</tr>\n<tr>\n<td>43</td>\n<td>message</td>\n<td>SAAS</td>\n<td></td>\n<td>{“actionDesc”:”快去看看”,”content”:”您的商品%s生产进度更新”,”title”:”进度通知”}</td>\n<td></td>\n</tr>\n<tr>\n<td>44</td>\n<td>message</td>\n<td>SYNC_LOGISTICS</td>\n<td></td>\n<td>{“actionDesc”:”快去看看”,”content”:”您有一个订单已发货”,”title”:”发货通知”}</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>buyer</td>\n<td>待寄回</td>\n<td>BGM</td>\n<td>卖家已同意退款退货申请</td>\n<td>2</td>\n</tr>\n<tr>\n<td>6</td>\n<td>buyer</td>\n<td>退款退货失败</td>\n<td>BGM</td>\n<td></td>\n<td>10</td>\n</tr>\n<tr>\n<td>7</td>\n<td>buyer</td>\n<td>退款退货成功</td>\n<td>BGM</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>buyer</td>\n<td>退款退货确认中</td>\n<td>BGM</td>\n<td>卖家已同意退款退货申请</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>seller</td>\n<td>待处理</td>\n<td>BGM</td>\n<td>买家申请退货退款</td>\n<td>4;5</td>\n</tr>\n</tbody></table>\n<h3 id=\"表结构\"><a href=\"#表结构\" class=\"headerlink\" title=\"表结构\"></a>表结构</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- chh_mmplanet_order.chh_object_attribute_values definition</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> `chh_object_attribute_values` (</span><br><span class=\"line\">  `id` <span class=\"type\">varchar</span>(<span class=\"number\">50</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_general_ci <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;主键&#x27;</span>,</span><br><span class=\"line\">  `type` <span class=\"type\">varchar</span>(<span class=\"number\">32</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_general_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;对象类型&#x27;</span>,</span><br><span class=\"line\">  `attribute` <span class=\"type\">varchar</span>(<span class=\"number\">32</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_general_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;对象属性&#x27;</span>,</span><br><span class=\"line\">  `attribute_1` <span class=\"type\">varchar</span>(<span class=\"number\">100</span>) <span class=\"keyword\">COLLATE</span> utf8mb4_general_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `attribute_values` <span class=\"type\">varchar</span>(<span class=\"number\">1000</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_general_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;对象属性值&#x27;</span>,</span><br><span class=\"line\">  `description` <span class=\"type\">varchar</span>(<span class=\"number\">300</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_general_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;属性描述&#x27;</span>,</span><br><span class=\"line\">  <span class=\"keyword\">PRIMARY</span> KEY (`id`)</span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB <span class=\"keyword\">DEFAULT</span> CHARSET<span class=\"operator\">=</span>utf8mb4 <span class=\"keyword\">COLLATE</span><span class=\"operator\">=</span>utf8mb4_general_ci COMMENT<span class=\"operator\">=</span><span class=\"string\">&#x27;object_attribute_values（非常重要，请勿删除任何数据）&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> chh_mmplanet_order.chh_object_attribute_values (id,`type`,`attribute`,attribute_1,attribute_values,description) <span class=\"keyword\">VALUES</span> </span><br><span class=\"line\">(<span class=\"string\">&#x27;1&#x27;</span>,<span class=\"string\">&#x27;productionProcess&#x27;</span>,<span class=\"string\">&#x27;baby&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;[&#123;&quot;step&quot;:&quot;0&quot;,&quot;stepName&quot;:&quot;配色中&quot;&#125;,&#123;&quot;step&quot;:&quot;1&quot;,&quot;stepName&quot;:&quot;精雕细琢中&quot;&#125;,&#123;&quot;step&quot;:&quot;2&quot;,&quot;stepName&quot;:&quot;车缝中&quot;&#125;,&#123;&quot;step&quot;:&quot;3&quot;,&quot;stepName&quot;:&quot;邮寄中&quot;&#125;,&#123;&quot;step&quot;:&quot;4&quot;,&quot;stepName&quot;:&quot;审核中&quot;&#125;,&#123;&quot;step&quot;:&quot;5&quot;,&quot;stepName&quot;:&quot;定样&quot;&#125;]&#x27;</span>,<span class=\"string\">&#x27;娃娃的生产进度&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;10&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;待寄回 &#x27;</span>,<span class=\"string\">&#x27;BGM&#x27;</span>,<span class=\"string\">&#x27;您已经同意买家的退款退货申请&#x27;</span>,<span class=\"string\">&#x27;6;7;8&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;11&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;退款退货确认中&#x27;</span>,<span class=\"string\">&#x27;BGM&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;6;7;9&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;12&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;退款退货成功&#x27;</span>,<span class=\"string\">&#x27;BGM&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;7&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;13&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;退款退货失败&#x27;</span>,<span class=\"string\">&#x27;BGM&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"keyword\">NULL</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;14&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;待处理&#x27;</span>,<span class=\"string\">&#x27;BM&#x27;</span>,<span class=\"string\">&#x27;已提交退款申请 等待卖家处理&#x27;</span>,<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;15&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;已取消&#x27;</span>,<span class=\"string\">&#x27;BM&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;16&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;退款成功&#x27;</span>,<span class=\"string\">&#x27;BM&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;17&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;退款失败&#x27;</span>,<span class=\"string\">&#x27;BM&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;10&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;18&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;待处理&#x27;</span>,<span class=\"string\">&#x27;BM&#x27;</span>,<span class=\"string\">&#x27;买家申请退款&#x27;</span>,<span class=\"string\">&#x27;4;5&#x27;</span>)</span><br><span class=\"line\">;</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> chh_mmplanet_order.chh_object_attribute_values (id,`type`,`attribute`,attribute_1,attribute_values,description) <span class=\"keyword\">VALUES</span> </span><br><span class=\"line\">(<span class=\"string\">&#x27;19&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;已取消&#x27;</span>,<span class=\"string\">&#x27;BM&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;2&#x27;</span>,<span class=\"string\">&#x27;productionProcess&#x27;</span>,<span class=\"string\">&#x27;clothes&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;[&#123;&quot;step&quot;:&quot;0&quot;,&quot;stepName&quot;:&quot;配采开中&quot;&#125;,&#123;&quot;step&quot;:&quot;1&quot;,&quot;stepName&quot;:&quot;精雕细琢中&quot;&#125;,&#123;&quot;step&quot;:&quot;2&quot;,&quot;stepName&quot;:&quot;车缝中&quot;&#125;,&#123;&quot;step&quot;:&quot;3&quot;,&quot;stepName&quot;:&quot;邮寄中&quot;&#125;,&#123;&quot;step&quot;:&quot;4&quot;,&quot;stepName&quot;:&quot;审核中&quot;&#125;,&#123;&quot;step&quot;:&quot;5&quot;,&quot;stepName&quot;:&quot;定样&quot;&#125;]&#x27;</span>,<span class=\"string\">&#x27;娃衣的生产进度&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;20&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;退款成功&#x27;</span>,<span class=\"string\">&#x27;BM&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;21&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;退款失败&#x27;</span>,<span class=\"string\">&#x27;BM&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;22&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;待处理&#x27;</span>,<span class=\"string\">&#x27;SG&#x27;</span>,<span class=\"string\">&#x27;已提交换货申请 等待卖家处理&#x27;</span>,<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;23&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;待寄回&#x27;</span>,<span class=\"string\">&#x27;SG&#x27;</span>,<span class=\"string\">&#x27;卖家已同意换货申请 &#x27;</span>,<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;24&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;换货确认中&#x27;</span>,<span class=\"string\">&#x27;SG&#x27;</span>,<span class=\"string\">&#x27;卖家已同意换货申请 &#x27;</span>,<span class=\"string\">&#x27;12&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;25&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;换货成功&#x27;</span>,<span class=\"string\">&#x27;SG&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>,<span class=\"string\">&#x27;11&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;26&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;换货失败&#x27;</span>,<span class=\"string\">&#x27;SG&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>,<span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;27&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;待处理&#x27;</span>,<span class=\"string\">&#x27;SG&#x27;</span>,<span class=\"string\">&#x27;买家申请换货&#x27;</span>,<span class=\"string\">&#x27;4;5&#x27;</span>)</span><br><span class=\"line\">;</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> chh_mmplanet_order.chh_object_attribute_values (id,`type`,`attribute`,attribute_1,attribute_values,description) <span class=\"keyword\">VALUES</span> </span><br><span class=\"line\">(<span class=\"string\">&#x27;28&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;待寄回&#x27;</span>,<span class=\"string\">&#x27;SG&#x27;</span>,<span class=\"string\">&#x27;您已同意买家的换货申请 &#x27;</span>,<span class=\"string\">&#x27;6;7;8&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;29&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;换货确认中&#x27;</span>,<span class=\"string\">&#x27;SG&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;3&#x27;</span>,<span class=\"string\">&#x27;afterSales&#x27;</span>,<span class=\"string\">&#x27;operation&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;[&#123;&quot;identify&quot;:&quot;1&quot;,&quot;operation&quot;:&quot;取消申请&quot;&#125;,&#123;&quot;identify&quot;:&quot;2&quot;,&quot;operation&quot;:&quot;寄回&quot;&#125;,&#123;&quot;identify&quot;:&quot;3&quot;,&quot;operation&quot;:&quot;再次申请&quot;&#125;,&#123;&quot;identify&quot;:&quot;4&quot;,&quot;operation&quot;:&quot;同意&quot;&#125;,&#123;&quot;identify&quot;:&quot;5&quot;,&quot;operation&quot;:&quot;拒绝&quot;&#125;,&#123;&quot;identify&quot;:&quot;6&quot;,&quot;operation&quot;:&quot;取消订单&quot;&#125;,&#123;&quot;identify&quot;:&quot;7&quot;,&quot;operation&quot;:&quot;查看物流&quot;&#125;,&#123;&quot;identify&quot;:&quot;8&quot;,&quot;operation&quot;:&quot;确认寄回&quot;&#125;,&#123;&quot;identify&quot;:&quot;9&quot;,&quot;operation&quot;:&quot;退款&quot;&#125;,&#123;&quot;identify&quot;:&quot;10&quot;,&quot;operation&quot;:&quot;再次申请&quot;&#125;,&#123;&quot;identify&quot;:&quot;11&quot;,&quot;operation&quot;:&quot;继续换货&quot;&#125;,&#123;&quot;identify&quot;:&quot;12&quot;,&quot;operation&quot;:&quot;确认换货&quot;&#125;,&#123;&quot;identify&quot;:&quot;13&quot;,&quot;operation&quot;:&quot;确认回收&quot;&#125;]&#x27;</span>,<span class=\"string\">&#x27;售后操作&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;30&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;换货成功&#x27;</span>,<span class=\"string\">&#x27;SG&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>,<span class=\"string\">&#x27;7&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;31&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;换货失败&#x27;</span>,<span class=\"string\">&#x27;SG&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;32&#x27;</span>,<span class=\"string\">&#x27;switch&#x27;</span>,<span class=\"string\">&#x27;orderCodeSplitSwitch&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;1&#x27;</span>,<span class=\"string\">&#x27;1开，0关&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;33&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;回收中&#x27;</span>,<span class=\"string\">&#x27;RG&#x27;</span>,<span class=\"string\">&#x27;打样商品回收寄回&#x27;</span>,<span class=\"string\">&#x27;7;13&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;34&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;回收成功&#x27;</span>,<span class=\"string\">&#x27;RG&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>,<span class=\"string\">&#x27;7&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;35&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;回收中&#x27;</span>,<span class=\"string\">&#x27;RG&#x27;</span>,<span class=\"string\">&#x27;打样商品回收寄回&#x27;</span>,<span class=\"keyword\">NULL</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;36&#x27;</span>,<span class=\"string\">&#x27;message&#x27;</span>,<span class=\"string\">&#x27;BGM&#x27;</span>,<span class=\"string\">&#x27;同意&#x27;</span>,<span class=\"string\">&#x27;&#123;&quot;actionDesc&quot;:&quot;去处理&quot;,&quot;content&quot;:&quot;您的订单#商品名称#卖家已同意退款退货&quot;,&quot;title&quot;:&quot;卖家同意退款退货申请通知&quot;&#125;&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">;</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> chh_mmplanet_order.chh_object_attribute_values (id,`type`,`attribute`,attribute_1,attribute_values,description) <span class=\"keyword\">VALUES</span> </span><br><span class=\"line\">(<span class=\"string\">&#x27;37&#x27;</span>,<span class=\"string\">&#x27;message&#x27;</span>,<span class=\"string\">&#x27;BGM&#x27;</span>,<span class=\"string\">&#x27;拒绝&#x27;</span>,<span class=\"string\">&#x27;&#123;&quot;actionDesc&quot;:&quot;快去看看&quot;,&quot;content&quot;:&quot;您的商品#商品名称#卖家拒绝退款退货&quot;,&quot;title&quot;:&quot;退款退货失败通知&quot;&#125;&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;38&#x27;</span>,<span class=\"string\">&#x27;message&#x27;</span>,<span class=\"string\">&#x27;SG&#x27;</span>,<span class=\"string\">&#x27;同意&#x27;</span>,<span class=\"string\">&#x27;&#123;&quot;actionDesc&quot;:&quot;去处理&quot;,&quot;content&quot;:&quot;您的订单#商品名称#卖家已同意换货&quot;,&quot;title&quot;:&quot;卖家同意换货申请通知&quot;&#125;&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;39&#x27;</span>,<span class=\"string\">&#x27;message&#x27;</span>,<span class=\"string\">&#x27;SG&#x27;</span>,<span class=\"string\">&#x27;拒绝&#x27;</span>,<span class=\"string\">&#x27;&#123;&quot;actionDesc&quot;:&quot;快去看看&quot;,&quot;content&quot;:&quot;您的商品#商品名称#卖家拒绝换货&quot;,&quot;title&quot;:&quot;换货失败通知&quot;&#125;&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;4&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;待处理&#x27;</span>,<span class=\"string\">&#x27;BGM&#x27;</span>,<span class=\"string\">&#x27;已提交退款退货申请 等待卖家处理&#x27;</span>,<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;40&#x27;</span>,<span class=\"string\">&#x27;message&#x27;</span>,<span class=\"string\">&#x27;BM&#x27;</span>,<span class=\"string\">&#x27;同意&#x27;</span>,<span class=\"string\">&#x27;&#123;&quot;actionDesc&quot;:&quot;去看看&quot;,&quot;content&quot;:&quot;您的商品#商品名称#已成功退款&quot;,&quot;title&quot;:&quot;退款成功通知&quot;&#125;&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;41&#x27;</span>,<span class=\"string\">&#x27;message&#x27;</span>,<span class=\"string\">&#x27;BM&#x27;</span>,<span class=\"string\">&#x27;拒绝&#x27;</span>,<span class=\"string\">&#x27;&#123;&quot;actionDesc&quot;:&quot;快去看看&quot;,&quot;content&quot;:&quot;您的商品#商品名称#卖家拒绝退款&quot;,&quot;title&quot;:&quot;退款失败通知&quot;&#125;&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;42&#x27;</span>,<span class=\"string\">&#x27;productionProcess&#x27;</span>,<span class=\"string\">&#x27;presales&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;[&#123;&quot;step&quot;:&quot;0&quot;,&quot;stepName&quot;:&quot;未开始&quot;&#125;,&#123;&quot;step&quot;:&quot;1&quot;,&quot;stepName&quot;:&quot;寄样中&quot;&#125;,&#123;&quot;step&quot;:&quot;2&quot;,&quot;stepName&quot;:&quot;生产中&quot;&#125;,&#123;&quot;step&quot;:&quot;3&quot;,&quot;stepName&quot;:&quot;已完成&quot;&#125;]&#x27;</span>,<span class=\"string\">&#x27;saas大货生产进度&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;43&#x27;</span>,<span class=\"string\">&#x27;message&#x27;</span>,<span class=\"string\">&#x27;SAAS&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;&#123;&quot;actionDesc&quot;:&quot;快去看看&quot;,&quot;content&quot;:&quot;您的商品%s生产进度更新&quot;,&quot;title&quot;:&quot;进度通知&quot;&#125;&#x27;</span>,<span class=\"keyword\">NULL</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;44&#x27;</span>,<span class=\"string\">&#x27;message&#x27;</span>,<span class=\"string\">&#x27;SYNC_LOGISTICS&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;&#123;&quot;actionDesc&quot;:&quot;快去看看&quot;,&quot;content&quot;:&quot;您有一个订单已发货&quot;,&quot;title&quot;:&quot;发货通知&quot;&#125;&#x27;</span>,<span class=\"keyword\">NULL</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;5&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;待寄回&#x27;</span>,<span class=\"string\">&#x27;BGM&#x27;</span>,<span class=\"string\">&#x27;卖家已同意退款退货申请 &#x27;</span>,<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">;</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> chh_mmplanet_order.chh_object_attribute_values (id,`type`,`attribute`,attribute_1,attribute_values,description) <span class=\"keyword\">VALUES</span> </span><br><span class=\"line\">(<span class=\"string\">&#x27;6&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;退款退货失败&#x27;</span>,<span class=\"string\">&#x27;BGM&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>,<span class=\"string\">&#x27;10&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;7&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;退款退货成功&#x27;</span>,<span class=\"string\">&#x27;BGM&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;8&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;退款退货确认中&#x27;</span>,<span class=\"string\">&#x27;BGM&#x27;</span>,<span class=\"string\">&#x27;卖家已同意退款退货申请&#x27;</span>,<span class=\"keyword\">NULL</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;9&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;待处理&#x27;</span>,<span class=\"string\">&#x27;BGM&#x27;</span>,<span class=\"string\">&#x27;买家申请退货退款&#x27;</span>,<span class=\"string\">&#x27;4;5&#x27;</span>)</span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"退款退货\"><a href=\"#退款退货\" class=\"headerlink\" title=\"退款退货\"></a>退款退货</h3><ul>\n<li>买家</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">文案</th>\n<th align=\"center\">状态</th>\n<th align=\"center\">按钮</th>\n<th align=\"center\">备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">已提交退款退货申请 等待卖家处理</td>\n<td align=\"center\">待处理</td>\n<td align=\"center\">取消申请</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">卖家已同意退款退货申请</td>\n<td align=\"center\">待寄回</td>\n<td align=\"center\">寄回</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">卖家已同意退款退货申请</td>\n<td align=\"center\">退款退货确认中</td>\n<td align=\"center\">无</td>\n<td align=\"center\">买家寄回之后显示</td>\n</tr>\n<tr>\n<td align=\"center\">卖家已同意退款退货申请</td>\n<td align=\"center\">退款退货确认中</td>\n<td align=\"center\">无</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">退款退货成功</td>\n<td align=\"center\">无</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">退款退货失败</td>\n<td align=\"center\">再次申请</td>\n<td align=\"center\">无</td>\n</tr>\n</tbody></table>\n<ul>\n<li>卖家</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">文案</th>\n<th align=\"center\">状态</th>\n<th align=\"center\">按钮</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">买家申请退货退款</td>\n<td align=\"center\">待处理</td>\n<td align=\"center\">同意 拒绝</td>\n</tr>\n<tr>\n<td align=\"center\">您已经同意买家的退款退货申请</td>\n<td align=\"center\">待寄回</td>\n<td align=\"center\">取消订单   查看物流   确认寄回</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">退款退货确认中</td>\n<td align=\"center\">取消订单  查看物流   退款</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">退款退货成功</td>\n<td align=\"center\">查看物流</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">退款退货失败</td>\n<td align=\"center\">无</td>\n</tr>\n</tbody></table>\n<h3 id=\"退款\"><a href=\"#退款\" class=\"headerlink\" title=\"退款\"></a>退款</h3><ul>\n<li>买家</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">文案</th>\n<th align=\"center\">状态</th>\n<th align=\"center\">按钮</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">已提交退款申请 等待卖家处理</td>\n<td align=\"center\">待处理</td>\n<td align=\"center\">取消申请</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">已取消</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">退款成功</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">退款失败</td>\n<td align=\"center\">再次申请</td>\n</tr>\n</tbody></table>\n<ul>\n<li>卖家</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">文案</th>\n<th align=\"center\">状态</th>\n<th align=\"center\">按钮</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">买家申请退款</td>\n<td align=\"center\">待处理</td>\n<td align=\"center\">同意 拒绝</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">已取消</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">退款成功</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">退款失败</td>\n<td align=\"center\">无</td>\n</tr>\n</tbody></table>\n<h3 id=\"换货\"><a href=\"#换货\" class=\"headerlink\" title=\"换货\"></a>换货</h3><ul>\n<li>买家</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">文案</th>\n<th align=\"center\">状态</th>\n<th align=\"center\">按钮</th>\n<th align=\"center\">备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">已提交换货申请 等待卖家处理</td>\n<td align=\"center\">待处理</td>\n<td align=\"center\">取消申请</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">卖家已同意换货申请</td>\n<td align=\"center\">待寄回</td>\n<td align=\"center\">寄回</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">卖家已同意换货申请</td>\n<td align=\"center\">换货确认中</td>\n<td align=\"center\">无</td>\n<td align=\"center\">买家寄回之后显示</td>\n</tr>\n<tr>\n<td align=\"center\">卖家已同意换货申请</td>\n<td align=\"center\">换货确认中</td>\n<td align=\"center\">确认换货</td>\n<td align=\"center\">买家确认换货变成换货成功</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">换货成功</td>\n<td align=\"center\">继续换货</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">换货失败</td>\n<td align=\"center\">再次申请</td>\n<td align=\"center\">无</td>\n</tr>\n</tbody></table>\n<ul>\n<li>卖家</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">文案</th>\n<th align=\"center\">状态</th>\n<th align=\"center\">按钮</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">买家申请换货</td>\n<td align=\"center\">待处理</td>\n<td align=\"center\">同意 拒绝</td>\n</tr>\n<tr>\n<td align=\"center\">您已同意买家的换货申请</td>\n<td align=\"center\">待寄回</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">您已同意买家的换货申请</td>\n<td align=\"center\">买家已寄回</td>\n<td align=\"center\">取消订单  查看物流  确认换货</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">换货确认中</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">换货成功</td>\n<td align=\"center\">查看物流</td>\n</tr>\n<tr>\n<td align=\"center\">无</td>\n<td align=\"center\">换货失败</td>\n<td align=\"center\">无</td>\n</tr>\n</tbody></table>\n<h3 id=\"回收\"><a href=\"#回收\" class=\"headerlink\" title=\"回收\"></a>回收</h3><p>经销商</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">文案</th>\n<th align=\"center\">状态</th>\n<th align=\"center\">按钮</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">打样商品回收寄回</td>\n<td align=\"center\">回收中</td>\n<td align=\"center\">查看物流    确认回收</td>\n</tr>\n<tr>\n<td align=\"center\">打样商品回收寄回</td>\n<td align=\"center\">回收成功</td>\n<td align=\"center\">查看物流</td>\n</tr>\n</tbody></table>\n<h3 id=\"表数据\"><a href=\"#表数据\" class=\"headerlink\" title=\"表数据\"></a>表数据</h3><table>\n<thead>\n<tr>\n<th>id</th>\n<th>type</th>\n<th>attribute</th>\n<th>attribute_1</th>\n<th>attribute_values</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>productionProcess</td>\n<td>baby</td>\n<td></td>\n<td>[{“step”:”0”,”stepName”:”配色中”},{“step”:”1”,”stepName”:”精雕细琢中”},{“step”:”2”,”stepName”:”车缝中”},{“step”:”3”,”stepName”:”邮寄中”},{“step”:”4”,”stepName”:”审核中”},{“step”:”5”,”stepName”:”定样”}]</td>\n<td>娃娃的生产进度</td>\n</tr>\n<tr>\n<td>10</td>\n<td>seller</td>\n<td>待寄回</td>\n<td>BGM</td>\n<td>您已经同意买家的退款退货申请</td>\n<td>6;7;8</td>\n</tr>\n<tr>\n<td>11</td>\n<td>seller</td>\n<td>退款退货确认中</td>\n<td>BGM</td>\n<td></td>\n<td>6;7;9</td>\n</tr>\n<tr>\n<td>12</td>\n<td>seller</td>\n<td>退款退货成功</td>\n<td>BGM</td>\n<td></td>\n<td>7</td>\n</tr>\n<tr>\n<td>13</td>\n<td>seller</td>\n<td>退款退货失败</td>\n<td>BGM</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>buyer</td>\n<td>待处理</td>\n<td>BM</td>\n<td>已提交退款申请 等待卖家处理</td>\n<td>1</td>\n</tr>\n<tr>\n<td>15</td>\n<td>buyer</td>\n<td>已取消</td>\n<td>BM</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>buyer</td>\n<td>退款成功</td>\n<td>BM</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td>buyer</td>\n<td>退款失败</td>\n<td>BM</td>\n<td></td>\n<td>10</td>\n</tr>\n<tr>\n<td>18</td>\n<td>seller</td>\n<td>待处理</td>\n<td>BM</td>\n<td>买家申请退款</td>\n<td>4;5</td>\n</tr>\n<tr>\n<td>19</td>\n<td>seller</td>\n<td>已取消</td>\n<td>BM</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>productionProcess</td>\n<td>clothes</td>\n<td></td>\n<td>[{“step”:”0”,”stepName”:”配采开中”},{“step”:”1”,”stepName”:”精雕细琢中”},{“step”:”2”,”stepName”:”车缝中”},{“step”:”3”,”stepName”:”邮寄中”},{“step”:”4”,”stepName”:”审核中”},{“step”:”5”,”stepName”:”定样”}]</td>\n<td>娃衣的生产进度</td>\n</tr>\n<tr>\n<td>20</td>\n<td>seller</td>\n<td>退款成功</td>\n<td>BM</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td>seller</td>\n<td>退款失败</td>\n<td>BM</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td>buyer</td>\n<td>待处理</td>\n<td>SG</td>\n<td>已提交换货申请 等待卖家处理</td>\n<td>1</td>\n</tr>\n<tr>\n<td>23</td>\n<td>buyer</td>\n<td>待寄回</td>\n<td>SG</td>\n<td>卖家已同意换货申请</td>\n<td>2</td>\n</tr>\n<tr>\n<td>24</td>\n<td>buyer</td>\n<td>换货确认中</td>\n<td>SG</td>\n<td>卖家已同意换货申请</td>\n<td>12</td>\n</tr>\n<tr>\n<td>25</td>\n<td>buyer</td>\n<td>换货成功</td>\n<td>SG</td>\n<td></td>\n<td>11</td>\n</tr>\n<tr>\n<td>26</td>\n<td>buyer</td>\n<td>换货失败</td>\n<td>SG</td>\n<td></td>\n<td>3</td>\n</tr>\n<tr>\n<td>27</td>\n<td>seller</td>\n<td>待处理</td>\n<td>SG</td>\n<td>买家申请换货</td>\n<td>4;5</td>\n</tr>\n<tr>\n<td>28</td>\n<td>seller</td>\n<td>待寄回</td>\n<td>SG</td>\n<td>您已同意买家的换货申请</td>\n<td>6;7;8</td>\n</tr>\n<tr>\n<td>29</td>\n<td>seller</td>\n<td>换货确认中</td>\n<td>SG</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>afterSales</td>\n<td>operation</td>\n<td></td>\n<td>[{“identify”:”1”,”operation”:”取消申请”},{“identify”:”2”,”operation”:”寄回”},{“identify”:”3”,”operation”:”再次申请”},{“identify”:”4”,”operation”:”同意”},{“identify”:”5”,”operation”:”拒绝”},{“identify”:”6”,”operation”:”取消订单”},{“identify”:”7”,”operation”:”查看物流”},{“identify”:”8”,”operation”:”确认寄回”},{“identify”:”9”,”operation”:”退款”},{“identify”:”10”,”operation”:”再次申请”},{“identify”:”11”,”operation”:”继续换货”},{“identify”:”12”,”operation”:”确认换货”},{“identify”:”13”,”operation”:”确认回收”}]</td>\n<td>售后操作</td>\n</tr>\n<tr>\n<td>30</td>\n<td>seller</td>\n<td>换货成功</td>\n<td>SG</td>\n<td></td>\n<td>7</td>\n</tr>\n<tr>\n<td>31</td>\n<td>seller</td>\n<td>换货失败</td>\n<td>SG</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>32</td>\n<td>switch</td>\n<td>orderCodeSplitSwitch</td>\n<td></td>\n<td>1</td>\n<td>1开，0关</td>\n</tr>\n<tr>\n<td>33</td>\n<td>seller</td>\n<td>回收中</td>\n<td>RG</td>\n<td>打样商品回收寄回</td>\n<td>7;13</td>\n</tr>\n<tr>\n<td>34</td>\n<td>seller</td>\n<td>回收成功</td>\n<td>RG</td>\n<td></td>\n<td>7</td>\n</tr>\n<tr>\n<td>35</td>\n<td>buyer</td>\n<td>回收中</td>\n<td>RG</td>\n<td>打样商品回收寄回</td>\n<td></td>\n</tr>\n<tr>\n<td>36</td>\n<td>message</td>\n<td>BGM</td>\n<td>同意</td>\n<td>{“actionDesc”:”去处理”,”content”:”您的订单#商品名称#卖家已同意退款退货”,”title”:”卖家同意退款退货申请通知”}</td>\n<td></td>\n</tr>\n<tr>\n<td>37</td>\n<td>message</td>\n<td>BGM</td>\n<td>拒绝</td>\n<td>{“actionDesc”:”快去看看”,”content”:”您的商品#商品名称#卖家拒绝退款退货”,”title”:”退款退货失败通知”}</td>\n<td></td>\n</tr>\n<tr>\n<td>38</td>\n<td>message</td>\n<td>SG</td>\n<td>同意</td>\n<td>{“actionDesc”:”去处理”,”content”:”您的订单#商品名称#卖家已同意换货”,”title”:”卖家同意换货申请通知”}</td>\n<td></td>\n</tr>\n<tr>\n<td>39</td>\n<td>message</td>\n<td>SG</td>\n<td>拒绝</td>\n<td>{“actionDesc”:”快去看看”,”content”:”您的商品#商品名称#卖家拒绝换货”,”title”:”换货失败通知”}</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>buyer</td>\n<td>待处理</td>\n<td>BGM</td>\n<td>已提交退款退货申请 等待卖家处理</td>\n<td>1</td>\n</tr>\n<tr>\n<td>40</td>\n<td>message</td>\n<td>BM</td>\n<td>同意</td>\n<td>{“actionDesc”:”去看看”,”content”:”您的商品#商品名称#已成功退款”,”title”:”退款成功通知”}</td>\n<td></td>\n</tr>\n<tr>\n<td>41</td>\n<td>message</td>\n<td>BM</td>\n<td>拒绝</td>\n<td>{“actionDesc”:”快去看看”,”content”:”您的商品#商品名称#卖家拒绝退款”,”title”:”退款失败通知”}</td>\n<td></td>\n</tr>\n<tr>\n<td>42</td>\n<td>productionProcess</td>\n<td>presales</td>\n<td></td>\n<td>[{“step”:”0”,”stepName”:”未开始”},{“step”:”1”,”stepName”:”寄样中”},{“step”:”2”,”stepName”:”生产中”},{“step”:”3”,”stepName”:”已完成”}]</td>\n<td>saas大货生产进度</td>\n</tr>\n<tr>\n<td>43</td>\n<td>message</td>\n<td>SAAS</td>\n<td></td>\n<td>{“actionDesc”:”快去看看”,”content”:”您的商品%s生产进度更新”,”title”:”进度通知”}</td>\n<td></td>\n</tr>\n<tr>\n<td>44</td>\n<td>message</td>\n<td>SYNC_LOGISTICS</td>\n<td></td>\n<td>{“actionDesc”:”快去看看”,”content”:”您有一个订单已发货”,”title”:”发货通知”}</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>buyer</td>\n<td>待寄回</td>\n<td>BGM</td>\n<td>卖家已同意退款退货申请</td>\n<td>2</td>\n</tr>\n<tr>\n<td>6</td>\n<td>buyer</td>\n<td>退款退货失败</td>\n<td>BGM</td>\n<td></td>\n<td>10</td>\n</tr>\n<tr>\n<td>7</td>\n<td>buyer</td>\n<td>退款退货成功</td>\n<td>BGM</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>buyer</td>\n<td>退款退货确认中</td>\n<td>BGM</td>\n<td>卖家已同意退款退货申请</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>seller</td>\n<td>待处理</td>\n<td>BGM</td>\n<td>买家申请退货退款</td>\n<td>4;5</td>\n</tr>\n</tbody></table>\n<h3 id=\"表结构\"><a href=\"#表结构\" class=\"headerlink\" title=\"表结构\"></a>表结构</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- chh_mmplanet_order.chh_object_attribute_values definition</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> `chh_object_attribute_values` (</span><br><span class=\"line\">  `id` <span class=\"type\">varchar</span>(<span class=\"number\">50</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_general_ci <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;主键&#x27;</span>,</span><br><span class=\"line\">  `type` <span class=\"type\">varchar</span>(<span class=\"number\">32</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_general_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;对象类型&#x27;</span>,</span><br><span class=\"line\">  `attribute` <span class=\"type\">varchar</span>(<span class=\"number\">32</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_general_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;对象属性&#x27;</span>,</span><br><span class=\"line\">  `attribute_1` <span class=\"type\">varchar</span>(<span class=\"number\">100</span>) <span class=\"keyword\">COLLATE</span> utf8mb4_general_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `attribute_values` <span class=\"type\">varchar</span>(<span class=\"number\">1000</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_general_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;对象属性值&#x27;</span>,</span><br><span class=\"line\">  `description` <span class=\"type\">varchar</span>(<span class=\"number\">300</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_general_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;属性描述&#x27;</span>,</span><br><span class=\"line\">  <span class=\"keyword\">PRIMARY</span> KEY (`id`)</span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB <span class=\"keyword\">DEFAULT</span> CHARSET<span class=\"operator\">=</span>utf8mb4 <span class=\"keyword\">COLLATE</span><span class=\"operator\">=</span>utf8mb4_general_ci COMMENT<span class=\"operator\">=</span><span class=\"string\">&#x27;object_attribute_values（非常重要，请勿删除任何数据）&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> chh_mmplanet_order.chh_object_attribute_values (id,`type`,`attribute`,attribute_1,attribute_values,description) <span class=\"keyword\">VALUES</span> </span><br><span class=\"line\">(<span class=\"string\">&#x27;1&#x27;</span>,<span class=\"string\">&#x27;productionProcess&#x27;</span>,<span class=\"string\">&#x27;baby&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;[&#123;&quot;step&quot;:&quot;0&quot;,&quot;stepName&quot;:&quot;配色中&quot;&#125;,&#123;&quot;step&quot;:&quot;1&quot;,&quot;stepName&quot;:&quot;精雕细琢中&quot;&#125;,&#123;&quot;step&quot;:&quot;2&quot;,&quot;stepName&quot;:&quot;车缝中&quot;&#125;,&#123;&quot;step&quot;:&quot;3&quot;,&quot;stepName&quot;:&quot;邮寄中&quot;&#125;,&#123;&quot;step&quot;:&quot;4&quot;,&quot;stepName&quot;:&quot;审核中&quot;&#125;,&#123;&quot;step&quot;:&quot;5&quot;,&quot;stepName&quot;:&quot;定样&quot;&#125;]&#x27;</span>,<span class=\"string\">&#x27;娃娃的生产进度&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;10&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;待寄回 &#x27;</span>,<span class=\"string\">&#x27;BGM&#x27;</span>,<span class=\"string\">&#x27;您已经同意买家的退款退货申请&#x27;</span>,<span class=\"string\">&#x27;6;7;8&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;11&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;退款退货确认中&#x27;</span>,<span class=\"string\">&#x27;BGM&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;6;7;9&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;12&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;退款退货成功&#x27;</span>,<span class=\"string\">&#x27;BGM&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;7&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;13&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;退款退货失败&#x27;</span>,<span class=\"string\">&#x27;BGM&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"keyword\">NULL</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;14&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;待处理&#x27;</span>,<span class=\"string\">&#x27;BM&#x27;</span>,<span class=\"string\">&#x27;已提交退款申请 等待卖家处理&#x27;</span>,<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;15&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;已取消&#x27;</span>,<span class=\"string\">&#x27;BM&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;16&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;退款成功&#x27;</span>,<span class=\"string\">&#x27;BM&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;17&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;退款失败&#x27;</span>,<span class=\"string\">&#x27;BM&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;10&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;18&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;待处理&#x27;</span>,<span class=\"string\">&#x27;BM&#x27;</span>,<span class=\"string\">&#x27;买家申请退款&#x27;</span>,<span class=\"string\">&#x27;4;5&#x27;</span>)</span><br><span class=\"line\">;</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> chh_mmplanet_order.chh_object_attribute_values (id,`type`,`attribute`,attribute_1,attribute_values,description) <span class=\"keyword\">VALUES</span> </span><br><span class=\"line\">(<span class=\"string\">&#x27;19&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;已取消&#x27;</span>,<span class=\"string\">&#x27;BM&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;2&#x27;</span>,<span class=\"string\">&#x27;productionProcess&#x27;</span>,<span class=\"string\">&#x27;clothes&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;[&#123;&quot;step&quot;:&quot;0&quot;,&quot;stepName&quot;:&quot;配采开中&quot;&#125;,&#123;&quot;step&quot;:&quot;1&quot;,&quot;stepName&quot;:&quot;精雕细琢中&quot;&#125;,&#123;&quot;step&quot;:&quot;2&quot;,&quot;stepName&quot;:&quot;车缝中&quot;&#125;,&#123;&quot;step&quot;:&quot;3&quot;,&quot;stepName&quot;:&quot;邮寄中&quot;&#125;,&#123;&quot;step&quot;:&quot;4&quot;,&quot;stepName&quot;:&quot;审核中&quot;&#125;,&#123;&quot;step&quot;:&quot;5&quot;,&quot;stepName&quot;:&quot;定样&quot;&#125;]&#x27;</span>,<span class=\"string\">&#x27;娃衣的生产进度&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;20&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;退款成功&#x27;</span>,<span class=\"string\">&#x27;BM&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;21&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;退款失败&#x27;</span>,<span class=\"string\">&#x27;BM&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;22&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;待处理&#x27;</span>,<span class=\"string\">&#x27;SG&#x27;</span>,<span class=\"string\">&#x27;已提交换货申请 等待卖家处理&#x27;</span>,<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;23&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;待寄回&#x27;</span>,<span class=\"string\">&#x27;SG&#x27;</span>,<span class=\"string\">&#x27;卖家已同意换货申请 &#x27;</span>,<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;24&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;换货确认中&#x27;</span>,<span class=\"string\">&#x27;SG&#x27;</span>,<span class=\"string\">&#x27;卖家已同意换货申请 &#x27;</span>,<span class=\"string\">&#x27;12&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;25&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;换货成功&#x27;</span>,<span class=\"string\">&#x27;SG&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>,<span class=\"string\">&#x27;11&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;26&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;换货失败&#x27;</span>,<span class=\"string\">&#x27;SG&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>,<span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;27&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;待处理&#x27;</span>,<span class=\"string\">&#x27;SG&#x27;</span>,<span class=\"string\">&#x27;买家申请换货&#x27;</span>,<span class=\"string\">&#x27;4;5&#x27;</span>)</span><br><span class=\"line\">;</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> chh_mmplanet_order.chh_object_attribute_values (id,`type`,`attribute`,attribute_1,attribute_values,description) <span class=\"keyword\">VALUES</span> </span><br><span class=\"line\">(<span class=\"string\">&#x27;28&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;待寄回&#x27;</span>,<span class=\"string\">&#x27;SG&#x27;</span>,<span class=\"string\">&#x27;您已同意买家的换货申请 &#x27;</span>,<span class=\"string\">&#x27;6;7;8&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;29&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;换货确认中&#x27;</span>,<span class=\"string\">&#x27;SG&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;3&#x27;</span>,<span class=\"string\">&#x27;afterSales&#x27;</span>,<span class=\"string\">&#x27;operation&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;[&#123;&quot;identify&quot;:&quot;1&quot;,&quot;operation&quot;:&quot;取消申请&quot;&#125;,&#123;&quot;identify&quot;:&quot;2&quot;,&quot;operation&quot;:&quot;寄回&quot;&#125;,&#123;&quot;identify&quot;:&quot;3&quot;,&quot;operation&quot;:&quot;再次申请&quot;&#125;,&#123;&quot;identify&quot;:&quot;4&quot;,&quot;operation&quot;:&quot;同意&quot;&#125;,&#123;&quot;identify&quot;:&quot;5&quot;,&quot;operation&quot;:&quot;拒绝&quot;&#125;,&#123;&quot;identify&quot;:&quot;6&quot;,&quot;operation&quot;:&quot;取消订单&quot;&#125;,&#123;&quot;identify&quot;:&quot;7&quot;,&quot;operation&quot;:&quot;查看物流&quot;&#125;,&#123;&quot;identify&quot;:&quot;8&quot;,&quot;operation&quot;:&quot;确认寄回&quot;&#125;,&#123;&quot;identify&quot;:&quot;9&quot;,&quot;operation&quot;:&quot;退款&quot;&#125;,&#123;&quot;identify&quot;:&quot;10&quot;,&quot;operation&quot;:&quot;再次申请&quot;&#125;,&#123;&quot;identify&quot;:&quot;11&quot;,&quot;operation&quot;:&quot;继续换货&quot;&#125;,&#123;&quot;identify&quot;:&quot;12&quot;,&quot;operation&quot;:&quot;确认换货&quot;&#125;,&#123;&quot;identify&quot;:&quot;13&quot;,&quot;operation&quot;:&quot;确认回收&quot;&#125;]&#x27;</span>,<span class=\"string\">&#x27;售后操作&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;30&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;换货成功&#x27;</span>,<span class=\"string\">&#x27;SG&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>,<span class=\"string\">&#x27;7&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;31&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;换货失败&#x27;</span>,<span class=\"string\">&#x27;SG&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;32&#x27;</span>,<span class=\"string\">&#x27;switch&#x27;</span>,<span class=\"string\">&#x27;orderCodeSplitSwitch&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;1&#x27;</span>,<span class=\"string\">&#x27;1开，0关&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;33&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;回收中&#x27;</span>,<span class=\"string\">&#x27;RG&#x27;</span>,<span class=\"string\">&#x27;打样商品回收寄回&#x27;</span>,<span class=\"string\">&#x27;7;13&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;34&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;回收成功&#x27;</span>,<span class=\"string\">&#x27;RG&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>,<span class=\"string\">&#x27;7&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;35&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;回收中&#x27;</span>,<span class=\"string\">&#x27;RG&#x27;</span>,<span class=\"string\">&#x27;打样商品回收寄回&#x27;</span>,<span class=\"keyword\">NULL</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;36&#x27;</span>,<span class=\"string\">&#x27;message&#x27;</span>,<span class=\"string\">&#x27;BGM&#x27;</span>,<span class=\"string\">&#x27;同意&#x27;</span>,<span class=\"string\">&#x27;&#123;&quot;actionDesc&quot;:&quot;去处理&quot;,&quot;content&quot;:&quot;您的订单#商品名称#卖家已同意退款退货&quot;,&quot;title&quot;:&quot;卖家同意退款退货申请通知&quot;&#125;&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">;</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> chh_mmplanet_order.chh_object_attribute_values (id,`type`,`attribute`,attribute_1,attribute_values,description) <span class=\"keyword\">VALUES</span> </span><br><span class=\"line\">(<span class=\"string\">&#x27;37&#x27;</span>,<span class=\"string\">&#x27;message&#x27;</span>,<span class=\"string\">&#x27;BGM&#x27;</span>,<span class=\"string\">&#x27;拒绝&#x27;</span>,<span class=\"string\">&#x27;&#123;&quot;actionDesc&quot;:&quot;快去看看&quot;,&quot;content&quot;:&quot;您的商品#商品名称#卖家拒绝退款退货&quot;,&quot;title&quot;:&quot;退款退货失败通知&quot;&#125;&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;38&#x27;</span>,<span class=\"string\">&#x27;message&#x27;</span>,<span class=\"string\">&#x27;SG&#x27;</span>,<span class=\"string\">&#x27;同意&#x27;</span>,<span class=\"string\">&#x27;&#123;&quot;actionDesc&quot;:&quot;去处理&quot;,&quot;content&quot;:&quot;您的订单#商品名称#卖家已同意换货&quot;,&quot;title&quot;:&quot;卖家同意换货申请通知&quot;&#125;&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;39&#x27;</span>,<span class=\"string\">&#x27;message&#x27;</span>,<span class=\"string\">&#x27;SG&#x27;</span>,<span class=\"string\">&#x27;拒绝&#x27;</span>,<span class=\"string\">&#x27;&#123;&quot;actionDesc&quot;:&quot;快去看看&quot;,&quot;content&quot;:&quot;您的商品#商品名称#卖家拒绝换货&quot;,&quot;title&quot;:&quot;换货失败通知&quot;&#125;&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;4&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;待处理&#x27;</span>,<span class=\"string\">&#x27;BGM&#x27;</span>,<span class=\"string\">&#x27;已提交退款退货申请 等待卖家处理&#x27;</span>,<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;40&#x27;</span>,<span class=\"string\">&#x27;message&#x27;</span>,<span class=\"string\">&#x27;BM&#x27;</span>,<span class=\"string\">&#x27;同意&#x27;</span>,<span class=\"string\">&#x27;&#123;&quot;actionDesc&quot;:&quot;去看看&quot;,&quot;content&quot;:&quot;您的商品#商品名称#已成功退款&quot;,&quot;title&quot;:&quot;退款成功通知&quot;&#125;&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;41&#x27;</span>,<span class=\"string\">&#x27;message&#x27;</span>,<span class=\"string\">&#x27;BM&#x27;</span>,<span class=\"string\">&#x27;拒绝&#x27;</span>,<span class=\"string\">&#x27;&#123;&quot;actionDesc&quot;:&quot;快去看看&quot;,&quot;content&quot;:&quot;您的商品#商品名称#卖家拒绝退款&quot;,&quot;title&quot;:&quot;退款失败通知&quot;&#125;&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;42&#x27;</span>,<span class=\"string\">&#x27;productionProcess&#x27;</span>,<span class=\"string\">&#x27;presales&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;[&#123;&quot;step&quot;:&quot;0&quot;,&quot;stepName&quot;:&quot;未开始&quot;&#125;,&#123;&quot;step&quot;:&quot;1&quot;,&quot;stepName&quot;:&quot;寄样中&quot;&#125;,&#123;&quot;step&quot;:&quot;2&quot;,&quot;stepName&quot;:&quot;生产中&quot;&#125;,&#123;&quot;step&quot;:&quot;3&quot;,&quot;stepName&quot;:&quot;已完成&quot;&#125;]&#x27;</span>,<span class=\"string\">&#x27;saas大货生产进度&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;43&#x27;</span>,<span class=\"string\">&#x27;message&#x27;</span>,<span class=\"string\">&#x27;SAAS&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;&#123;&quot;actionDesc&quot;:&quot;快去看看&quot;,&quot;content&quot;:&quot;您的商品%s生产进度更新&quot;,&quot;title&quot;:&quot;进度通知&quot;&#125;&#x27;</span>,<span class=\"keyword\">NULL</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;44&#x27;</span>,<span class=\"string\">&#x27;message&#x27;</span>,<span class=\"string\">&#x27;SYNC_LOGISTICS&#x27;</span>,<span class=\"keyword\">NULL</span>,<span class=\"string\">&#x27;&#123;&quot;actionDesc&quot;:&quot;快去看看&quot;,&quot;content&quot;:&quot;您有一个订单已发货&quot;,&quot;title&quot;:&quot;发货通知&quot;&#125;&#x27;</span>,<span class=\"keyword\">NULL</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;5&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;待寄回&#x27;</span>,<span class=\"string\">&#x27;BGM&#x27;</span>,<span class=\"string\">&#x27;卖家已同意退款退货申请 &#x27;</span>,<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">;</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> chh_mmplanet_order.chh_object_attribute_values (id,`type`,`attribute`,attribute_1,attribute_values,description) <span class=\"keyword\">VALUES</span> </span><br><span class=\"line\">(<span class=\"string\">&#x27;6&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;退款退货失败&#x27;</span>,<span class=\"string\">&#x27;BGM&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>,<span class=\"string\">&#x27;10&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;7&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;退款退货成功&#x27;</span>,<span class=\"string\">&#x27;BGM&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>,<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;8&#x27;</span>,<span class=\"string\">&#x27;buyer&#x27;</span>,<span class=\"string\">&#x27;退款退货确认中&#x27;</span>,<span class=\"string\">&#x27;BGM&#x27;</span>,<span class=\"string\">&#x27;卖家已同意退款退货申请&#x27;</span>,<span class=\"keyword\">NULL</span>)</span><br><span class=\"line\">,(<span class=\"string\">&#x27;9&#x27;</span>,<span class=\"string\">&#x27;seller&#x27;</span>,<span class=\"string\">&#x27;待处理&#x27;</span>,<span class=\"string\">&#x27;BGM&#x27;</span>,<span class=\"string\">&#x27;买家申请退货退款&#x27;</span>,<span class=\"string\">&#x27;4;5&#x27;</span>)</span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure>\n\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cl0vrkopv000110lnapc795ve","tag_id":"cl0vrkoq2000410ln15ij5hxi","_id":"cl0vrkoq7000910lnebz42dlk"},{"post_id":"cl0vrkoq7000a10ln3itbec95","tag_id":"cl0vrkoq2000410ln15ij5hxi","_id":"cl0vrkoq9000d10lnhy7u3pxk"},{"post_id":"cl0vrkopz000310ln4qhm67n3","tag_id":"cl0vrkoq6000810lngkq42smf","_id":"cl0vrkoq9000e10lneibjh2jm"},{"post_id":"cl0vrkoq3000510lnhm82hpqb","tag_id":"cl0vrkoq9000c10lncafad17t","_id":"cl0vrkoqa000g10ln099adngr"},{"post_id":"cl0vrkoq5000610ln47othejd","tag_id":"cl0vrkoq9000f10lnchpd3h0f","_id":"cl0vrkoqa000i10ln4xbg59hq"},{"post_id":"cl0vrkoq6000710lnbou89t0j","tag_id":"cl0vrkoqa000h10ln1rcn2fmi","_id":"cl0vrkoqb000k10lngipx7v6a"},{"post_id":"cl0vrkoq8000b10lnakymd3a5","tag_id":"cl0vrkoqa000j10ln720n5hzq","_id":"cl0vrkoqb000l10ln6xvlgmu1"},{"post_id":"cl0vrkoqc000m10ln61inejxk","tag_id":"cl0vrkoqd000n10ln8e9a3va5","_id":"cl0vrkoqi000o10ln5outa60e"},{"post_id":"cl0vtoqfl0000h8ln0qv70u4x","tag_id":"cl0vrkoqa000j10ln720n5hzq","_id":"cl0vtoqgk0001h8lnaeyadlix"},{"post_id":"cl0w7tahj0000bslnajaw8g8q","tag_id":"cl0vrkoq2000410ln15ij5hxi","_id":"cl0w7tahz0001bslngx9whn62"},{"post_id":"cl0w85rpm0000kwln248m0180","tag_id":"cl0vrkoq2000410ln15ij5hxi","_id":"cl0w85rpu0001kwlncfn1clz8"},{"post_id":"cl0xy078r0000e8ln5kyg22c7","tag_id":"cl0vrkoqa000h10ln1rcn2fmi","_id":"cl0xy07950001e8lnc6he1fo7"},{"post_id":"cl0yxjemr0000hclng5xs6c5n","tag_id":"cl0vrkoqd000n10ln8e9a3va5","_id":"cl0yxjen80001hcln7quydtx0"},{"post_id":"cl2yhjkqe00003kln6lxtedx1","tag_id":"cl0vrkoqa000j10ln720n5hzq","_id":"cl2yhjkqk00013kln09k0654c"},{"post_id":"cl30z7gfq0000p0lnbjsn2q4r","tag_id":"cl30z7gg40001p0lnftt25hhu","_id":"cl30z7ggh0002p0ln1783b855"},{"post_id":"cl319pqdp0000dklnb4z8hq07","tag_id":"cl30z7gg40001p0lnftt25hhu","_id":"cl319pqe50001dkln5vr5f58q"},{"post_id":"cl31azf3f0000k4lne4hdf47q","tag_id":"cl30z7gg40001p0lnftt25hhu","_id":"cl31azf3u0001k4lnax649e7o"},{"post_id":"cl32lvw8400007oln8h3h45ll","tag_id":"cl0vrkoq2000410ln15ij5hxi","_id":"cl32lwcxx00017oln11477oix"},{"post_id":"cl35pld2w00002klngjm1ffw3","tag_id":"cl0vrkoqd000n10ln8e9a3va5","_id":"cl35pld3a00012kln9sfaartp"},{"post_id":"cl3707ohw0000fslnbdmygyfu","tag_id":"cl0vrkoqa000j10ln720n5hzq","_id":"cl3707oih0002fslncdto6hor"},{"post_id":"cl3707oia0001fslngtf27czs","tag_id":"cl3707oik0003fslndy8n46zx","_id":"cl3707oiw0004fsln7xr49ojx"},{"post_id":"cl3kt6val0000v4lnas1404tf","tag_id":"cl0vrkoqa000j10ln720n5hzq","_id":"cl3kt6vav0001v4lnbdx7co33"},{"post_id":"cl5s266j70000lcln7q3scn95","tag_id":"cl0vrkoq9000c10lncafad17t","_id":"cl5s266jd0001lcln7ypp651f"},{"post_id":"cl5sygbtt0000x0ln4236hi5o","tag_id":"cl0vrkoqa000j10ln720n5hzq","_id":"cl5sygbu20002x0lnaypm7hi5"},{"post_id":"cl5sygbtz0001x0ln4ngfbyyg","tag_id":"cl0vrkoqd000n10ln8e9a3va5","_id":"cl5sygbu30004x0ln9ulyani6"},{"post_id":"cl5sygbu20003x0ln7vz1f09z","tag_id":"cl0vrkoqa000j10ln720n5hzq","_id":"cl5sygbu40005x0ln1ept3047"}],"Tag":[{"name":"Java","_id":"cl0vrkoq2000410ln15ij5hxi"},{"name":"WSL","_id":"cl0vrkoq6000810lngkq42smf"},{"name":"Hexo","_id":"cl0vrkoq9000c10lncafad17t"},{"name":"MySql","_id":"cl0vrkoq9000f10lnchpd3h0f"},{"name":"MyBatis","_id":"cl0vrkoqa000h10ln1rcn2fmi"},{"name":"Design","_id":"cl0vrkoqa000j10ln720n5hzq"},{"name":"Other","_id":"cl0vrkoqd000n10ln8e9a3va5"},{"name":"Diary","_id":"cl0z7zet40001aclnbc3lenxg"},{"name":"牛客网华为题目","_id":"cl30z7gg40001p0lnftt25hhu"},{"name":"Spring","_id":"cl3707oik0003fslndy8n46zx"}]}}